name: ðŸš€ Advanced Issue Coordination & Project Management

on:
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled, assigned, unassigned]
  issue_comment:
    types: [created, edited]
  pull_request:
    types: [opened, closed, merged]
  schedule:
    - cron: '0 */4 * * *'  # Every 4 hours for coordination sync
    - cron: '0 8 * * 1'    # Weekly planning session
  workflow_dispatch:
    inputs:
      action:
        description: 'Coordination action to perform'
        required: true
        type: choice
        options:
          - 'full-sync'
          - 'priority-review'
          - 'team-assignment'
          - 'milestone-planning'
          - 'velocity-analysis'

permissions:
  issues: write
  pull-requests: write
  contents: read
  projects: write

jobs:
  issue_coordination:
    name: ðŸŽ¯ Issue Coordination Engine
    runs-on: ubuntu-latest
    
    steps:
      - name: ðŸ—ï¸ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ðŸ”§ Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          
      - name: ðŸ¤– Initialize Claude Flow Coordination
        id: claude_flow
        run: |
          echo "ðŸ Initializing Claude Flow coordination..."
          npx claude-flow@alpha hooks pre-task --description "GitHub issue coordination" --auto-spawn-agents false
          
      - name: ðŸ“Š Analyze Issue Context
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs').promises;
            const path = require('path');
            
            // Enhanced issue analysis
            class IssueCoordinator {
              constructor(github, context) {
                this.github = github;
                this.context = context;
                this.issueData = context.payload.issue || context.payload.pull_request;
                this.actionType = context.eventName;
                this.metrics = {
                  velocity: 0,
                  cycleTime: 0,
                  blockers: 0,
                  dependencies: []
                };
              }
              
              async analyze() {
                console.log(`ðŸ” Analyzing ${this.actionType} event...`);
                
                // Get comprehensive issue data
                const issueDetails = await this.getIssueDetails();
                const teamWorkload = await this.analyzeTeamWorkload();
                const projectStatus = await this.getProjectStatus();
                const dependencies = await this.analyzeDependencies();
                
                return {
                  issue: issueDetails,
                  team: teamWorkload,
                  project: projectStatus,
                  dependencies: dependencies,
                  recommendations: await this.generateRecommendations(issueDetails, teamWorkload)
                };
              }
              
              async getIssueDetails() {
                if (!this.issueData) return null;
                
                const labels = (this.issueData.labels || []).map(l => l.name);
                const priority = this.extractPriority(labels);
                const components = this.extractComponents(labels);
                const effort = this.extractEffort(labels);
                
                // Analyze issue content for additional context
                const contentAnalysis = this.analyzeContent(
                  this.issueData.title + ' ' + (this.issueData.body || '')
                );
                
                return {
                  number: this.issueData.number,
                  title: this.issueData.title,
                  state: this.issueData.state,
                  priority: priority,
                  components: components,
                  effort: effort,
                  assignees: (this.issueData.assignees || []).map(a => a.login),
                  createdAt: this.issueData.created_at,
                  updatedAt: this.issueData.updated_at,
                  labels: labels,
                  contentAnalysis: contentAnalysis,
                  age: this.calculateAge(this.issueData.created_at)
                };
              }
              
              extractPriority(labels) {
                const priorities = ['critical', 'high', 'medium', 'low'];
                for (const priority of priorities) {
                  if (labels.includes(`priority:${priority}`) || 
                      labels.includes(`priority-${priority}`)) {
                    return priority;
                  }
                }
                return 'medium'; // default
              }
              
              extractComponents(labels) {
                return labels
                  .filter(l => l.startsWith('component:'))
                  .map(l => l.replace('component:', ''));
              }
              
              extractEffort(labels) {
                const efforts = ['small', 'medium', 'large'];
                for (const effort of efforts) {
                  if (labels.includes(`effort:${effort}`)) {
                    return effort;
                  }
                }
                return null;
              }
              
              analyzeContent(text) {
                const keywords = {
                  urgent: ['urgent', 'critical', 'asap', 'emergency', 'blocking'],
                  security: ['security', 'vulnerability', 'exploit', 'breach'],
                  performance: ['slow', 'performance', 'optimize', 'lag', 'timeout'],
                  bug: ['bug', 'error', 'broken', 'crash', 'fail'],
                  feature: ['feature', 'enhancement', 'add', 'implement', 'new']
                };
                
                const analysis = {};
                for (const [category, terms] of Object.entries(keywords)) {
                  analysis[category] = terms.some(term => 
                    text.toLowerCase().includes(term)
                  );
                }
                
                return analysis;
              }
              
              calculateAge(createdAt) {
                const created = new Date(createdAt);
                const now = new Date();
                return Math.floor((now - created) / (1000 * 60 * 60 * 24));
              }
              
              async analyzeTeamWorkload() {
                // Get all open issues assigned to team members
                const { data: openIssues } = await this.github.rest.issues.listForRepo({
                  owner: this.context.repo.owner,
                  repo: this.context.repo.repo,
                  state: 'open',
                  per_page: 100
                });
                
                const workload = {};
                const priorityCount = {};
                
                for (const issue of openIssues) {
                  const assignees = issue.assignees || [];
                  const priority = this.extractPriority(
                    issue.labels.map(l => l.name)
                  );
                  
                  for (const assignee of assignees) {
                    const login = assignee.login;
                    if (!workload[login]) {
                      workload[login] = {
                        total: 0,
                        critical: 0,
                        high: 0,
                        medium: 0,
                        low: 0,
                        inProgress: 0,
                        blocked: 0
                      };
                    }
                    
                    workload[login].total++;
                    workload[login][priority]++;
                    
                    const labels = issue.labels.map(l => l.name);
                    if (labels.includes('status:in-progress')) {
                      workload[login].inProgress++;
                    }
                    if (labels.includes('status:blocked')) {
                      workload[login].blocked++;
                    }
                  }
                }
                
                // Calculate team capacity
                const teamCapacity = this.calculateTeamCapacity(workload);
                
                return {
                  individual: workload,
                  teamCapacity: teamCapacity,
                  recommendations: this.generateWorkloadRecommendations(workload)
                };
              }
              
              calculateTeamCapacity(workload) {
                const totalIssues = Object.values(workload)
                  .reduce((sum, member) => sum + member.total, 0);
                const avgPerMember = totalIssues / Math.max(Object.keys(workload).length, 1);
                
                const overloaded = Object.entries(workload)
                  .filter(([_, data]) => data.total > avgPerMember * 1.5)
                  .map(([member, _]) => member);
                
                const available = Object.entries(workload)
                  .filter(([_, data]) => data.total < avgPerMember * 0.7)
                  .map(([member, _]) => member);
                
                return {
                  totalIssues,
                  avgPerMember: Math.round(avgPerMember * 10) / 10,
                  overloaded,
                  available,
                  criticalCount: Object.values(workload)
                    .reduce((sum, member) => sum + member.critical, 0)
                };
              }
              
              generateWorkloadRecommendations(workload) {
                const recommendations = [];
                
                for (const [member, data] of Object.entries(workload)) {
                  if (data.critical > 2) {
                    recommendations.push({
                      type: 'workload',
                      severity: 'high',
                      message: `@${member} has ${data.critical} critical issues - consider redistribution`
                    });
                  }
                  if (data.blocked > 3) {
                    recommendations.push({
                      type: 'blocked',
                      severity: 'medium',
                      message: `@${member} has ${data.blocked} blocked issues - needs attention`
                    });
                  }
                  if (data.total > 15) {
                    recommendations.push({
                      type: 'overload',
                      severity: 'high',
                      message: `@${member} is overloaded with ${data.total} issues`
                    });
                  }
                }
                
                return recommendations;
              }
              
              async getProjectStatus() {
                // Get milestone information
                const { data: milestones } = await this.github.rest.issues.listMilestones({
                  owner: this.context.repo.owner,
                  repo: this.context.repo.repo,
                  state: 'open',
                  per_page: 10
                });
                
                const projectMetrics = {
                  activeMilestones: milestones.length,
                  upcomingDeadlines: [],
                  completionRate: 0,
                  velocity: await this.calculateVelocity()
                };
                
                // Analyze milestone progress
                for (const milestone of milestones) {
                  if (milestone.due_on) {
                    const dueDate = new Date(milestone.due_on);
                    const daysUntilDue = Math.floor((dueDate - new Date()) / (1000 * 60 * 60 * 24));
                    
                    if (daysUntilDue < 7) {
                      projectMetrics.upcomingDeadlines.push({
                        title: milestone.title,
                        daysUntilDue,
                        openIssues: milestone.open_issues,
                        closedIssues: milestone.closed_issues,
                        progress: Math.round((milestone.closed_issues / 
                          (milestone.open_issues + milestone.closed_issues)) * 100)
                      });
                    }
                  }
                }
                
                return projectMetrics;
              }
              
              async calculateVelocity() {
                const thirtyDaysAgo = new Date();
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
                
                const { data: closedIssues } = await this.github.rest.issues.listForRepo({
                  owner: this.context.repo.owner,
                  repo: this.context.repo.repo,
                  state: 'closed',
                  since: thirtyDaysAgo.toISOString(),
                  per_page: 100
                });
                
                // Calculate weekly velocity
                const weeklyVelocity = {};
                for (const issue of closedIssues) {
                  if (issue.closed_at) {
                    const closedDate = new Date(issue.closed_at);
                    const weekNumber = this.getWeekNumber(closedDate);
                    weeklyVelocity[weekNumber] = (weeklyVelocity[weekNumber] || 0) + 1;
                  }
                }
                
                const weeks = Object.values(weeklyVelocity);
                const avgVelocity = weeks.length > 0 ? 
                  weeks.reduce((a, b) => a + b, 0) / weeks.length : 0;
                
                return {
                  weekly: weeklyVelocity,
                  average: Math.round(avgVelocity * 10) / 10,
                  trend: this.calculateTrend(weeks)
                };
              }
              
              getWeekNumber(date) {
                const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
                const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
                return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
              }
              
              calculateTrend(values) {
                if (values.length < 2) return 'stable';
                const recent = values.slice(-2);
                const older = values.slice(-4, -2);
                const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
                const olderAvg = older.reduce((a, b) => a + b, 0) / Math.max(older.length, 1);
                
                if (recentAvg > olderAvg * 1.2) return 'improving';
                if (recentAvg < olderAvg * 0.8) return 'declining';
                return 'stable';
              }
              
              async analyzeDependencies() {
                if (!this.issueData) return [];
                
                const body = this.issueData.body || '';
                const dependencies = [];
                
                // Extract issue references
                const issueRefs = body.match(/#\d+/g) || [];
                for (const ref of issueRefs) {
                  const issueNumber = parseInt(ref.substring(1));
                  try {
                    const { data: referencedIssue } = await this.github.rest.issues.get({
                      owner: this.context.repo.owner,
                      repo: this.context.repo.repo,
                      issue_number: issueNumber
                    });
                    
                    dependencies.push({
                      number: issueNumber,
                      title: referencedIssue.title,
                      state: referencedIssue.state,
                      labels: referencedIssue.labels.map(l => l.name),
                      assignees: referencedIssue.assignees.map(a => a.login)
                    });
                  } catch (error) {
                    console.log(`Could not fetch issue ${issueNumber}`);
                  }
                }
                
                // Check for blocking dependencies
                const blockingDeps = dependencies.filter(dep => 
                  dep.state === 'open' && 
                  (dep.labels.includes('status:blocked') || 
                   dep.labels.includes('priority:critical'))
                );
                
                return {
                  all: dependencies,
                  blocking: blockingDeps,
                  hasBlockers: blockingDeps.length > 0
                };
              }
              
              async generateRecommendations(issueDetails, teamWorkload) {
                const recommendations = [];
                
                // Priority-based recommendations
                if (issueDetails && issueDetails.priority === 'critical') {
                  if (issueDetails.assignees.length === 0) {
                    recommendations.push({
                      type: 'assignment',
                      severity: 'critical',
                      action: 'assign-immediately',
                      message: 'Critical issue needs immediate assignment',
                      suggestedAssignees: teamWorkload.teamCapacity.available
                    });
                  }
                  
                  if (issueDetails.age > 1) {
                    recommendations.push({
                      type: 'escalation',
                      severity: 'high',
                      action: 'escalate',
                      message: `Critical issue open for ${issueDetails.age} days`
                    });
                  }
                }
                
                // Workload-based recommendations
                if (issueDetails && issueDetails.assignees.length > 0) {
                  for (const assignee of issueDetails.assignees) {
                    const memberWorkload = teamWorkload.individual[assignee];
                    if (memberWorkload && memberWorkload.total > 10) {
                      recommendations.push({
                        type: 'reassignment',
                        severity: 'medium',
                        action: 'consider-reassignment',
                        message: `@${assignee} is overloaded with ${memberWorkload.total} issues`,
                        suggestedAssignees: teamWorkload.teamCapacity.available
                      });
                    }
                  }
                }
                
                // Age-based recommendations
                if (issueDetails && issueDetails.age > 30) {
                  recommendations.push({
                    type: 'stale',
                    severity: 'low',
                    action: 'review-relevance',
                    message: `Issue is ${issueDetails.age} days old - review if still relevant`
                  });
                }
                
                // Content-based recommendations
                if (issueDetails && issueDetails.contentAnalysis) {
                  if (issueDetails.contentAnalysis.security) {
                    recommendations.push({
                      type: 'security',
                      severity: 'critical',
                      action: 'security-review',
                      message: 'Potential security issue detected - requires security review'
                    });
                  }
                  
                  if (issueDetails.contentAnalysis.urgent && 
                      issueDetails.priority !== 'critical') {
                    recommendations.push({
                      type: 'priority',
                      severity: 'high',
                      action: 'increase-priority',
                      message: 'Content suggests urgency but priority is not critical'
                    });
                  }
                }
                
                return recommendations;
              }
            }
            
            // Execute coordination
            const coordinator = new IssueCoordinator(github, context);
            const analysis = await coordinator.analyze();
            
            // Save analysis results
            const resultsPath = '.github/issue-tracker/analysis-results.json';
            await fs.writeFile(
              resultsPath, 
              JSON.stringify(analysis, null, 2)
            );
            
            // Store in GitHub outputs
            core.setOutput('analysis', JSON.stringify(analysis));
            core.setOutput('hasRecommendations', analysis.recommendations.length > 0);
            
            // Log summary
            console.log('ðŸ“Š Analysis Complete:');
            console.log(`- Issue: ${analysis.issue ? analysis.issue.number : 'N/A'}`);
            console.log(`- Team Capacity: ${JSON.stringify(analysis.team.teamCapacity)}`);
            console.log(`- Recommendations: ${analysis.recommendations.length}`);
            
      - name: ðŸ¤– Execute Coordination Actions
        if: steps.claude_flow.outputs.analysis
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const analysis = JSON.parse('${{ steps.claude_flow.outputs.analysis }}');
            
            // Auto-assignment logic
            if (analysis.issue && analysis.issue.assignees.length === 0) {
              const availableMembers = analysis.team.teamCapacity.available;
              
              if (analysis.issue.priority === 'critical' && availableMembers.length > 0) {
                // Auto-assign critical issues
                await github.rest.issues.addAssignees({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: analysis.issue.number,
                  assignees: [availableMembers[0]]
                });
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: analysis.issue.number,
                  body: `ðŸš¨ **Auto-Assignment Alert**
                  
This critical issue has been automatically assigned to @${availableMembers[0]} based on current team capacity.

**Team Workload Analysis:**
- Available team members: ${availableMembers.join(', ')}
- Average issues per member: ${analysis.team.teamCapacity.avgPerMember}
- Critical issues in queue: ${analysis.team.teamCapacity.criticalCount}

---
*Automated by Issue Coordination System*`
                });
              }
            }
            
            // Handle recommendations
            for (const recommendation of analysis.recommendations) {
              if (recommendation.severity === 'critical') {
                // Create alerts for critical recommendations
                console.log(`ðŸš¨ Critical Recommendation: ${recommendation.message}`);
                
                if (recommendation.type === 'security' && analysis.issue) {
                  // Add security label
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: analysis.issue.number,
                    labels: ['type:security', 'priority:critical']
                  });
                }
              }
            }
            
      - name: ðŸ“Š Update Project Board
        if: github.event_name == 'issues' || github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Project board automation would go here
            // This requires GitHub Projects API v2
            console.log('Project board update would execute here');
            
      - name: ðŸ’¾ Store Coordination Memory
        run: |
          npx claude-flow@alpha hooks post-task --task-id "issue-coordination" --analyze-performance true
          npx claude-flow@alpha hooks notification --message "Issue coordination completed" --telemetry true
          
  velocity_tracking:
    name: ðŸ“ˆ Velocity & Performance Tracking
    runs-on: ubuntu-latest
    if: github.event.schedule == '0 */4 * * *' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: ðŸ—ï¸ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ðŸ“Š Calculate Team Velocity
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const now = new Date();
            const periods = {
              day: 1,
              week: 7,
              sprint: 14,
              month: 30
            };
            
            const velocityData = {};
            
            for (const [period, days] of Object.entries(periods)) {
              const sinceDate = new Date(now);
              sinceDate.setDate(sinceDate.getDate() - days);
              
              // Get closed issues
              const { data: closedIssues } = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'closed',
                since: sinceDate.toISOString(),
                per_page: 100
              });
              
              // Calculate metrics
              const metrics = {
                totalClosed: closedIssues.length,
                byPriority: {},
                byType: {},
                byComponent: {},
                avgCycleTime: 0,
                totalCycleTime: 0
              };
              
              for (const issue of closedIssues) {
                const labels = issue.labels.map(l => l.name);
                
                // Count by priority
                const priority = labels.find(l => l.startsWith('priority:')) || 'none';
                metrics.byPriority[priority] = (metrics.byPriority[priority] || 0) + 1;
                
                // Count by type
                const type = labels.find(l => l.startsWith('type:')) || 'none';
                metrics.byType[type] = (metrics.byType[type] || 0) + 1;
                
                // Count by component
                const components = labels.filter(l => l.startsWith('component:'));
                for (const component of components) {
                  metrics.byComponent[component] = (metrics.byComponent[component] || 0) + 1;
                }
                
                // Calculate cycle time
                if (issue.closed_at) {
                  const created = new Date(issue.created_at);
                  const closed = new Date(issue.closed_at);
                  const cycleTime = (closed - created) / (1000 * 60 * 60 * 24);
                  metrics.totalCycleTime += cycleTime;
                }
              }
              
              // Calculate average cycle time
              if (closedIssues.length > 0) {
                metrics.avgCycleTime = Math.round(
                  (metrics.totalCycleTime / closedIssues.length) * 10
                ) / 10;
              }
              
              velocityData[period] = metrics;
            }
            
            // Store velocity data
            const fs = require('fs').promises;
            await fs.writeFile(
              '.github/issue-tracker/velocity-data.json',
              JSON.stringify(velocityData, null, 2)
            );
            
            console.log('ðŸ“ˆ Velocity Data Updated:', velocityData);
            
  milestone_planning:
    name: ðŸŽ¯ Milestone Planning & Tracking
    runs-on: ubuntu-latest
    if: github.event.schedule == '0 8 * * 1' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'milestone-planning')
    
    steps:
      - name: ðŸ—ï¸ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ðŸ“… Analyze Milestones
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Get all milestones
            const { data: milestones } = await github.rest.issues.listMilestones({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 30
            });
            
            const milestoneAnalysis = [];
            
            for (const milestone of milestones) {
              if (milestone.state === 'open') {
                const analysis = {
                  title: milestone.title,
                  number: milestone.number,
                  dueOn: milestone.due_on,
                  openIssues: milestone.open_issues,
                  closedIssues: milestone.closed_issues,
                  progress: Math.round((milestone.closed_issues / 
                    Math.max(milestone.open_issues + milestone.closed_issues, 1)) * 100),
                  health: 'unknown',
                  risks: [],
                  recommendations: []
                };
                
                // Calculate health status
                if (milestone.due_on) {
                  const dueDate = new Date(milestone.due_on);
                  const now = new Date();
                  const daysUntilDue = Math.floor((dueDate - now) / (1000 * 60 * 60 * 24));
                  const totalDays = Math.floor((dueDate - new Date(milestone.created_at)) / (1000 * 60 * 60 * 24));
                  const daysElapsed = totalDays - daysUntilDue;
                  const expectedProgress = (daysElapsed / totalDays) * 100;
                  
                  analysis.daysUntilDue = daysUntilDue;
                  analysis.expectedProgress = Math.round(expectedProgress);
                  
                  // Determine health
                  if (analysis.progress >= expectedProgress - 10) {
                    analysis.health = 'good';
                  } else if (analysis.progress >= expectedProgress - 25) {
                    analysis.health = 'at-risk';
                    analysis.risks.push('Behind expected progress');
                  } else {
                    analysis.health = 'critical';
                    analysis.risks.push('Significantly behind schedule');
                  }
                  
                  if (daysUntilDue < 7 && analysis.openIssues > 5) {
                    analysis.risks.push('High number of open issues near deadline');
                    analysis.recommendations.push('Consider scope reduction or deadline extension');
                  }
                }
                
                // Get issues in milestone
                const { data: milestoneIssues } = await github.rest.issues.listForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  milestone: milestone.number,
                  state: 'open',
                  per_page: 100
                });
                
                // Analyze blockers
                const blockedIssues = milestoneIssues.filter(issue => 
                  issue.labels.some(l => l.name === 'status:blocked')
                );
                
                if (blockedIssues.length > 0) {
                  analysis.risks.push(`${blockedIssues.length} blocked issues`);
                  analysis.blockedIssues = blockedIssues.map(i => ({
                    number: i.number,
                    title: i.title
                  }));
                }
                
                // Analyze critical issues
                const criticalIssues = milestoneIssues.filter(issue =>
                  issue.labels.some(l => l.name === 'priority:critical')
                );
                
                if (criticalIssues.length > 0) {
                  analysis.criticalCount = criticalIssues.length;
                  analysis.recommendations.push(`Focus on ${criticalIssues.length} critical issues first`);
                }
                
                milestoneAnalysis.push(analysis);
              }
            }
            
            // Generate milestone report
            let report = `# ðŸŽ¯ Milestone Planning Report
            
## ðŸ“Š Active Milestones Overview

| Milestone | Progress | Health | Days Left | Open Issues | Risks |
|-----------|----------|--------|-----------|-------------|-------|
`;
            
            for (const milestone of milestoneAnalysis) {
              const healthEmoji = {
                good: 'ðŸŸ¢',
                'at-risk': 'ðŸŸ¡',
                critical: 'ðŸ”´',
                unknown: 'âšª'
              }[milestone.health];
              
              report += `| ${milestone.title} | ${milestone.progress}% | ${healthEmoji} | ${milestone.daysUntilDue || 'N/A'} | ${milestone.openIssues} | ${milestone.risks.length} |\n`;
            }
            
            report += `\n## ðŸš¨ Risk Assessment\n\n`;
            
            for (const milestone of milestoneAnalysis) {
              if (milestone.risks.length > 0) {
                report += `### ${milestone.title}\n`;
                report += milestone.risks.map(r => `- ${r}`).join('\n');
                report += '\n\n';
                
                if (milestone.recommendations.length > 0) {
                  report += `**Recommendations:**\n`;
                  report += milestone.recommendations.map(r => `- ${r}`).join('\n');
                  report += '\n\n';
                }
              }
            }
            
            // Create planning issue
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸŽ¯ Weekly Milestone Planning - ${new Date().toDateString()}`,
              body: report,
              labels: ['report', 'milestone-planning', 'automation']
            });
            
            console.log('Milestone planning report created');