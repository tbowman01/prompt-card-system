name: 🎯 Issue Triage & Auto-Labeling

on:
  issues:
    types: [opened, edited, reopened]
  issue_comment:
    types: [created]

permissions:
  issues: write
  contents: read
  pull-requests: read

jobs:
  triage:
    name: 🔍 Auto-Triage Issues
    runs-on: ubuntu-latest
    if: github.event_name == 'issues'
    
    steps:
      - name: 🏗️ Checkout Repository
        uses: actions/checkout@v4
        
      - name: 🏷️ Auto-Label Based on Title and Body
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const labels = [];
            
            // Priority Detection
            if (title.includes('urgent') || title.includes('critical') || body.includes('urgent') || body.includes('critical')) {
              labels.push('priority:critical');
            } else if (title.includes('high priority') || body.includes('high priority') || title.includes('important')) {
              labels.push('priority:high');
            } else if (title.includes('low priority') || body.includes('low priority') || title.includes('nice to have')) {
              labels.push('priority:low');
            } else {
              labels.push('priority:medium');
            }
            
            // Type Detection
            if (title.includes('bug') || title.includes('error') || title.includes('fail') || title.includes('broken')) {
              labels.push('type:bug');
            } else if (title.includes('feature') || title.includes('enhancement') || body.includes('new feature')) {
              labels.push('type:feature');
            } else if (title.includes('doc') || title.includes('documentation')) {
              labels.push('type:documentation');
            } else if (title.includes('test') || body.includes('testing')) {
              labels.push('type:testing');
            } else if (title.includes('security') || body.includes('security')) {
              labels.push('type:security');
            } else if (title.includes('performance') || body.includes('performance')) {
              labels.push('type:performance');
            }
            
            // Component Detection
            if (title.includes('frontend') || title.includes('ui') || title.includes('react') || body.includes('frontend')) {
              labels.push('component:frontend');
            }
            if (title.includes('backend') || title.includes('api') || title.includes('server') || body.includes('backend')) {
              labels.push('component:backend');
            }
            if (title.includes('database') || title.includes('db') || body.includes('database')) {
              labels.push('component:database');
            }
            if (title.includes('docker') || title.includes('deployment') || body.includes('docker')) {
              labels.push('component:infrastructure');
            }
            if (title.includes('test') || body.includes('jest') || body.includes('playwright')) {
              labels.push('component:testing');
            }
            if (title.includes('monitoring') || title.includes('analytics') || body.includes('monitoring')) {
              labels.push('component:monitoring');
            }
            
            // Effort Estimation
            const wordCount = (title + ' ' + body).split(' ').length;
            if (wordCount > 200 || title.includes('major') || body.includes('complex')) {
              labels.push('effort:large');
            } else if (wordCount > 100 || title.includes('moderate')) {
              labels.push('effort:medium');
            } else {
              labels.push('effort:small');
            }
            
            // Status
            labels.push('status:triage');
            
            // Apply labels
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }
            
      - name: 🎯 Assign Team Members Based on Labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(label => label.name);
            let assignees = [];
            
            // Auto-assign based on component
            if (labels.includes('component:frontend')) {
              // assignees.push('frontend-team-member');
            }
            if (labels.includes('component:backend')) {
              // assignees.push('backend-team-member');
            }
            if (labels.includes('priority:critical')) {
              // assignees.push('tech-lead');
            }
            
            // For now, we'll skip auto-assignment until team members are defined
            console.log('Would assign to:', assignees);
            
      - name: 📋 Add to Project Board
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(label => label.name);
            
            // Add high priority issues to project board automatically
            if (labels.includes('priority:critical') || labels.includes('priority:high')) {
              console.log('High priority issue detected - would add to project board');
              // Note: Project board automation would require additional setup
            }
            
      - name: 🔔 Create Priority Notification
        if: contains(github.event.issue.labels.*.name, 'priority:critical')
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `🚨 **CRITICAL PRIORITY ISSUE DETECTED** 🚨

This issue has been automatically flagged as **critical priority** and requires immediate attention.

**Next Steps:**
- [ ] Technical lead review within 2 hours
- [ ] Impact assessment and mitigation plan
- [ ] Development team assignment
- [ ] Timeline estimation

**Auto-assigned Labels:** ${issue.labels.map(l => l.name).join(', ')}

---
*This is an automated message from the Issue Triage System*`
            });
            
  update_status:
    name: 📊 Update Issue Status
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment'
    
    steps:
      - name: 🏗️ Checkout Repository
        uses: actions/checkout@v4
        
      - name: 🔄 Process Status Updates
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const comment = context.payload.comment;
            const issue = context.payload.issue;
            const commentBody = comment.body.toLowerCase();
            
            let labelsToAdd = [];
            let labelsToRemove = [];
            
            // Status transitions based on comments
            if (commentBody.includes('/in-progress') || commentBody.includes('/working')) {
              labelsToRemove.push('status:triage', 'status:ready');
              labelsToAdd.push('status:in-progress');
            } else if (commentBody.includes('/ready') || commentBody.includes('/approved')) {
              labelsToRemove.push('status:triage', 'status:blocked');
              labelsToAdd.push('status:ready');
            } else if (commentBody.includes('/blocked')) {
              labelsToRemove.push('status:in-progress', 'status:ready');
              labelsToAdd.push('status:blocked');
            } else if (commentBody.includes('/needs-info') || commentBody.includes('/more-info')) {
              labelsToAdd.push('status:needs-info');
            }
            
            // Priority updates
            if (commentBody.includes('/priority critical')) {
              labelsToRemove.push('priority:high', 'priority:medium', 'priority:low');
              labelsToAdd.push('priority:critical');
            } else if (commentBody.includes('/priority high')) {
              labelsToRemove.push('priority:critical', 'priority:medium', 'priority:low');
              labelsToAdd.push('priority:high');
            }
            
            // Apply label changes
            if (labelsToRemove.length > 0) {
              for (const label of labelsToRemove) {
                try {
                  await github.rest.issues.removeLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: issue.number,
                    name: label
                  });
                } catch (error) {
                  console.log(`Label ${label} not found or already removed`);
                }
              }
            }
            
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labelsToAdd
              });
            }