a136cc9b233ef50618d3c587be5ff853
'use strict';
const { getBooleanOption, cppdb } = require('../util');
module.exports = function defineAggregate(name, options) {
    // Validate arguments
    if (typeof name !== 'string') throw new TypeError('Expected first argument to be a string');
    if (typeof options !== 'object' || options === null) throw new TypeError('Expected second argument to be an options object');
    if (!name) throw new TypeError('User-defined function name cannot be an empty string');
    // Interpret options
    const start = 'start' in options ? options.start : null;
    const step = getFunctionOption(options, 'step', true);
    const inverse = getFunctionOption(options, 'inverse', false);
    const result = getFunctionOption(options, 'result', false);
    const safeIntegers = 'safeIntegers' in options ? +getBooleanOption(options, 'safeIntegers') : 2;
    const deterministic = getBooleanOption(options, 'deterministic');
    const directOnly = getBooleanOption(options, 'directOnly');
    const varargs = getBooleanOption(options, 'varargs');
    let argCount = -1;
    // Determine argument count
    if (!varargs) {
        argCount = Math.max(getLength(step), inverse ? getLength(inverse) : 0);
        if (argCount > 0) argCount -= 1;
        if (argCount > 100) throw new RangeError('User-defined functions cannot have more than 100 arguments');
    }
    this[cppdb].aggregate(start, step, inverse, result, name, argCount, safeIntegers, deterministic, directOnly);
    return this;
};
const getFunctionOption = (options, key, required)=>{
    const value = key in options ? options[key] : null;
    if (typeof value === 'function') return value;
    if (value != null) throw new TypeError(`Expected the "${key}" option to be a function`);
    if (required) throw new TypeError(`Missing required option "${key}"`);
    return null;
};
const getLength = ({ length })=>{
    if (Number.isInteger(length) && length >= 0) return length;
    throw new TypeError('Expected function.length to be a positive integer');
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3Byb21wdC1jYXJkLXN5c3RlbS9ub2RlX21vZHVsZXMvYmV0dGVyLXNxbGl0ZTMvbGliL21ldGhvZHMvYWdncmVnYXRlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IHsgZ2V0Qm9vbGVhbk9wdGlvbiwgY3BwZGIgfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVBZ2dyZWdhdGUobmFtZSwgb3B0aW9ucykge1xuXHQvLyBWYWxpZGF0ZSBhcmd1bWVudHNcblx0aWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBzdHJpbmcnKTtcblx0aWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCBvcHRpb25zID09PSBudWxsKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYW4gb3B0aW9ucyBvYmplY3QnKTtcblx0aWYgKCFuYW1lKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVc2VyLWRlZmluZWQgZnVuY3Rpb24gbmFtZSBjYW5ub3QgYmUgYW4gZW1wdHkgc3RyaW5nJyk7XG5cblx0Ly8gSW50ZXJwcmV0IG9wdGlvbnNcblx0Y29uc3Qgc3RhcnQgPSAnc3RhcnQnIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXJ0IDogbnVsbDtcblx0Y29uc3Qgc3RlcCA9IGdldEZ1bmN0aW9uT3B0aW9uKG9wdGlvbnMsICdzdGVwJywgdHJ1ZSk7XG5cdGNvbnN0IGludmVyc2UgPSBnZXRGdW5jdGlvbk9wdGlvbihvcHRpb25zLCAnaW52ZXJzZScsIGZhbHNlKTtcblx0Y29uc3QgcmVzdWx0ID0gZ2V0RnVuY3Rpb25PcHRpb24ob3B0aW9ucywgJ3Jlc3VsdCcsIGZhbHNlKTtcblx0Y29uc3Qgc2FmZUludGVnZXJzID0gJ3NhZmVJbnRlZ2VycycgaW4gb3B0aW9ucyA/ICtnZXRCb29sZWFuT3B0aW9uKG9wdGlvbnMsICdzYWZlSW50ZWdlcnMnKSA6IDI7XG5cdGNvbnN0IGRldGVybWluaXN0aWMgPSBnZXRCb29sZWFuT3B0aW9uKG9wdGlvbnMsICdkZXRlcm1pbmlzdGljJyk7XG5cdGNvbnN0IGRpcmVjdE9ubHkgPSBnZXRCb29sZWFuT3B0aW9uKG9wdGlvbnMsICdkaXJlY3RPbmx5Jyk7XG5cdGNvbnN0IHZhcmFyZ3MgPSBnZXRCb29sZWFuT3B0aW9uKG9wdGlvbnMsICd2YXJhcmdzJyk7XG5cdGxldCBhcmdDb3VudCA9IC0xO1xuXG5cdC8vIERldGVybWluZSBhcmd1bWVudCBjb3VudFxuXHRpZiAoIXZhcmFyZ3MpIHtcblx0XHRhcmdDb3VudCA9IE1hdGgubWF4KGdldExlbmd0aChzdGVwKSwgaW52ZXJzZSA/IGdldExlbmd0aChpbnZlcnNlKSA6IDApO1xuXHRcdGlmIChhcmdDb3VudCA+IDApIGFyZ0NvdW50IC09IDE7XG5cdFx0aWYgKGFyZ0NvdW50ID4gMTAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVXNlci1kZWZpbmVkIGZ1bmN0aW9ucyBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gMTAwIGFyZ3VtZW50cycpO1xuXHR9XG5cblx0dGhpc1tjcHBkYl0uYWdncmVnYXRlKHN0YXJ0LCBzdGVwLCBpbnZlcnNlLCByZXN1bHQsIG5hbWUsIGFyZ0NvdW50LCBzYWZlSW50ZWdlcnMsIGRldGVybWluaXN0aWMsIGRpcmVjdE9ubHkpO1xuXHRyZXR1cm4gdGhpcztcbn07XG5cbmNvbnN0IGdldEZ1bmN0aW9uT3B0aW9uID0gKG9wdGlvbnMsIGtleSwgcmVxdWlyZWQpID0+IHtcblx0Y29uc3QgdmFsdWUgPSBrZXkgaW4gb3B0aW9ucyA/IG9wdGlvbnNba2V5XSA6IG51bGw7XG5cdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHJldHVybiB2YWx1ZTtcblx0aWYgKHZhbHVlICE9IG51bGwpIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIHRoZSBcIiR7a2V5fVwiIG9wdGlvbiB0byBiZSBhIGZ1bmN0aW9uYCk7XG5cdGlmIChyZXF1aXJlZCkgdGhyb3cgbmV3IFR5cGVFcnJvcihgTWlzc2luZyByZXF1aXJlZCBvcHRpb24gXCIke2tleX1cImApO1xuXHRyZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IGdldExlbmd0aCA9ICh7IGxlbmd0aCB9KSA9PiB7XG5cdGlmIChOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkgJiYgbGVuZ3RoID49IDApIHJldHVybiBsZW5ndGg7XG5cdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGZ1bmN0aW9uLmxlbmd0aCB0byBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbn07XG4iXSwibmFtZXMiOlsiZ2V0Qm9vbGVhbk9wdGlvbiIsImNwcGRiIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZpbmVBZ2dyZWdhdGUiLCJuYW1lIiwib3B0aW9ucyIsIlR5cGVFcnJvciIsInN0YXJ0Iiwic3RlcCIsImdldEZ1bmN0aW9uT3B0aW9uIiwiaW52ZXJzZSIsInJlc3VsdCIsInNhZmVJbnRlZ2VycyIsImRldGVybWluaXN0aWMiLCJkaXJlY3RPbmx5IiwidmFyYXJncyIsImFyZ0NvdW50IiwiTWF0aCIsIm1heCIsImdldExlbmd0aCIsIlJhbmdlRXJyb3IiLCJhZ2dyZWdhdGUiLCJrZXkiLCJyZXF1aXJlZCIsInZhbHVlIiwibGVuZ3RoIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLE1BQU0sRUFBRUEsZ0JBQWdCLEVBQUVDLEtBQUssRUFBRSxHQUFHQyxRQUFRO0FBRTVDQyxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsZ0JBQWdCQyxJQUFJLEVBQUVDLE9BQU87SUFDdEQscUJBQXFCO0lBQ3JCLElBQUksT0FBT0QsU0FBUyxVQUFVLE1BQU0sSUFBSUUsVUFBVTtJQUNsRCxJQUFJLE9BQU9ELFlBQVksWUFBWUEsWUFBWSxNQUFNLE1BQU0sSUFBSUMsVUFBVTtJQUN6RSxJQUFJLENBQUNGLE1BQU0sTUFBTSxJQUFJRSxVQUFVO0lBRS9CLG9CQUFvQjtJQUNwQixNQUFNQyxRQUFRLFdBQVdGLFVBQVVBLFFBQVFFLEtBQUssR0FBRztJQUNuRCxNQUFNQyxPQUFPQyxrQkFBa0JKLFNBQVMsUUFBUTtJQUNoRCxNQUFNSyxVQUFVRCxrQkFBa0JKLFNBQVMsV0FBVztJQUN0RCxNQUFNTSxTQUFTRixrQkFBa0JKLFNBQVMsVUFBVTtJQUNwRCxNQUFNTyxlQUFlLGtCQUFrQlAsVUFBVSxDQUFDUCxpQkFBaUJPLFNBQVMsa0JBQWtCO0lBQzlGLE1BQU1RLGdCQUFnQmYsaUJBQWlCTyxTQUFTO0lBQ2hELE1BQU1TLGFBQWFoQixpQkFBaUJPLFNBQVM7SUFDN0MsTUFBTVUsVUFBVWpCLGlCQUFpQk8sU0FBUztJQUMxQyxJQUFJVyxXQUFXLENBQUM7SUFFaEIsMkJBQTJCO0lBQzNCLElBQUksQ0FBQ0QsU0FBUztRQUNiQyxXQUFXQyxLQUFLQyxHQUFHLENBQUNDLFVBQVVYLE9BQU9FLFVBQVVTLFVBQVVULFdBQVc7UUFDcEUsSUFBSU0sV0FBVyxHQUFHQSxZQUFZO1FBQzlCLElBQUlBLFdBQVcsS0FBSyxNQUFNLElBQUlJLFdBQVc7SUFDMUM7SUFFQSxJQUFJLENBQUNyQixNQUFNLENBQUNzQixTQUFTLENBQUNkLE9BQU9DLE1BQU1FLFNBQVNDLFFBQVFQLE1BQU1ZLFVBQVVKLGNBQWNDLGVBQWVDO0lBQ2pHLE9BQU8sSUFBSTtBQUNaO0FBRUEsTUFBTUwsb0JBQW9CLENBQUNKLFNBQVNpQixLQUFLQztJQUN4QyxNQUFNQyxRQUFRRixPQUFPakIsVUFBVUEsT0FBTyxDQUFDaUIsSUFBSSxHQUFHO0lBQzlDLElBQUksT0FBT0UsVUFBVSxZQUFZLE9BQU9BO0lBQ3hDLElBQUlBLFNBQVMsTUFBTSxNQUFNLElBQUlsQixVQUFVLENBQUMsY0FBYyxFQUFFZ0IsSUFBSSx5QkFBeUIsQ0FBQztJQUN0RixJQUFJQyxVQUFVLE1BQU0sSUFBSWpCLFVBQVUsQ0FBQyx5QkFBeUIsRUFBRWdCLElBQUksQ0FBQyxDQUFDO0lBQ3BFLE9BQU87QUFDUjtBQUVBLE1BQU1ILFlBQVksQ0FBQyxFQUFFTSxNQUFNLEVBQUU7SUFDNUIsSUFBSUMsT0FBT0MsU0FBUyxDQUFDRixXQUFXQSxVQUFVLEdBQUcsT0FBT0E7SUFDcEQsTUFBTSxJQUFJbkIsVUFBVTtBQUNyQiJ9