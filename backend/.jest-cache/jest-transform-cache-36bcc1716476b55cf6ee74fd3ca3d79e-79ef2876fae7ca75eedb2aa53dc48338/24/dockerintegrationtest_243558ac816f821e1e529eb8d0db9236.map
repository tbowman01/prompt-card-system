{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/tests/integration/docker-integration.test.ts"],"sourcesContent":["import request from 'supertest';\nimport { exec } from 'child_process';\nimport { promisify } from 'util';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport assert from 'assert';\n\nconst execAsync = promisify(exec);\n\ninterface DockerService {\n  name: string;\n  container: string;\n  port: number;\n  healthEndpoint: string;\n  expectedResponse?: any;\n}\n\ninterface SystemMetrics {\n  cpu: number;\n  memory: number;\n  networkLatency: number;\n  responseTime: number;\n  throughput: number;\n}\n\ndescribe('Docker Integration Tests - Complete System Verification', () => {\n  const services: DockerService[] = [\n    {\n      name: 'frontend',\n      container: 'prompt-frontend',\n      port: 3000,\n      healthEndpoint: '/api/health'\n    },\n    {\n      name: 'backend',\n      container: 'prompt-backend',\n      port: 3001,\n      healthEndpoint: '/api/health/comprehensive'\n    },\n    {\n      name: 'ollama',\n      container: 'prompt-ollama',\n      port: 11434,\n      healthEndpoint: '/api/version'\n    },\n    {\n      name: 'redis',\n      container: 'prompt-redis',\n      port: 6379,\n      healthEndpoint: '/ping'\n    },\n    {\n      name: 'postgres',\n      container: 'prompt-postgres',\n      port: 5432,\n      healthEndpoint: ''\n    }\n  ];\n\n  let baselineMetrics: SystemMetrics;\n  const testData = {\n    cardId: 'docker-integration-test-card',\n    testExecutionId: '',\n    analyticsSessionId: ''\n  };\n\n  beforeAll(async () => {\n    \n    console.log('🐳 Starting Docker Integration Test Suite');\n    console.log('📊 Establishing baseline performance metrics...');\n    \n    // Establish baseline metrics\n    baselineMetrics = await captureSystemMetrics();\n    \n    console.log('✅ Baseline metrics captured:', baselineMetrics);\n  });\n\n  afterAll(async () => {\n    \n    console.log('🧹 Cleaning up Docker integration test resources...');\n    await cleanupTestResources();\n  });\n\n  describe('🏥 Service Health and Connectivity', () => {\n    it('should verify all Docker services are running and healthy', async () => {\n      const healthResults = [];\n      \n      for (const service of services) {\n        const isHealthy = await checkServiceHealth(service);\n        healthResults.push({ service: service.name, healthy: isHealthy });\n        \n        expect(isHealthy).toBe(true); \n        // `Service ${service.name} is not healthy`;\n      }\n      \n      console.log('✅ All services are healthy:', healthResults);\n    });\n\n    it('should verify inter-service network connectivity', async () => {\n      // Test frontend -> backend connectivity\n      const frontendToBackend = await testNetworkConnectivity(\n        'prompt-frontend', \n        'prompt-backend:3001'\n      );\n      expect(frontendToBackend).toBe(true);\n\n      // Test backend -> ollama connectivity\n      const backendToOllama = await testNetworkConnectivity(\n        'prompt-backend', \n        'prompt-ollama:11434'\n      );\n      expect(backendToOllama).toBe(true);\n\n      // Test backend -> redis connectivity\n      const backendToRedis = await testNetworkConnectivity(\n        'prompt-backend', \n        'prompt-redis:6379'\n      );\n      expect(backendToRedis).toBe(true);\n\n      // Test backend -> postgres connectivity\n      const backendToPostgres = await testNetworkConnectivity(\n        'prompt-backend', \n        'prompt-postgres:5432'\n      );\n      expect(backendToPostgres).toBe(true);\n\n      console.log('✅ All inter-service network connections verified');\n    });\n\n    it('should verify service startup order and dependencies', async () => {\n      const startupOrder = await getServiceStartupOrder();\n      \n      // Verify postgres started before backend\n      expect(startupOrder.postgres).toBeLessThan(startupOrder.backend);\n      \n      // Verify redis started before backend\n      expect(startupOrder.redis).toBeLessThan(startupOrder.backend);\n      \n      // Verify ollama started before backend\n      expect(startupOrder.ollama).toBeLessThan(startupOrder.backend);\n      \n      // Verify backend started before frontend\n      expect(startupOrder.backend).toBeLessThan(startupOrder.frontend);\n      \n      console.log('✅ Service startup order verified:', startupOrder);\n    });\n  });\n\n  describe('🔄 End-to-End Data Flow', () => {\n    it('should complete full prompt card creation and testing workflow', async () => {\n      // 1. Create a prompt card via API\n      const createResponse = await request(`http://localhost:3001`)\n        .post('/api/prompt-cards')\n        .send({\n          name: 'Docker Integration Test Card',\n          description: 'Test card for Docker integration testing',\n          prompts: [\n            {\n              role: 'user',\n              content: 'What is 2 + 2?'\n            }\n          ],\n          model: 'llama2:7b',\n          parameters: {\n            temperature: 0.1,\n            maxTokens: 100\n          }\n        })\n        .expect(201);\n\n      testData.cardId = createResponse.body.data.id;\n      expect(createResponse.body.success).toBe(true);\n      expect(createResponse.body.data).toHaveProperty('id');\n\n      // 2. Execute tests on the prompt card\n      const testResponse = await request(`http://localhost:3001`)\n        .post('/api/test-execution')\n        .send({\n          cardId: testData.cardId,\n          testCases: [\n            {\n              id: 'math-test-1',\n              input: 'What is 2 + 2?',\n              expectedOutput: '4'\n            },\n            {\n              id: 'math-test-2', \n              input: 'What is 5 + 3?',\n              expectedOutput: '8'\n            }\n          ],\n          model: 'llama2:7b'\n        })\n        .expect(200);\n\n      testData.testExecutionId = testResponse.body.data.executionId;\n      expect(testResponse.body.success).toBe(true);\n      \n      // 3. Wait for test completion and verify results\n      await waitForTestCompletion(testData.testExecutionId);\n      \n      const resultsResponse = await request(`http://localhost:3001`)\n        .get(`/api/test-execution/${testData.testExecutionId}/results`)\n        .expect(200);\n\n      expect(resultsResponse.body.success).toBe(true);\n      expect(resultsResponse.body.data).toHaveProperty('testResults');\n      expect(Array.isArray(resultsResponse.body.data.testResults)).toBe(true);\n\n      console.log('✅ Complete workflow verified successfully');\n    });\n\n    it('should verify real-time WebSocket communication', async () => {\n      const WebSocket = require('ws');\n      const ws = new WebSocket('ws://localhost:3001');\n      \n      let connectionEstablished = false;\n      let progressUpdatesReceived = 0;\n\n      return new Promise((resolve, reject) => {\n        const timeout = setTimeout(() => {\n          reject(new Error('WebSocket test timed out'));\n        }, 30000);\n\n        ws.on('open', () => {\n          connectionEstablished = true;\n          \n          // Subscribe to test execution updates\n          ws.send(JSON.stringify({\n            type: 'subscribe',\n            channel: 'test-execution',\n            executionId: testData.testExecutionId\n          }));\n        });\n\n        ws.on('message', (data: string) => {\n          const message = JSON.parse(data);\n          \n          if (message.type === 'progress' || message.type === 'update') {\n            progressUpdatesReceived++;\n          }\n          \n          if (message.type === 'completed' || progressUpdatesReceived >= 2) {\n            clearTimeout(timeout);\n            expect(connectionEstablished).toBe(true);\n            expect(progressUpdatesReceived).toBeGreaterThan(0);\n            ws.close();\n            resolve(undefined);\n          }\n        });\n\n        ws.on('error', (error: Error) => {\n          clearTimeout(timeout);\n          reject(error);\n        });\n      });\n    });\n\n    it('should verify analytics data collection and aggregation', async () => {\n      // Trigger analytics collection\n      const analyticsResponse = await request(`http://localhost:3001`)\n        .post('/api/analytics/collect')\n        .send({\n          event: 'test_execution_completed',\n          cardId: testData.cardId,\n          executionId: testData.testExecutionId,\n          metadata: {\n            testType: 'docker-integration',\n            environment: 'container'\n          }\n        })\n        .expect(200);\n\n      testData.analyticsSessionId = analyticsResponse.body.data.sessionId;\n      \n      // Retrieve analytics data\n      const metricsResponse = await request(`http://localhost:3001`)\n        .get('/api/analytics/metrics')\n        .query({ \n          sessionId: testData.analyticsSessionId,\n          timeRange: '1h'\n        })\n        .expect(200);\n\n      expect(metricsResponse.body.success).toBe(true);\n      expect(metricsResponse.body.data).toHaveProperty('executionMetrics');\n      expect(metricsResponse.body.data).toHaveProperty('performanceMetrics');\n\n      console.log('✅ Analytics data collection verified');\n    });\n  });\n\n  describe('⚡ Performance and Load Testing', () => {\n    it('should handle concurrent requests across services', async () => {\n      const concurrentRequests = 20;\n      const requests = [];\n      \n      // Create concurrent requests\n      for (let i = 0; i < concurrentRequests; i++) {\n        requests.push(\n          request(`http://localhost:3001`)\n            .get('/api/health/comprehensive')\n            .timeout(10000)\n        );\n        \n        requests.push(\n          request(`http://localhost:3000`)\n            .get('/api/health')\n            .timeout(10000)\n        );\n      }\n\n      const startTime = Date.now();\n      const responses = await Promise.allSettled(requests);\n      const duration = Date.now() - startTime;\n      \n      const successful = responses.filter(r => \n        r.status === 'fulfilled' && r.value.status === 200\n      ).length;\n      \n      const successRate = (successful / responses.length) * 100;\n      \n      expect(successRate).toBeGreaterThan(90); // 90% success rate\n      expect(duration).toBeLessThan(15000); // Under 15 seconds\n      \n      console.log(`✅ Concurrent load test: ${successRate}% success rate in ${duration}ms`);\n    });\n\n    it('should maintain performance under sustained load', async () => {\n      const loadTestDuration = 30000; // 30 seconds\n      const requestInterval = 500; // 500ms between requests\n      \n      const metricsStart = await captureSystemMetrics();\n      const startTime = Date.now();\n      let requestCount = 0;\n      let successCount = 0;\n      \n      const loadTestPromise = new Promise<void>((resolve) => {\n        const interval = setInterval(async () => {\n          if (Date.now() - startTime >= loadTestDuration) {\n            clearInterval(interval);\n            resolve();\n            return;\n          }\n          \n          requestCount++;\n          try {\n            const response = await request(`http://localhost:3001`)\n              .get('/api/health')\n              .timeout(5000);\n            \n            if (response.status === 200) {\n              successCount++;\n            }\n          } catch (error) {\n            // Request failed\n          }\n        }, requestInterval);\n      });\n      \n      await loadTestPromise;\n      const metricsEnd = await captureSystemMetrics();\n      \n      const successRate = (successCount / requestCount) * 100;\n      const performanceDegradation = calculatePerformanceDegradation(\n        metricsStart, \n        metricsEnd\n      );\n      \n      expect(successRate).toBeGreaterThan(85); // 85% success rate under load\n      expect(performanceDegradation).toBeLessThan(30); // Less than 30% degradation\n      \n      console.log(`✅ Sustained load test: ${successRate}% success rate, ${performanceDegradation}% performance degradation`);\n    });\n\n    it('should verify container resource utilization', async () => {\n      const resourceMetrics = await getContainerResourceMetrics();\n      \n      // Verify no container is using excessive resources\n      for (const [containerName, metrics] of Object.entries(resourceMetrics)) {\n        expect(metrics.cpuPercent).toBeLessThan(80); // Less than 80% CPU\n        expect(metrics.memoryPercent).toBeLessThan(85); // Less than 85% memory\n        \n        console.log(`📊 ${containerName}: CPU ${metrics.cpuPercent}%, Memory ${metrics.memoryPercent}%`);\n      }\n      \n      console.log('✅ Container resource utilization within acceptable limits');\n    });\n  });\n\n  describe('🛡️ Security and Error Handling', () => {\n    it('should handle service failures gracefully', async () => {\n      // Temporarily stop Redis to test error handling\n      console.log('🔄 Testing Redis failure scenario...');\n      await execAsync('docker stop prompt-redis');\n      \n      try {\n        // Backend should still respond but with degraded functionality\n        const response = await request(`http://localhost:3001`)\n          .get('/api/health')\n          .expect(200);\n        \n        expect(response.body).toHaveProperty('status');\n        // Health check might report degraded status\n        \n        // Test caching functionality (should gracefully degrade)\n        const cacheTestResponse = await request(`http://localhost:3001`)\n          .post('/api/test-execution')\n          .send({\n            cardId: testData.cardId,\n            testCases: [\n              {\n                id: 'cache-test',\n                input: 'Test without Redis',\n                expectedOutput: 'Should work without cache'\n              }\n            ],\n            model: 'llama2:7b'\n          });\n        \n        // Should still work but might be slower\n        expect([200, 503]).toContain(cacheTestResponse.status);\n        \n      } finally {\n        // Restart Redis\n        await execAsync('docker start prompt-redis');\n        \n        // Wait for Redis to be ready\n        await new Promise(resolve => setTimeout(resolve, 5000));\n        \n        // Verify Redis is back online\n        const redisHealth = await checkServiceHealth(services.find(s => s.name === 'redis')!);\n        expect(redisHealth).toBe(true);\n      }\n      \n      console.log('✅ Service failure handling verified');\n    });\n\n    it('should enforce proper security headers and CORS', async () => {\n      const response = await request(`http://localhost:3001`)\n        .get('/api/health')\n        .expect(200);\n      \n      // Check security headers\n      expect(response.headers).toHaveProperty('x-frame-options');\n      expect(response.headers).toHaveProperty('x-content-type-options');\n      expect(response.headers['x-content-type-options']).toBe('nosniff');\n      \n      // Test CORS\n      const corsResponse = await request(`http://localhost:3001`)\n        .options('/api/health')\n        .set('Origin', 'http://localhost:3000')\n        .expect(200);\n      \n      expect(corsResponse.headers['access-control-allow-origin']).toBeDefined();\n      \n      console.log('✅ Security headers and CORS verified');\n    });\n\n    it('should handle database connection issues', async () => {\n      // Test database connection resilience\n      const dbTestResponse = await request(`http://localhost:3001`)\n        .get('/api/prompt-cards')\n        .expect(200);\n      \n      expect(dbTestResponse.body.success).toBe(true);\n      \n      // Verify database is properly connected\n      const dbHealthResponse = await request(`http://localhost:3001`)\n        .get('/api/health/database')\n        .expect(200);\n      \n      expect(dbHealthResponse.body.database).toHaveProperty('connected');\n      expect(dbHealthResponse.body.database.connected).toBe(true);\n      \n      console.log('✅ Database connection handling verified');\n    });\n  });\n\n  describe('📊 Monitoring and Observability', () => {\n    it('should provide comprehensive health monitoring', async () => {\n      const healthResponse = await request(`http://localhost:3001`)\n        .get('/api/health/comprehensive')\n        .expect(200);\n      \n      expect(healthResponse.body).toHaveProperty('status');\n      expect(healthResponse.body).toHaveProperty('timestamp');\n      expect(healthResponse.body).toHaveProperty('services');\n      expect(healthResponse.body).toHaveProperty('database');\n      expect(healthResponse.body).toHaveProperty('cache');\n      expect(healthResponse.body).toHaveProperty('llm');\n      expect(healthResponse.body).toHaveProperty('system');\n      \n      // Verify all service statuses\n      expect(healthResponse.body.services.backend).toBe('healthy');\n      expect(healthResponse.body.database.connected).toBe(true);\n      expect(healthResponse.body.cache.connected).toBe(true);\n      expect(healthResponse.body.llm.available).toBe(true);\n      \n      console.log('✅ Comprehensive health monitoring verified');\n    });\n\n    it('should collect and export metrics for monitoring', async () => {\n      const metricsResponse = await request(`http://localhost:3001`)\n        .get('/api/metrics')\n        .expect(200);\n      \n      // Should return Prometheus-format metrics\n      expect(metricsResponse.text).toContain('# HELP');\n      expect(metricsResponse.text).toContain('# TYPE');\n      expect(metricsResponse.text).toContain('http_requests_total');\n      expect(metricsResponse.text).toContain('process_cpu_user_seconds_total');\n      \n      console.log('✅ Metrics collection and export verified');\n    });\n  });\n\n  // Helper Functions\n  async function checkServiceHealth(service: DockerService): Promise<boolean> {\n    try {\n      if (service.name === 'redis') {\n        const { stdout } = await execAsync(`docker exec ${service.container} redis-cli ping`);\n        return stdout.trim() === 'PONG';\n      }\n      \n      if (service.name === 'postgres') {\n        const { stdout } = await execAsync(`docker exec ${service.container} pg_isready -U promptcard -d promptcard_dev`);\n        return stdout.includes('accepting connections');\n      }\n      \n      const response = await request(`http://localhost:${service.port}`)\n        .get(service.healthEndpoint)\n        .timeout(10000);\n      \n      return response.status === 200;\n    } catch (error) {\n      console.error(`Health check failed for ${service.name}:`, error.message);\n      return false;\n    }\n  }\n\n  async function testNetworkConnectivity(fromContainer: string, toAddress: string): Promise<boolean> {\n    try {\n      const command = `docker exec ${fromContainer} sh -c \"nc -z ${toAddress.split(':')[0]} ${toAddress.split(':')[1]}\"`;\n      await execAsync(command);\n      return true;\n    } catch (error) {\n      console.error(`Network connectivity test failed from ${fromContainer} to ${toAddress}:`, error.message);\n      return false;\n    }\n  }\n\n  async function getServiceStartupOrder(): Promise<Record<string, number>> {\n    const order: Record<string, number> = {};\n    \n    for (const service of services) {\n      try {\n        const { stdout } = await execAsync(`docker inspect ${service.container} --format='{{.State.StartedAt}}'`);\n        order[service.name] = new Date(stdout.trim()).getTime();\n      } catch (error) {\n        order[service.name] = 0;\n      }\n    }\n    \n    return order;\n  }\n\n  async function captureSystemMetrics(): Promise<SystemMetrics> {\n    try {\n      // CPU usage\n      const cpuInfo = await execAsync(\"docker stats --no-stream --format 'table {{.CPUPerc}}' | tail -n +2 | head -1\");\n      const cpu = parseFloat(cpuInfo.stdout.replace('%', '')) || 0;\n      \n      // Memory usage\n      const memInfo = await execAsync(\"docker stats --no-stream --format 'table {{.MemPerc}}' | tail -n +2 | head -1\");\n      const memory = parseFloat(memInfo.stdout.replace('%', '')) || 0;\n      \n      // Network latency (ping to backend)\n      const latencyStart = Date.now();\n      await request('http://localhost:3001').get('/api/health').timeout(5000);\n      const networkLatency = Date.now() - latencyStart;\n      \n      // Response time for a standard request\n      const responseStart = Date.now();\n      await request('http://localhost:3001').get('/api/prompt-cards').timeout(10000);\n      const responseTime = Date.now() - responseStart;\n      \n      // Throughput (requests per second) - simple estimation\n      const throughputStart = Date.now();\n      const requests = Array(10).fill(null).map(() => \n        request('http://localhost:3001').get('/api/health').timeout(5000)\n      );\n      await Promise.all(requests);\n      const throughputDuration = Date.now() - throughputStart;\n      const throughput = (10 / throughputDuration) * 1000; // requests per second\n      \n      return {\n        cpu,\n        memory,\n        networkLatency,\n        responseTime,\n        throughput\n      };\n    } catch (error) {\n      console.warn('Failed to capture complete system metrics:', error.message);\n      return {\n        cpu: 0,\n        memory: 0,\n        networkLatency: 1000,\n        responseTime: 1000,\n        throughput: 0\n      };\n    }\n  }\n\n  async function waitForTestCompletion(executionId: string, timeout: number = 60000): Promise<void> {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      try {\n        const response = await request(`http://localhost:3001`)\n          .get(`/api/test-execution/${executionId}/status`)\n          .timeout(5000);\n        \n        if (response.body.data.status === 'completed' || response.body.data.status === 'failed') {\n          return;\n        }\n        \n        await new Promise(resolve => setTimeout(resolve, 2000));\n      } catch (error) {\n        await new Promise(resolve => setTimeout(resolve, 2000));\n      }\n    }\n    \n    throw new Error(`Test execution ${executionId} did not complete within ${timeout}ms`);\n  }\n\n  function calculatePerformanceDegradation(start: SystemMetrics, end: SystemMetrics): number {\n    const responseTimeDegradation = ((end.responseTime - start.responseTime) / start.responseTime) * 100;\n    const throughputDegradation = ((start.throughput - end.throughput) / start.throughput) * 100;\n    \n    return Math.max(responseTimeDegradation, throughputDegradation);\n  }\n\n  async function getContainerResourceMetrics(): Promise<Record<string, { cpuPercent: number; memoryPercent: number }>> {\n    const metrics: Record<string, { cpuPercent: number; memoryPercent: number }> = {};\n    \n    try {\n      const { stdout } = await execAsync(\"docker stats --no-stream --format 'table {{.Name}}\\t{{.CPUPerc}}\\t{{.MemPerc}}'\");\n      const lines = stdout.split('\\n').slice(1); // Skip header\n      \n      for (const line of lines) {\n        if (line.trim()) {\n          const [name, cpu, memory] = line.split('\\t');\n          metrics[name] = {\n            cpuPercent: parseFloat(cpu.replace('%', '')),\n            memoryPercent: parseFloat(memory.replace('%', ''))\n          };\n        }\n      }\n    } catch (error) {\n      console.warn('Failed to get container resource metrics:', error.message);\n    }\n    \n    return metrics;\n  }\n\n  async function cleanupTestResources(): Promise<void> {\n    try {\n      // Clean up test data\n      if (testData.cardId && testData.cardId !== 'docker-integration-test-card') {\n        await request(`http://localhost:3001`)\n          .delete(`/api/prompt-cards/${testData.cardId}`)\n          .timeout(5000);\n      }\n      \n      // Clean up test executions\n      if (testData.testExecutionId) {\n        await request(`http://localhost:3001`)\n          .delete(`/api/test-execution/${testData.testExecutionId}`)\n          .timeout(5000);\n      }\n      \n      console.log('✅ Test resources cleaned up');\n    } catch (error) {\n      console.warn('Failed to clean up some test resources:', error.message);\n    }\n  }\n});"],"names":["execAsync","promisify","exec","describe","services","name","container","port","healthEndpoint","baselineMetrics","testData","cardId","testExecutionId","analyticsSessionId","beforeAll","console","log","captureSystemMetrics","afterAll","cleanupTestResources","it","healthResults","service","isHealthy","checkServiceHealth","push","healthy","expect","toBe","frontendToBackend","testNetworkConnectivity","backendToOllama","backendToRedis","backendToPostgres","startupOrder","getServiceStartupOrder","postgres","toBeLessThan","backend","redis","ollama","frontend","createResponse","request","post","send","description","prompts","role","content","model","parameters","temperature","maxTokens","body","data","id","success","toHaveProperty","testResponse","testCases","input","expectedOutput","executionId","waitForTestCompletion","resultsResponse","get","Array","isArray","testResults","WebSocket","require","ws","connectionEstablished","progressUpdatesReceived","Promise","resolve","reject","timeout","setTimeout","Error","on","JSON","stringify","type","channel","message","parse","clearTimeout","toBeGreaterThan","close","undefined","error","analyticsResponse","event","metadata","testType","environment","sessionId","metricsResponse","query","timeRange","concurrentRequests","requests","i","startTime","Date","now","responses","allSettled","duration","successful","filter","r","status","value","length","successRate","loadTestDuration","requestInterval","metricsStart","requestCount","successCount","loadTestPromise","interval","setInterval","clearInterval","response","metricsEnd","performanceDegradation","calculatePerformanceDegradation","resourceMetrics","getContainerResourceMetrics","containerName","metrics","Object","entries","cpuPercent","memoryPercent","cacheTestResponse","toContain","redisHealth","find","s","headers","corsResponse","options","set","toBeDefined","dbTestResponse","dbHealthResponse","database","connected","healthResponse","cache","llm","available","text","stdout","trim","includes","fromContainer","toAddress","command","split","order","getTime","cpuInfo","cpu","parseFloat","replace","memInfo","memory","latencyStart","networkLatency","responseStart","responseTime","throughputStart","fill","map","all","throughputDuration","throughput","warn","start","end","responseTimeDegradation","throughputDegradation","Math","max","lines","slice","line","delete"],"mappings":";;;;kEAAoB;+BACC;sBACK;;;;;;AAK1B,MAAMA,YAAYC,IAAAA,eAAS,EAACC,mBAAI;AAkBhCC,SAAS,2DAA2D;IAClE,MAAMC,WAA4B;QAChC;YACEC,MAAM;YACNC,WAAW;YACXC,MAAM;YACNC,gBAAgB;QAClB;QACA;YACEH,MAAM;YACNC,WAAW;YACXC,MAAM;YACNC,gBAAgB;QAClB;QACA;YACEH,MAAM;YACNC,WAAW;YACXC,MAAM;YACNC,gBAAgB;QAClB;QACA;YACEH,MAAM;YACNC,WAAW;YACXC,MAAM;YACNC,gBAAgB;QAClB;QACA;YACEH,MAAM;YACNC,WAAW;YACXC,MAAM;YACNC,gBAAgB;QAClB;KACD;IAED,IAAIC;IACJ,MAAMC,WAAW;QACfC,QAAQ;QACRC,iBAAiB;QACjBC,oBAAoB;IACtB;IAEAC,UAAU;QAERC,QAAQC,GAAG,CAAC;QACZD,QAAQC,GAAG,CAAC;QAEZ,6BAA6B;QAC7BP,kBAAkB,MAAMQ;QAExBF,QAAQC,GAAG,CAAC,gCAAgCP;IAC9C;IAEAS,SAAS;QAEPH,QAAQC,GAAG,CAAC;QACZ,MAAMG;IACR;IAEAhB,SAAS,sCAAsC;QAC7CiB,GAAG,6DAA6D;YAC9D,MAAMC,gBAAgB,EAAE;YAExB,KAAK,MAAMC,WAAWlB,SAAU;gBAC9B,MAAMmB,YAAY,MAAMC,mBAAmBF;gBAC3CD,cAAcI,IAAI,CAAC;oBAAEH,SAASA,QAAQjB,IAAI;oBAAEqB,SAASH;gBAAU;gBAE/DI,OAAOJ,WAAWK,IAAI,CAAC;YACvB,4CAA4C;YAC9C;YAEAb,QAAQC,GAAG,CAAC,+BAA+BK;QAC7C;QAEAD,GAAG,oDAAoD;YACrD,wCAAwC;YACxC,MAAMS,oBAAoB,MAAMC,wBAC9B,mBACA;YAEFH,OAAOE,mBAAmBD,IAAI,CAAC;YAE/B,sCAAsC;YACtC,MAAMG,kBAAkB,MAAMD,wBAC5B,kBACA;YAEFH,OAAOI,iBAAiBH,IAAI,CAAC;YAE7B,qCAAqC;YACrC,MAAMI,iBAAiB,MAAMF,wBAC3B,kBACA;YAEFH,OAAOK,gBAAgBJ,IAAI,CAAC;YAE5B,wCAAwC;YACxC,MAAMK,oBAAoB,MAAMH,wBAC9B,kBACA;YAEFH,OAAOM,mBAAmBL,IAAI,CAAC;YAE/Bb,QAAQC,GAAG,CAAC;QACd;QAEAI,GAAG,wDAAwD;YACzD,MAAMc,eAAe,MAAMC;YAE3B,yCAAyC;YACzCR,OAAOO,aAAaE,QAAQ,EAAEC,YAAY,CAACH,aAAaI,OAAO;YAE/D,sCAAsC;YACtCX,OAAOO,aAAaK,KAAK,EAAEF,YAAY,CAACH,aAAaI,OAAO;YAE5D,uCAAuC;YACvCX,OAAOO,aAAaM,MAAM,EAAEH,YAAY,CAACH,aAAaI,OAAO;YAE7D,yCAAyC;YACzCX,OAAOO,aAAaI,OAAO,EAAED,YAAY,CAACH,aAAaO,QAAQ;YAE/D1B,QAAQC,GAAG,CAAC,qCAAqCkB;QACnD;IACF;IAEA/B,SAAS,2BAA2B;QAClCiB,GAAG,kEAAkE;YACnE,kCAAkC;YAClC,MAAMsB,iBAAiB,MAAMC,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACzDC,IAAI,CAAC,qBACLC,IAAI,CAAC;gBACJxC,MAAM;gBACNyC,aAAa;gBACbC,SAAS;oBACP;wBACEC,MAAM;wBACNC,SAAS;oBACX;iBACD;gBACDC,OAAO;gBACPC,YAAY;oBACVC,aAAa;oBACbC,WAAW;gBACb;YACF,GACC1B,MAAM,CAAC;YAEVjB,SAASC,MAAM,GAAG+B,eAAeY,IAAI,CAACC,IAAI,CAACC,EAAE;YAC7C7B,OAAOe,eAAeY,IAAI,CAACG,OAAO,EAAE7B,IAAI,CAAC;YACzCD,OAAOe,eAAeY,IAAI,CAACC,IAAI,EAAEG,cAAc,CAAC;YAEhD,sCAAsC;YACtC,MAAMC,eAAe,MAAMhB,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACvDC,IAAI,CAAC,uBACLC,IAAI,CAAC;gBACJlC,QAAQD,SAASC,MAAM;gBACvBiD,WAAW;oBACT;wBACEJ,IAAI;wBACJK,OAAO;wBACPC,gBAAgB;oBAClB;oBACA;wBACEN,IAAI;wBACJK,OAAO;wBACPC,gBAAgB;oBAClB;iBACD;gBACDZ,OAAO;YACT,GACCvB,MAAM,CAAC;YAEVjB,SAASE,eAAe,GAAG+C,aAAaL,IAAI,CAACC,IAAI,CAACQ,WAAW;YAC7DpC,OAAOgC,aAAaL,IAAI,CAACG,OAAO,EAAE7B,IAAI,CAAC;YAEvC,iDAAiD;YACjD,MAAMoC,sBAAsBtD,SAASE,eAAe;YAEpD,MAAMqD,kBAAkB,MAAMtB,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC1DuB,GAAG,CAAC,CAAC,oBAAoB,EAAExD,SAASE,eAAe,CAAC,QAAQ,CAAC,EAC7De,MAAM,CAAC;YAEVA,OAAOsC,gBAAgBX,IAAI,CAACG,OAAO,EAAE7B,IAAI,CAAC;YAC1CD,OAAOsC,gBAAgBX,IAAI,CAACC,IAAI,EAAEG,cAAc,CAAC;YACjD/B,OAAOwC,MAAMC,OAAO,CAACH,gBAAgBX,IAAI,CAACC,IAAI,CAACc,WAAW,GAAGzC,IAAI,CAAC;YAElEb,QAAQC,GAAG,CAAC;QACd;QAEAI,GAAG,mDAAmD;YACpD,MAAMkD,YAAYC,QAAQ;YAC1B,MAAMC,KAAK,IAAIF,UAAU;YAEzB,IAAIG,wBAAwB;YAC5B,IAAIC,0BAA0B;YAE9B,OAAO,IAAIC,QAAQ,CAACC,SAASC;gBAC3B,MAAMC,UAAUC,WAAW;oBACzBF,OAAO,IAAIG,MAAM;gBACnB,GAAG;gBAEHR,GAAGS,EAAE,CAAC,QAAQ;oBACZR,wBAAwB;oBAExB,sCAAsC;oBACtCD,GAAG3B,IAAI,CAACqC,KAAKC,SAAS,CAAC;wBACrBC,MAAM;wBACNC,SAAS;wBACTtB,aAAarD,SAASE,eAAe;oBACvC;gBACF;gBAEA4D,GAAGS,EAAE,CAAC,WAAW,CAAC1B;oBAChB,MAAM+B,UAAUJ,KAAKK,KAAK,CAAChC;oBAE3B,IAAI+B,QAAQF,IAAI,KAAK,cAAcE,QAAQF,IAAI,KAAK,UAAU;wBAC5DV;oBACF;oBAEA,IAAIY,QAAQF,IAAI,KAAK,eAAeV,2BAA2B,GAAG;wBAChEc,aAAaV;wBACbnD,OAAO8C,uBAAuB7C,IAAI,CAAC;wBACnCD,OAAO+C,yBAAyBe,eAAe,CAAC;wBAChDjB,GAAGkB,KAAK;wBACRd,QAAQe;oBACV;gBACF;gBAEAnB,GAAGS,EAAE,CAAC,SAAS,CAACW;oBACdJ,aAAaV;oBACbD,OAAOe;gBACT;YACF;QACF;QAEAxE,GAAG,2DAA2D;YAC5D,+BAA+B;YAC/B,MAAMyE,oBAAoB,MAAMlD,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC5DC,IAAI,CAAC,0BACLC,IAAI,CAAC;gBACJiD,OAAO;gBACPnF,QAAQD,SAASC,MAAM;gBACvBoD,aAAarD,SAASE,eAAe;gBACrCmF,UAAU;oBACRC,UAAU;oBACVC,aAAa;gBACf;YACF,GACCtE,MAAM,CAAC;YAEVjB,SAASG,kBAAkB,GAAGgF,kBAAkBvC,IAAI,CAACC,IAAI,CAAC2C,SAAS;YAEnE,0BAA0B;YAC1B,MAAMC,kBAAkB,MAAMxD,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC1DuB,GAAG,CAAC,0BACJkC,KAAK,CAAC;gBACLF,WAAWxF,SAASG,kBAAkB;gBACtCwF,WAAW;YACb,GACC1E,MAAM,CAAC;YAEVA,OAAOwE,gBAAgB7C,IAAI,CAACG,OAAO,EAAE7B,IAAI,CAAC;YAC1CD,OAAOwE,gBAAgB7C,IAAI,CAACC,IAAI,EAAEG,cAAc,CAAC;YACjD/B,OAAOwE,gBAAgB7C,IAAI,CAACC,IAAI,EAAEG,cAAc,CAAC;YAEjD3C,QAAQC,GAAG,CAAC;QACd;IACF;IAEAb,SAAS,kCAAkC;QACzCiB,GAAG,qDAAqD;YACtD,MAAMkF,qBAAqB;YAC3B,MAAMC,WAAW,EAAE;YAEnB,6BAA6B;YAC7B,IAAK,IAAIC,IAAI,GAAGA,IAAIF,oBAAoBE,IAAK;gBAC3CD,SAAS9E,IAAI,CACXkB,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC5BuB,GAAG,CAAC,6BACJY,OAAO,CAAC;gBAGbyB,SAAS9E,IAAI,CACXkB,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC5BuB,GAAG,CAAC,eACJY,OAAO,CAAC;YAEf;YAEA,MAAM2B,YAAYC,KAAKC,GAAG;YAC1B,MAAMC,YAAY,MAAMjC,QAAQkC,UAAU,CAACN;YAC3C,MAAMO,WAAWJ,KAAKC,GAAG,KAAKF;YAE9B,MAAMM,aAAaH,UAAUI,MAAM,CAACC,CAAAA,IAClCA,EAAEC,MAAM,KAAK,eAAeD,EAAEE,KAAK,CAACD,MAAM,KAAK,KAC/CE,MAAM;YAER,MAAMC,cAAc,AAACN,aAAaH,UAAUQ,MAAM,GAAI;YAEtDzF,OAAO0F,aAAa5B,eAAe,CAAC,KAAK,mBAAmB;YAC5D9D,OAAOmF,UAAUzE,YAAY,CAAC,QAAQ,mBAAmB;YAEzDtB,QAAQC,GAAG,CAAC,CAAC,wBAAwB,EAAEqG,YAAY,kBAAkB,EAAEP,SAAS,EAAE,CAAC;QACrF;QAEA1F,GAAG,oDAAoD;YACrD,MAAMkG,mBAAmB,OAAO,aAAa;YAC7C,MAAMC,kBAAkB,KAAK,yBAAyB;YAEtD,MAAMC,eAAe,MAAMvG;YAC3B,MAAMwF,YAAYC,KAAKC,GAAG;YAC1B,IAAIc,eAAe;YACnB,IAAIC,eAAe;YAEnB,MAAMC,kBAAkB,IAAIhD,QAAc,CAACC;gBACzC,MAAMgD,WAAWC,YAAY;oBAC3B,IAAInB,KAAKC,GAAG,KAAKF,aAAaa,kBAAkB;wBAC9CQ,cAAcF;wBACdhD;wBACA;oBACF;oBAEA6C;oBACA,IAAI;wBACF,MAAMM,WAAW,MAAMpF,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACnDuB,GAAG,CAAC,eACJY,OAAO,CAAC;wBAEX,IAAIiD,SAASb,MAAM,KAAK,KAAK;4BAC3BQ;wBACF;oBACF,EAAE,OAAO9B,OAAO;oBACd,iBAAiB;oBACnB;gBACF,GAAG2B;YACL;YAEA,MAAMI;YACN,MAAMK,aAAa,MAAM/G;YAEzB,MAAMoG,cAAc,AAACK,eAAeD,eAAgB;YACpD,MAAMQ,yBAAyBC,gCAC7BV,cACAQ;YAGFrG,OAAO0F,aAAa5B,eAAe,CAAC,KAAK,8BAA8B;YACvE9D,OAAOsG,wBAAwB5F,YAAY,CAAC,KAAK,4BAA4B;YAE7EtB,QAAQC,GAAG,CAAC,CAAC,uBAAuB,EAAEqG,YAAY,gBAAgB,EAAEY,uBAAuB,yBAAyB,CAAC;QACvH;QAEA7G,GAAG,gDAAgD;YACjD,MAAM+G,kBAAkB,MAAMC;YAE9B,mDAAmD;YACnD,KAAK,MAAM,CAACC,eAAeC,QAAQ,IAAIC,OAAOC,OAAO,CAACL,iBAAkB;gBACtExG,OAAO2G,QAAQG,UAAU,EAAEpG,YAAY,CAAC,KAAK,oBAAoB;gBACjEV,OAAO2G,QAAQI,aAAa,EAAErG,YAAY,CAAC,KAAK,uBAAuB;gBAEvEtB,QAAQC,GAAG,CAAC,CAAC,GAAG,EAAEqH,cAAc,MAAM,EAAEC,QAAQG,UAAU,CAAC,UAAU,EAAEH,QAAQI,aAAa,CAAC,CAAC,CAAC;YACjG;YAEA3H,QAAQC,GAAG,CAAC;QACd;IACF;IAEAb,SAAS,mCAAmC;QAC1CiB,GAAG,6CAA6C;YAC9C,gDAAgD;YAChDL,QAAQC,GAAG,CAAC;YACZ,MAAMhB,UAAU;YAEhB,IAAI;gBACF,+DAA+D;gBAC/D,MAAM+H,WAAW,MAAMpF,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACnDuB,GAAG,CAAC,eACJvC,MAAM,CAAC;gBAEVA,OAAOoG,SAASzE,IAAI,EAAEI,cAAc,CAAC;gBACrC,4CAA4C;gBAE5C,yDAAyD;gBACzD,MAAMiF,oBAAoB,MAAMhG,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC5DC,IAAI,CAAC,uBACLC,IAAI,CAAC;oBACJlC,QAAQD,SAASC,MAAM;oBACvBiD,WAAW;wBACT;4BACEJ,IAAI;4BACJK,OAAO;4BACPC,gBAAgB;wBAClB;qBACD;oBACDZ,OAAO;gBACT;gBAEF,wCAAwC;gBACxCvB,OAAO;oBAAC;oBAAK;iBAAI,EAAEiH,SAAS,CAACD,kBAAkBzB,MAAM;YAEvD,SAAU;gBACR,gBAAgB;gBAChB,MAAMlH,UAAU;gBAEhB,6BAA6B;gBAC7B,MAAM,IAAI2E,QAAQC,CAAAA,UAAWG,WAAWH,SAAS;gBAEjD,8BAA8B;gBAC9B,MAAMiE,cAAc,MAAMrH,mBAAmBpB,SAAS0I,IAAI,CAACC,CAAAA,IAAKA,EAAE1I,IAAI,KAAK;gBAC3EsB,OAAOkH,aAAajH,IAAI,CAAC;YAC3B;YAEAb,QAAQC,GAAG,CAAC;QACd;QAEAI,GAAG,mDAAmD;YACpD,MAAM2G,WAAW,MAAMpF,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACnDuB,GAAG,CAAC,eACJvC,MAAM,CAAC;YAEV,yBAAyB;YACzBA,OAAOoG,SAASiB,OAAO,EAAEtF,cAAc,CAAC;YACxC/B,OAAOoG,SAASiB,OAAO,EAAEtF,cAAc,CAAC;YACxC/B,OAAOoG,SAASiB,OAAO,CAAC,yBAAyB,EAAEpH,IAAI,CAAC;YAExD,YAAY;YACZ,MAAMqH,eAAe,MAAMtG,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACvDuG,OAAO,CAAC,eACRC,GAAG,CAAC,UAAU,yBACdxH,MAAM,CAAC;YAEVA,OAAOsH,aAAaD,OAAO,CAAC,8BAA8B,EAAEI,WAAW;YAEvErI,QAAQC,GAAG,CAAC;QACd;QAEAI,GAAG,4CAA4C;YAC7C,sCAAsC;YACtC,MAAMiI,iBAAiB,MAAM1G,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACzDuB,GAAG,CAAC,qBACJvC,MAAM,CAAC;YAEVA,OAAO0H,eAAe/F,IAAI,CAACG,OAAO,EAAE7B,IAAI,CAAC;YAEzC,wCAAwC;YACxC,MAAM0H,mBAAmB,MAAM3G,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC3DuB,GAAG,CAAC,wBACJvC,MAAM,CAAC;YAEVA,OAAO2H,iBAAiBhG,IAAI,CAACiG,QAAQ,EAAE7F,cAAc,CAAC;YACtD/B,OAAO2H,iBAAiBhG,IAAI,CAACiG,QAAQ,CAACC,SAAS,EAAE5H,IAAI,CAAC;YAEtDb,QAAQC,GAAG,CAAC;QACd;IACF;IAEAb,SAAS,mCAAmC;QAC1CiB,GAAG,kDAAkD;YACnD,MAAMqI,iBAAiB,MAAM9G,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACzDuB,GAAG,CAAC,6BACJvC,MAAM,CAAC;YAEVA,OAAO8H,eAAenG,IAAI,EAAEI,cAAc,CAAC;YAC3C/B,OAAO8H,eAAenG,IAAI,EAAEI,cAAc,CAAC;YAC3C/B,OAAO8H,eAAenG,IAAI,EAAEI,cAAc,CAAC;YAC3C/B,OAAO8H,eAAenG,IAAI,EAAEI,cAAc,CAAC;YAC3C/B,OAAO8H,eAAenG,IAAI,EAAEI,cAAc,CAAC;YAC3C/B,OAAO8H,eAAenG,IAAI,EAAEI,cAAc,CAAC;YAC3C/B,OAAO8H,eAAenG,IAAI,EAAEI,cAAc,CAAC;YAE3C,8BAA8B;YAC9B/B,OAAO8H,eAAenG,IAAI,CAAClD,QAAQ,CAACkC,OAAO,EAAEV,IAAI,CAAC;YAClDD,OAAO8H,eAAenG,IAAI,CAACiG,QAAQ,CAACC,SAAS,EAAE5H,IAAI,CAAC;YACpDD,OAAO8H,eAAenG,IAAI,CAACoG,KAAK,CAACF,SAAS,EAAE5H,IAAI,CAAC;YACjDD,OAAO8H,eAAenG,IAAI,CAACqG,GAAG,CAACC,SAAS,EAAEhI,IAAI,CAAC;YAE/Cb,QAAQC,GAAG,CAAC;QACd;QAEAI,GAAG,oDAAoD;YACrD,MAAM+E,kBAAkB,MAAMxD,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAC1DuB,GAAG,CAAC,gBACJvC,MAAM,CAAC;YAEV,0CAA0C;YAC1CA,OAAOwE,gBAAgB0D,IAAI,EAAEjB,SAAS,CAAC;YACvCjH,OAAOwE,gBAAgB0D,IAAI,EAAEjB,SAAS,CAAC;YACvCjH,OAAOwE,gBAAgB0D,IAAI,EAAEjB,SAAS,CAAC;YACvCjH,OAAOwE,gBAAgB0D,IAAI,EAAEjB,SAAS,CAAC;YAEvC7H,QAAQC,GAAG,CAAC;QACd;IACF;IAEA,mBAAmB;IACnB,eAAeQ,mBAAmBF,OAAsB;QACtD,IAAI;YACF,IAAIA,QAAQjB,IAAI,KAAK,SAAS;gBAC5B,MAAM,EAAEyJ,MAAM,EAAE,GAAG,MAAM9J,UAAU,CAAC,YAAY,EAAEsB,QAAQhB,SAAS,CAAC,eAAe,CAAC;gBACpF,OAAOwJ,OAAOC,IAAI,OAAO;YAC3B;YAEA,IAAIzI,QAAQjB,IAAI,KAAK,YAAY;gBAC/B,MAAM,EAAEyJ,MAAM,EAAE,GAAG,MAAM9J,UAAU,CAAC,YAAY,EAAEsB,QAAQhB,SAAS,CAAC,2CAA2C,CAAC;gBAChH,OAAOwJ,OAAOE,QAAQ,CAAC;YACzB;YAEA,MAAMjC,WAAW,MAAMpF,IAAAA,kBAAO,EAAC,CAAC,iBAAiB,EAAErB,QAAQf,IAAI,EAAE,EAC9D2D,GAAG,CAAC5C,QAAQd,cAAc,EAC1BsE,OAAO,CAAC;YAEX,OAAOiD,SAASb,MAAM,KAAK;QAC7B,EAAE,OAAOtB,OAAO;YACd7E,QAAQ6E,KAAK,CAAC,CAAC,wBAAwB,EAAEtE,QAAQjB,IAAI,CAAC,CAAC,CAAC,EAAEuF,MAAMN,OAAO;YACvE,OAAO;QACT;IACF;IAEA,eAAexD,wBAAwBmI,aAAqB,EAAEC,SAAiB;QAC7E,IAAI;YACF,MAAMC,UAAU,CAAC,YAAY,EAAEF,cAAc,cAAc,EAAEC,UAAUE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,EAAEF,UAAUE,KAAK,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC;YAClH,MAAMpK,UAAUmK;YAChB,OAAO;QACT,EAAE,OAAOvE,OAAO;YACd7E,QAAQ6E,KAAK,CAAC,CAAC,sCAAsC,EAAEqE,cAAc,IAAI,EAAEC,UAAU,CAAC,CAAC,EAAEtE,MAAMN,OAAO;YACtG,OAAO;QACT;IACF;IAEA,eAAenD;QACb,MAAMkI,QAAgC,CAAC;QAEvC,KAAK,MAAM/I,WAAWlB,SAAU;YAC9B,IAAI;gBACF,MAAM,EAAE0J,MAAM,EAAE,GAAG,MAAM9J,UAAU,CAAC,eAAe,EAAEsB,QAAQhB,SAAS,CAAC,gCAAgC,CAAC;gBACxG+J,KAAK,CAAC/I,QAAQjB,IAAI,CAAC,GAAG,IAAIqG,KAAKoD,OAAOC,IAAI,IAAIO,OAAO;YACvD,EAAE,OAAO1E,OAAO;gBACdyE,KAAK,CAAC/I,QAAQjB,IAAI,CAAC,GAAG;YACxB;QACF;QAEA,OAAOgK;IACT;IAEA,eAAepJ;QACb,IAAI;YACF,YAAY;YACZ,MAAMsJ,UAAU,MAAMvK,UAAU;YAChC,MAAMwK,MAAMC,WAAWF,QAAQT,MAAM,CAACY,OAAO,CAAC,KAAK,QAAQ;YAE3D,eAAe;YACf,MAAMC,UAAU,MAAM3K,UAAU;YAChC,MAAM4K,SAASH,WAAWE,QAAQb,MAAM,CAACY,OAAO,CAAC,KAAK,QAAQ;YAE9D,oCAAoC;YACpC,MAAMG,eAAenE,KAAKC,GAAG;YAC7B,MAAMhE,IAAAA,kBAAO,EAAC,yBAAyBuB,GAAG,CAAC,eAAeY,OAAO,CAAC;YAClE,MAAMgG,iBAAiBpE,KAAKC,GAAG,KAAKkE;YAEpC,uCAAuC;YACvC,MAAME,gBAAgBrE,KAAKC,GAAG;YAC9B,MAAMhE,IAAAA,kBAAO,EAAC,yBAAyBuB,GAAG,CAAC,qBAAqBY,OAAO,CAAC;YACxE,MAAMkG,eAAetE,KAAKC,GAAG,KAAKoE;YAElC,uDAAuD;YACvD,MAAME,kBAAkBvE,KAAKC,GAAG;YAChC,MAAMJ,WAAWpC,MAAM,IAAI+G,IAAI,CAAC,MAAMC,GAAG,CAAC,IACxCxI,IAAAA,kBAAO,EAAC,yBAAyBuB,GAAG,CAAC,eAAeY,OAAO,CAAC;YAE9D,MAAMH,QAAQyG,GAAG,CAAC7E;YAClB,MAAM8E,qBAAqB3E,KAAKC,GAAG,KAAKsE;YACxC,MAAMK,aAAa,AAAC,KAAKD,qBAAsB,MAAM,sBAAsB;YAE3E,OAAO;gBACLb;gBACAI;gBACAE;gBACAE;gBACAM;YACF;QACF,EAAE,OAAO1F,OAAO;YACd7E,QAAQwK,IAAI,CAAC,8CAA8C3F,MAAMN,OAAO;YACxE,OAAO;gBACLkF,KAAK;gBACLI,QAAQ;gBACRE,gBAAgB;gBAChBE,cAAc;gBACdM,YAAY;YACd;QACF;IACF;IAEA,eAAetH,sBAAsBD,WAAmB,EAAEe,UAAkB,KAAK;QAC/E,MAAM2B,YAAYC,KAAKC,GAAG;QAE1B,MAAOD,KAAKC,GAAG,KAAKF,YAAY3B,QAAS;YACvC,IAAI;gBACF,MAAMiD,WAAW,MAAMpF,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EACnDuB,GAAG,CAAC,CAAC,oBAAoB,EAAEH,YAAY,OAAO,CAAC,EAC/Ce,OAAO,CAAC;gBAEX,IAAIiD,SAASzE,IAAI,CAACC,IAAI,CAAC2D,MAAM,KAAK,eAAea,SAASzE,IAAI,CAACC,IAAI,CAAC2D,MAAM,KAAK,UAAU;oBACvF;gBACF;gBAEA,MAAM,IAAIvC,QAAQC,CAAAA,UAAWG,WAAWH,SAAS;YACnD,EAAE,OAAOgB,OAAO;gBACd,MAAM,IAAIjB,QAAQC,CAAAA,UAAWG,WAAWH,SAAS;YACnD;QACF;QAEA,MAAM,IAAII,MAAM,CAAC,eAAe,EAAEjB,YAAY,yBAAyB,EAAEe,QAAQ,EAAE,CAAC;IACtF;IAEA,SAASoD,gCAAgCsD,KAAoB,EAAEC,GAAkB;QAC/E,MAAMC,0BAA0B,AAAED,CAAAA,IAAIT,YAAY,GAAGQ,MAAMR,YAAY,AAAD,IAAKQ,MAAMR,YAAY,GAAI;QACjG,MAAMW,wBAAwB,AAAEH,CAAAA,MAAMF,UAAU,GAAGG,IAAIH,UAAU,AAAD,IAAKE,MAAMF,UAAU,GAAI;QAEzF,OAAOM,KAAKC,GAAG,CAACH,yBAAyBC;IAC3C;IAEA,eAAevD;QACb,MAAME,UAAyE,CAAC;QAEhF,IAAI;YACF,MAAM,EAAEwB,MAAM,EAAE,GAAG,MAAM9J,UAAU;YACnC,MAAM8L,QAAQhC,OAAOM,KAAK,CAAC,MAAM2B,KAAK,CAAC,IAAI,cAAc;YAEzD,KAAK,MAAMC,QAAQF,MAAO;gBACxB,IAAIE,KAAKjC,IAAI,IAAI;oBACf,MAAM,CAAC1J,MAAMmK,KAAKI,OAAO,GAAGoB,KAAK5B,KAAK,CAAC;oBACvC9B,OAAO,CAACjI,KAAK,GAAG;wBACdoI,YAAYgC,WAAWD,IAAIE,OAAO,CAAC,KAAK;wBACxChC,eAAe+B,WAAWG,OAAOF,OAAO,CAAC,KAAK;oBAChD;gBACF;YACF;QACF,EAAE,OAAO9E,OAAO;YACd7E,QAAQwK,IAAI,CAAC,6CAA6C3F,MAAMN,OAAO;QACzE;QAEA,OAAOgD;IACT;IAEA,eAAenH;QACb,IAAI;YACF,qBAAqB;YACrB,IAAIT,SAASC,MAAM,IAAID,SAASC,MAAM,KAAK,gCAAgC;gBACzE,MAAMgC,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAClCsJ,MAAM,CAAC,CAAC,kBAAkB,EAAEvL,SAASC,MAAM,EAAE,EAC7CmE,OAAO,CAAC;YACb;YAEA,2BAA2B;YAC3B,IAAIpE,SAASE,eAAe,EAAE;gBAC5B,MAAM+B,IAAAA,kBAAO,EAAC,CAAC,qBAAqB,CAAC,EAClCsJ,MAAM,CAAC,CAAC,oBAAoB,EAAEvL,SAASE,eAAe,EAAE,EACxDkE,OAAO,CAAC;YACb;YAEA/D,QAAQC,GAAG,CAAC;QACd,EAAE,OAAO4E,OAAO;YACd7E,QAAQwK,IAAI,CAAC,2CAA2C3F,MAAMN,OAAO;QACvE;IACF;AACF"}