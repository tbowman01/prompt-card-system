1564ff4762eaddf96d0778f9600c916a
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get CostTracker () {
        return CostTracker;
    },
    get costTracker () {
        return costTracker;
    }
});
const _connection = require("../database/connection");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class CostTracker {
    /**
   * Initialize database tables for cost tracking
   */ initializeDatabase() {
        console.log('Initializing cost tracking database...');
        // Cost tracking data table
        _connection.db.exec(`
      CREATE TABLE IF NOT EXISTS cost_tracking (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        execution_id TEXT NOT NULL,
        model TEXT NOT NULL,
        prompt_tokens INTEGER NOT NULL DEFAULT 0,
        completion_tokens INTEGER NOT NULL DEFAULT 0,
        total_tokens INTEGER NOT NULL DEFAULT 0,
        cost_usd REAL NOT NULL DEFAULT 0,
        execution_time_ms INTEGER NOT NULL DEFAULT 0,
        test_case_id INTEGER,
        prompt_card_id INTEGER,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (test_case_id) REFERENCES test_cases(id) ON DELETE CASCADE,
        FOREIGN KEY (prompt_card_id) REFERENCES prompt_cards(id) ON DELETE CASCADE
      )
    `);
        // Model pricing table
        _connection.db.exec(`
      CREATE TABLE IF NOT EXISTS model_pricing (
        model TEXT PRIMARY KEY,
        prompt_token_cost REAL NOT NULL,
        completion_token_cost REAL NOT NULL,
        context_window INTEGER NOT NULL,
        last_updated DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
        // Budget alerts table
        _connection.db.exec(`
      CREATE TABLE IF NOT EXISTS budget_alerts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        type TEXT NOT NULL CHECK (type IN ('daily', 'weekly', 'monthly', 'total')),
        threshold REAL NOT NULL,
        current_amount REAL DEFAULT 0,
        percentage_used REAL DEFAULT 0,
        status TEXT DEFAULT 'active' CHECK (status IN ('active', 'triggered', 'exceeded')),
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        triggered_at DATETIME
      )
    `);
        // Cost optimization settings table
        _connection.db.exec(`
      CREATE TABLE IF NOT EXISTS cost_optimization_settings (
        id INTEGER PRIMARY KEY CHECK (id = 1),
        enable_auto_optimization BOOLEAN DEFAULT 1,
        cost_threshold REAL DEFAULT 10.0,
        token_threshold INTEGER DEFAULT 100000,
        model_preferences TEXT DEFAULT '[]',
        prompt_optimization BOOLEAN DEFAULT 1,
        batching_enabled BOOLEAN DEFAULT 1,
        caching_enabled BOOLEAN DEFAULT 1,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
        // Create indexes for better performance
        _connection.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_cost_tracking_execution_id ON cost_tracking(execution_id);
      CREATE INDEX IF NOT EXISTS idx_cost_tracking_model ON cost_tracking(model);
      CREATE INDEX IF NOT EXISTS idx_cost_tracking_created_at ON cost_tracking(created_at);
      CREATE INDEX IF NOT EXISTS idx_cost_tracking_prompt_card_id ON cost_tracking(prompt_card_id);
    `);
        console.log('Cost tracking database initialized successfully');
    }
    /**
   * Initialize model pricing data
   */ initializePricing() {
        const defaultPricing = [
            {
                model: 'gpt-4',
                prompt_token_cost: 0.03,
                completion_token_cost: 0.06,
                context_window: 8192,
                last_updated: new Date().toISOString()
            },
            {
                model: 'gpt-4-turbo',
                prompt_token_cost: 0.01,
                completion_token_cost: 0.03,
                context_window: 128000,
                last_updated: new Date().toISOString()
            },
            {
                model: 'gpt-3.5-turbo',
                prompt_token_cost: 0.0015,
                completion_token_cost: 0.002,
                context_window: 16385,
                last_updated: new Date().toISOString()
            },
            {
                model: 'llama3',
                prompt_token_cost: 0.0,
                completion_token_cost: 0.0,
                context_window: 8192,
                last_updated: new Date().toISOString()
            },
            {
                model: 'claude-3-sonnet',
                prompt_token_cost: 0.003,
                completion_token_cost: 0.015,
                context_window: 200000,
                last_updated: new Date().toISOString()
            }
        ];
        // Insert default pricing into database
        const insertPricing = _connection.db.prepare(`
      INSERT OR REPLACE INTO model_pricing 
      (model, prompt_token_cost, completion_token_cost, context_window, last_updated)
      VALUES (?, ?, ?, ?, ?)
    `);
        for (const pricing of defaultPricing){
            insertPricing.run(pricing.model, pricing.prompt_token_cost, pricing.completion_token_cost, pricing.context_window, pricing.last_updated);
            this.modelPricing.set(pricing.model, pricing);
        }
        console.log('Model pricing initialized');
    }
    /**
   * Track token usage and calculate cost for an execution
   */ async trackUsage(executionId, model, promptTokens, completionTokens, executionTimeMs, testCaseId, promptCardId) {
        const totalTokens = promptTokens + completionTokens;
        const cost = this.calculateCost(model, promptTokens, completionTokens);
        const insertCost = _connection.db.prepare(`
      INSERT INTO cost_tracking 
      (execution_id, model, prompt_tokens, completion_tokens, total_tokens, cost_usd, execution_time_ms, test_case_id, prompt_card_id)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `);
        const result = insertCost.run(executionId, model, promptTokens, completionTokens, totalTokens, cost, executionTimeMs, testCaseId, promptCardId);
        const costData = {
            id: result.lastInsertRowid,
            execution_id: executionId,
            model,
            prompt_tokens: promptTokens,
            completion_tokens: completionTokens,
            total_tokens: totalTokens,
            cost_usd: cost,
            execution_time_ms: executionTimeMs,
            test_case_id: testCaseId,
            prompt_card_id: promptCardId,
            created_at: new Date().toISOString()
        };
        // Check budget alerts
        await this.checkBudgetAlerts();
        return costData;
    }
    /**
   * Calculate cost for given token usage
   */ calculateCost(model, promptTokens, completionTokens) {
        const pricing = this.modelPricing.get(model);
        if (!pricing) {
            console.warn(`No pricing found for model: ${model}, assuming zero cost`);
            return 0;
        }
        const promptCost = promptTokens / 1000 * pricing.prompt_token_cost;
        const completionCost = completionTokens / 1000 * pricing.completion_token_cost;
        return promptCost + completionCost;
    }
    /**
   * Get cost summary for a given time period
   */ async getCostSummary(startDate, endDate, promptCardId) {
        let query = `
      SELECT 
        model,
        SUM(cost_usd) as total_cost,
        SUM(total_tokens) as total_tokens,
        SUM(prompt_tokens) as total_prompt_tokens,
        SUM(completion_tokens) as total_completion_tokens,
        COUNT(*) as total_executions
      FROM cost_tracking
      WHERE 1=1
    `;
        const params = [];
        if (startDate) {
            query += ` AND created_at >= ?`;
            params.push(startDate);
        }
        if (endDate) {
            query += ` AND created_at <= ?`;
            params.push(endDate);
        }
        if (promptCardId) {
            query += ` AND prompt_card_id = ?`;
            params.push(promptCardId);
        }
        query += ` GROUP BY model`;
        const results = _connection.db.prepare(query).all(...params);
        const costByModel = {};
        const tokensByModel = {};
        const executionsByModel = {};
        let totalCost = 0;
        let totalTokens = 0;
        let totalPromptTokens = 0;
        let totalCompletionTokens = 0;
        let totalExecutions = 0;
        for (const result of results){
            const model = result.model;
            const cost = result.total_cost;
            const tokens = result.total_tokens;
            const executions = result.total_executions;
            costByModel[model] = cost;
            tokensByModel[model] = tokens;
            executionsByModel[model] = executions;
            totalCost += cost;
            totalTokens += tokens;
            totalPromptTokens += result.total_prompt_tokens;
            totalCompletionTokens += result.total_completion_tokens;
            totalExecutions += executions;
        }
        return {
            totalCost,
            totalTokens,
            totalPromptTokens,
            totalCompletionTokens,
            totalExecutions,
            averageCostPerExecution: totalExecutions > 0 ? totalCost / totalExecutions : 0,
            averageTokensPerExecution: totalExecutions > 0 ? totalTokens / totalExecutions : 0,
            costByModel,
            tokensByModel,
            executionsByModel
        };
    }
    /**
   * Generate cost optimization recommendations
   */ async generateOptimizationRecommendations(startDate, endDate) {
        const recommendations = [];
        const summary = await this.getCostSummary(startDate, endDate);
        // Model optimization recommendations
        const sortedModels = Object.entries(summary.costByModel).sort(([, a], [, b])=>b - a);
        if (sortedModels.length > 1) {
            const mostExpensiveModel = sortedModels[0][0];
            const mostExpensiveCost = sortedModels[0][1];
            const cheapestModel = sortedModels[sortedModels.length - 1][0];
            const cheapestCost = sortedModels[sortedModels.length - 1][1];
            if (mostExpensiveCost > cheapestCost * 2) {
                recommendations.push({
                    type: 'model_suggestion',
                    title: `Consider switching from ${mostExpensiveModel} to ${cheapestModel}`,
                    description: `${mostExpensiveModel} accounts for $${mostExpensiveCost.toFixed(2)} of your costs. Consider using ${cheapestModel} for appropriate tasks.`,
                    estimatedSavings: mostExpensiveCost - cheapestCost,
                    estimatedSavingsPercentage: (mostExpensiveCost - cheapestCost) / mostExpensiveCost * 100,
                    priority: 'high',
                    actionRequired: `Review test cases using ${mostExpensiveModel} and evaluate if ${cheapestModel} would be sufficient.`,
                    metadata: {
                        currentModel: mostExpensiveModel,
                        suggestedModel: cheapestModel,
                        currentCost: mostExpensiveCost,
                        suggestedCost: cheapestCost
                    }
                });
            }
        }
        // High token usage recommendations
        if (summary.averageTokensPerExecution > 2000) {
            recommendations.push({
                type: 'token_reduction',
                title: 'High token usage detected',
                description: `Average token usage is ${summary.averageTokensPerExecution.toFixed(0)} tokens per execution. Consider optimizing prompts.`,
                estimatedSavings: summary.totalCost * 0.3,
                estimatedSavingsPercentage: 30,
                priority: 'medium',
                actionRequired: 'Review and optimize prompt templates to reduce token usage.',
                metadata: {
                    averageTokens: summary.averageTokensPerExecution,
                    totalTokens: summary.totalTokens
                }
            });
        }
        // Execution frequency recommendations
        if (summary.totalExecutions > 1000) {
            recommendations.push({
                type: 'execution_reduction',
                title: 'High execution frequency',
                description: `${summary.totalExecutions} executions recorded. Consider implementing caching or batching.`,
                estimatedSavings: summary.totalCost * 0.2,
                estimatedSavingsPercentage: 20,
                priority: 'low',
                actionRequired: 'Implement result caching and batch processing for similar test cases.',
                metadata: {
                    totalExecutions: summary.totalExecutions,
                    avgCostPerExecution: summary.averageCostPerExecution
                }
            });
        }
        return recommendations;
    }
    /**
   * Create or update budget alert
   */ async createBudgetAlert(name, type, threshold) {
        const insertAlert = _connection.db.prepare(`
      INSERT INTO budget_alerts (name, type, threshold)
      VALUES (?, ?, ?)
    `);
        const result = insertAlert.run(name, type, threshold);
        return {
            id: result.lastInsertRowid,
            name,
            type,
            threshold,
            current_amount: 0,
            percentage_used: 0,
            status: 'active',
            created_at: new Date().toISOString()
        };
    }
    /**
   * Check budget alerts and update their status
   */ async checkBudgetAlerts() {
        const alerts = _connection.db.prepare(`
      SELECT * FROM budget_alerts WHERE status IN ('active', 'triggered')
    `).all();
        const triggeredAlerts = [];
        for (const alert of alerts){
            const currentAmount = await this.getCurrentSpendingForAlert(alert.type);
            const percentageUsed = currentAmount / alert.threshold * 100;
            let newStatus = alert.status;
            if (percentageUsed >= 100) {
                newStatus = 'exceeded';
            } else if (percentageUsed >= 80) {
                newStatus = 'triggered';
            }
            // Update alert with current amounts
            _connection.db.prepare(`
        UPDATE budget_alerts 
        SET current_amount = ?, percentage_used = ?, status = ?
        WHERE id = ?
      `).run(currentAmount, percentageUsed, newStatus, alert.id);
            if (newStatus !== alert.status) {
                triggeredAlerts.push({
                    ...alert,
                    current_amount: currentAmount,
                    percentage_used: percentageUsed,
                    status: newStatus
                });
            }
        }
        return triggeredAlerts;
    }
    /**
   * Get current spending for alert period
   */ async getCurrentSpendingForAlert(type) {
        let startDate;
        const now = new Date();
        switch(type){
            case 'daily':
                startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();
                break;
            case 'weekly':
                const weekStart = new Date(now);
                weekStart.setDate(now.getDate() - now.getDay());
                startDate = weekStart.toISOString();
                break;
            case 'monthly':
                startDate = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();
                break;
            case 'total':
                startDate = '1970-01-01T00:00:00.000Z';
                break;
            default:
                return 0;
        }
        const result = _connection.db.prepare(`
      SELECT SUM(cost_usd) as total_cost 
      FROM cost_tracking 
      WHERE created_at >= ?
    `).get(startDate);
        return result?.total_cost || 0;
    }
    /**
   * Generate cost predictions based on historical data
   */ async generateCostPrediction(period) {
        const days = period === 'daily' ? 7 : period === 'weekly' ? 28 : 90;
        const startDate = new Date();
        startDate.setDate(startDate.getDate() - days);
        const historicalData = _connection.db.prepare(`
      SELECT 
        DATE(created_at) as date,
        SUM(cost_usd) as daily_cost,
        SUM(total_tokens) as daily_tokens,
        COUNT(*) as daily_executions
      FROM cost_tracking
      WHERE created_at >= ?
      GROUP BY DATE(created_at)
      ORDER BY date
    `).all(startDate.toISOString());
        if (historicalData.length < 3) {
            return {
                period,
                predictedCost: 0,
                confidence: 0,
                basedOnDays: historicalData.length,
                trend: 'stable',
                factors: [
                    'Insufficient historical data'
                ]
            };
        }
        const costs = historicalData.map((d)=>d.daily_cost);
        const avgDailyCost = costs.reduce((a, b)=>a + b, 0) / costs.length;
        // Simple trend analysis
        const recentCosts = costs.slice(-7);
        const earlierCosts = costs.slice(0, 7);
        const recentAvg = recentCosts.reduce((a, b)=>a + b, 0) / recentCosts.length;
        const earlierAvg = earlierCosts.reduce((a, b)=>a + b, 0) / earlierCosts.length;
        let trend = 'stable';
        if (recentAvg > earlierAvg * 1.1) {
            trend = 'increasing';
        } else if (recentAvg < earlierAvg * 0.9) {
            trend = 'decreasing';
        }
        const multiplier = period === 'daily' ? 1 : period === 'weekly' ? 7 : 30;
        const predictedCost = avgDailyCost * multiplier;
        return {
            period,
            predictedCost,
            confidence: Math.min(historicalData.length / 30, 1),
            basedOnDays: historicalData.length,
            trend,
            factors: [
                `Based on ${historicalData.length} days of historical data`,
                `Average daily cost: $${avgDailyCost.toFixed(2)}`,
                `Trend: ${trend}`
            ]
        };
    }
    /**
   * Get usage analytics for a time period
   */ async getUsageAnalytics(startDate, endDate) {
        const summary = await this.getCostSummary(startDate, endDate);
        // Get daily trend data
        const trendData = _connection.db.prepare(`
      SELECT 
        DATE(created_at) as date,
        SUM(cost_usd) as cost,
        SUM(total_tokens) as tokens,
        COUNT(*) as executions
      FROM cost_tracking
      WHERE created_at >= ? AND created_at <= ?
      GROUP BY DATE(created_at)
      ORDER BY date
    `).all(startDate, endDate);
        const dayCount = Math.max(1, Math.ceil((new Date(endDate).getTime() - new Date(startDate).getTime()) / (24 * 60 * 60 * 1000)));
        // Find peak usage day
        const peakDay = trendData.reduce((max, day)=>day.cost > max.cost ? day : max, trendData[0] || {
            date: startDate,
            cost: 0,
            tokens: 0,
            executions: 0
        });
        // Model usage breakdown
        const modelUsage = Object.entries(summary.costByModel).map(([model, cost])=>({
                model,
                cost,
                tokens: summary.tokensByModel[model] || 0,
                executions: summary.executionsByModel[model] || 0,
                percentage: cost / summary.totalCost * 100
            })).sort((a, b)=>b.cost - a.cost);
        return {
            period: {
                start: startDate,
                end: endDate
            },
            totalCost: summary.totalCost,
            totalTokens: summary.totalTokens,
            totalExecutions: summary.totalExecutions,
            averageCostPerDay: summary.totalCost / dayCount,
            averageTokensPerDay: summary.totalTokens / dayCount,
            averageExecutionsPerDay: summary.totalExecutions / dayCount,
            peakUsageDay: peakDay.date,
            peakUsageCost: peakDay.cost,
            costTrend: trendData.map((d)=>({
                    date: d.date,
                    cost: d.cost,
                    tokens: d.tokens,
                    executions: d.executions
                })),
            modelUsage
        };
    }
    /**
   * Calculate ROI for test executions
   */ async calculateROI(startDate, endDate, promptCardId) {
        const summary = await this.getCostSummary(startDate, endDate, promptCardId);
        // Get success/failure statistics
        let query = `
      SELECT 
        COUNT(*) as total_executions,
        SUM(CASE WHEN passed = 1 THEN 1 ELSE 0 END) as successful_executions,
        SUM(CASE WHEN passed = 0 THEN 1 ELSE 0 END) as failed_executions
      FROM test_results tr
      JOIN cost_tracking ct ON tr.execution_id = ct.execution_id
      WHERE 1=1
    `;
        const params = [];
        if (startDate) {
            query += ` AND ct.created_at >= ?`;
            params.push(startDate);
        }
        if (endDate) {
            query += ` AND ct.created_at <= ?`;
            params.push(endDate);
        }
        if (promptCardId) {
            query += ` AND ct.prompt_card_id = ?`;
            params.push(promptCardId);
        }
        const result = _connection.db.prepare(query).get(...params);
        const totalExecutions = result?.total_executions || 0;
        const successfulExecutions = result?.successful_executions || 0;
        const failedExecutions = result?.failed_executions || 0;
        const successRate = totalExecutions > 0 ? successfulExecutions / totalExecutions * 100 : 0;
        const averageCostPerSuccess = successfulExecutions > 0 ? summary.totalCost / successfulExecutions : 0;
        const costEfficiency = summary.totalCost > 0 ? successfulExecutions / summary.totalCost * 100 : 0;
        const recommendations = await this.generateOptimizationRecommendations(startDate, endDate);
        return {
            totalCost: summary.totalCost,
            totalExecutions,
            successfulExecutions,
            failedExecutions,
            averageCostPerSuccess,
            successRate,
            costEfficiency,
            recommendations
        };
    }
    /**
   * Get all budget alerts
   */ async getBudgetAlerts() {
        return _connection.db.prepare(`
      SELECT * FROM budget_alerts ORDER BY created_at DESC
    `).all();
    }
    /**
   * Update optimization settings
   */ async updateOptimizationSettings(settings) {
        this.optimizationSettings = {
            ...this.optimizationSettings,
            ...settings
        };
        _connection.db.prepare(`
      INSERT OR REPLACE INTO cost_optimization_settings 
      (id, enable_auto_optimization, cost_threshold, token_threshold, model_preferences, 
       prompt_optimization, batching_enabled, caching_enabled, updated_at)
      VALUES (1, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)
    `).run(settings.enableAutoOptimization ?? this.optimizationSettings.enableAutoOptimization, settings.costThreshold ?? this.optimizationSettings.costThreshold, settings.tokenThreshold ?? this.optimizationSettings.tokenThreshold, JSON.stringify(settings.modelPreferences ?? this.optimizationSettings.modelPreferences), settings.promptOptimization ?? this.optimizationSettings.promptOptimization, settings.batchingEnabled ?? this.optimizationSettings.batchingEnabled, settings.cachingEnabled ?? this.optimizationSettings.cachingEnabled);
    }
    /**
   * Get optimization settings
   */ getOptimizationSettings() {
        return this.optimizationSettings;
    }
    constructor(){
        _define_property(this, "modelPricing", new Map());
        _define_property(this, "optimizationSettings", void 0);
        this.optimizationSettings = {
            enableAutoOptimization: true,
            costThreshold: 10.0,
            tokenThreshold: 100000,
            modelPreferences: [
                'gpt-3.5-turbo',
                'llama3'
            ],
            promptOptimization: true,
            batchingEnabled: true,
            cachingEnabled: true
        };
        this.initializePricing();
        this.initializeDatabase();
    }
}
const costTracker = new CostTracker();
