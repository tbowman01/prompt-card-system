324534e29dc804768af132cf340cafe5
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "authRoutes", {
    enumerable: true,
    get: function() {
        return router;
    }
});
const _express = require("express");
const _auth = require("../middleware/auth");
const _rateLimiting = require("../middleware/rateLimiting");
const _validation = require("../middleware/validation");
const _expressvalidator = require("express-validator");
const _security = require("../middleware/security");
const router = (0, _express.Router)();
// Apply rate limiting to all auth routes
router.use(_rateLimiting.authRateLimit);
// Apply CSRF protection to state-changing operations
router.use([
    'POST',
    'PUT',
    'DELETE'
], _security.csrfProtection);
// Apply input sanitization
router.use(_validation.sanitizeRequestBody);
const users = [
    {
        id: '1',
        email: 'admin@example.com',
        password: '$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/UnFhqA5qLiDVN7Z6a',
        role: 'admin',
        permissions: [
            'read',
            'write',
            'delete',
            'admin'
        ],
        createdAt: new Date(),
        isActive: true
    },
    {
        id: '2',
        email: 'user@example.com',
        password: '$2a$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/UnFhqA5qLiDVN7Z6a',
        role: 'user',
        permissions: [
            'read',
            'write'
        ],
        createdAt: new Date(),
        isActive: true
    }
];
// Helper functions
const findUserByEmail = (email)=>{
    return users.find((user)=>user.email.toLowerCase() === email.toLowerCase() && user.isActive);
};
const findUserById = (id)=>{
    return users.find((user)=>user.id === id && user.isActive);
};
// Validation schemas
const loginValidation = [
    (0, _expressvalidator.body)('email').isEmail().normalizeEmail().isLength({
        max: 255
    }).withMessage('Valid email is required'),
    (0, _expressvalidator.body)('password').isLength({
        min: 6,
        max: 128
    }).withMessage('Password must be between 6 and 128 characters'),
    _validation.handleValidationErrors
];
const registerValidation = [
    (0, _expressvalidator.body)('email').isEmail().normalizeEmail().isLength({
        max: 255
    }).withMessage('Valid email is required'),
    (0, _expressvalidator.body)('password').isLength({
        min: 8,
        max: 128
    }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/).withMessage('Password must contain at least 8 characters with uppercase, lowercase, number, and special character'),
    (0, _expressvalidator.body)('confirmPassword').custom((value, { req })=>{
        if (value !== req.body.password) {
            throw new Error('Password confirmation does not match password');
        }
        return true;
    }),
    _validation.handleValidationErrors
];
// POST /auth/login
router.post('/login', loginValidation, async (req, res)=>{
    try {
        const { email, password } = req.body;
        const user = findUserByEmail(email);
        if (!user) {
            res.status(401).json({
                success: false,
                error: 'Invalid credentials',
                code: 'INVALID_CREDENTIALS'
            });
            return;
        }
        const isValidPassword = await (0, _auth.verifyPassword)(password, user.password);
        if (!isValidPassword) {
            res.status(401).json({
                success: false,
                error: 'Invalid credentials',
                code: 'INVALID_CREDENTIALS'
            });
            return;
        }
        user.lastLogin = new Date();
        const tokens = (0, _auth.generateTokens)({
            id: user.id,
            email: user.email,
            role: user.role,
            permissions: user.permissions
        });
        res.json({
            success: true,
            data: {
                user: {
                    id: user.id,
                    email: user.email,
                    role: user.role,
                    permissions: user.permissions,
                    lastLogin: user.lastLogin
                },
                tokens
            }
        });
    } catch (error) {
        console.error('Login error:', error);
        res.status(500).json({
            success: false,
            error: 'Login failed',
            code: 'LOGIN_ERROR'
        });
    }
});
// POST /auth/register
router.post('/register', registerValidation, async (req, res)=>{
    try {
        const { email, password } = req.body;
        const existingUser = findUserByEmail(email);
        if (existingUser) {
            res.status(409).json({
                success: false,
                error: 'User already exists',
                code: 'USER_EXISTS'
            });
            return;
        }
        const hashedPassword = await (0, _auth.hashPassword)(password);
        const newUser = {
            id: String(users.length + 1),
            email,
            password: hashedPassword,
            role: 'user',
            permissions: [
                'read',
                'write'
            ],
            createdAt: new Date(),
            isActive: true
        };
        users.push(newUser);
        const tokens = (0, _auth.generateTokens)({
            id: newUser.id,
            email: newUser.email,
            role: newUser.role,
            permissions: newUser.permissions
        });
        res.status(201).json({
            success: true,
            data: {
                user: {
                    id: newUser.id,
                    email: newUser.email,
                    role: newUser.role,
                    permissions: newUser.permissions,
                    createdAt: newUser.createdAt
                },
                tokens
            }
        });
    } catch (error) {
        console.error('Registration error:', error);
        res.status(500).json({
            success: false,
            error: 'Registration failed',
            code: 'REGISTRATION_ERROR'
        });
    }
});
// POST /auth/refresh
router.post('/refresh', _auth.refreshToken);
// POST /auth/logout
router.post('/logout', _auth.logout);
// GET /auth/me
router.get('/me', _auth.verifyToken, (req, res)=>{
    const user = findUserById(req.user.id);
    if (!user) {
        res.status(404).json({
            success: false,
            error: 'User not found',
            code: 'USER_NOT_FOUND'
        });
        return;
    }
    res.json({
        success: true,
        data: {
            user: {
                id: user.id,
                email: user.email,
                role: user.role,
                permissions: user.permissions,
                createdAt: user.createdAt,
                lastLogin: user.lastLogin
            }
        }
    });
});
// GET /auth/users - Admin only
router.get('/users', _auth.verifyToken, (0, _auth.requireRole)([
    'admin'
]), (req, res)=>{
    const userList = users.filter((user)=>user.isActive).map((user)=>({
            id: user.id,
            email: user.email,
            role: user.role,
            permissions: user.permissions,
            createdAt: user.createdAt,
            lastLogin: user.lastLogin
        }));
    res.json({
        success: true,
        data: {
            users: userList
        }
    });
});
