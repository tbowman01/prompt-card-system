{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/tests/integration/parallel-execution.test.ts"],"sourcesContent":["import request from 'supertest';\nimport assert from 'assert';\nimport app from '../../server';\nimport { TestQueueManager } from '../../services/testing/TestQueueManager';\nimport { ResourceManager } from '../../services/testing/ResourceManager';\nimport { Semaphore } from '../../services/testing/Semaphore';\n\ndescribe('Parallel Testing Infrastructure Integration Tests', () => {\n  let testQueueManager: TestQueueManager;\n  let resourceManager: ResourceManager;\n  let semaphore: Semaphore;\n  const testCardId = 'test-parallel-card-123';\n\n  beforeEach(async () => {\n    testQueueManager = new TestQueueManager();\n    resourceManager = new ResourceManager();\n    semaphore = new Semaphore(3); // Allow 3 concurrent tests\n    \n    // Initialize test infrastructure\n    await testQueueManager.initialize();\n    await resourceManager.initialize();\n  });\n\n  afterEach(async () => {\n    await testQueueManager.cleanup();\n    await resourceManager.cleanup();\n  });\n\n  describe('Queue Management Integration', () => {\n    it('should handle multiple test submissions and execute them in parallel', async () => {\n      const testPromises = [];\n      \n      // Submit 10 test executions\n      for (let i = 0; i < 10; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `test-${i}-1`,\n                  input: `Test input ${i}-1`,\n                  expectedOutput: `Expected output ${i}-1`\n                },\n                {\n                  id: `test-${i}-2`,\n                  input: `Test input ${i}-2`,\n                  expectedOutput: `Expected output ${i}-2`\n                }\n              ],\n              model: 'gpt-3.5-turbo',\n              parallelism: 2\n            })\n        );\n      }\n\n      const responses = await Promise.all(testPromises);\n      \n      // All submissions should be accepted\n      for (const response of responses) {\n        expect(response.status).toBe(200);\n        expect(response.body.success).toBe(true);\n        expect(response.body.data).toHaveProperty('executionId');\n        expect(response.body.data).toHaveProperty('status');\n        expect(['queued', 'running']).toContain(response.body.data.status);\n      }\n    });\n\n    it('should respect resource limits and queue appropriately', async () => {\n      // Set resource limits\n      await resourceManager.setLimits({\n        max_concurrent_tests: 3,\n        max_memory_mb: 1024, // 1GB\n        max_cpu_percent: 80\n      });\n\n      const testPromises = [];\n      \n      // Submit more tests than the limit\n      for (let i = 0; i < 8; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `limit-test-${i}`,\n                  input: `Test input ${i}`,\n                  expectedOutput: `Expected output ${i}`\n                }\n              ],\n              model: 'gpt-3.5-turbo',\n              priority: i < 3 ? 'high' : 'normal'\n            })\n        );\n      }\n\n      const responses = await Promise.all(testPromises);\n      \n      // Check queue status\n      const queueStatusResponse = await request(app)\n        .get('/api/test-execution/queue/status')\n        .expect(200);\n\n      assert(queueStatusResponse.body.success === true);\n      expect(queueStatusResponse.body.data).toHaveProperty('running');\n      expect(queueStatusResponse.body.data).toHaveProperty('queued');\n      expect(queueStatusResponse.body.data.running).toBeLessThanOrEqual(3);\n    });\n\n    it('should handle queue priority correctly', async () => {\n      // Submit tests with different priorities\n      const lowPriorityResponse = await request(app)\n        .post('/api/test-execution/parallel')\n        .send({\n          cardId: testCardId,\n          testCases: [{ id: 'low-priority', input: 'Low priority test', expectedOutput: 'output' }],\n          priority: 'low'\n        })\n        .expect(200);\n\n      const highPriorityResponse = await request(app)\n        .post('/api/test-execution/parallel')\n        .send({\n          cardId: testCardId,\n          testCases: [{ id: 'high-priority', input: 'High priority test', expectedOutput: 'output' }],\n          priority: 'high'\n        })\n        .expect(200);\n\n      const criticalPriorityResponse = await request(app)\n        .post('/api/test-execution/parallel')\n        .send({\n          cardId: testCardId,\n          testCases: [{ id: 'critical-priority', input: 'Critical priority test', expectedOutput: 'output' }],\n          priority: 'critical'\n        })\n        .expect(200);\n\n      // Check queue order\n      const queueResponse = await request(app)\n        .get('/api/test-execution/queue/list')\n        .expect(200);\n\n      assert(queueResponse.body.success === true);\n      expect(Array.isArray(queueResponse.body.data)).toBe(true);\n      \n      // Critical should be first, then high, then low\n      const priorities = queueResponse.body.data.map(item => item.priority);\n      expect(priorities[0]).toBe('critical');\n    });\n  });\n\n  describe('Resource Management Integration', () => {\n    it('should monitor and manage system resources during parallel execution', async () => {\n      // Start resource monitoring\n      const monitoringResponse = await request(app)\n        .post('/api/test-execution/monitoring/start')\n        .send({\n          interval: 1000, // 1 second intervals\n          metrics: ['cpu', 'memory', 'activeTests', 'queueLength']\n        })\n        .expect(200);\n\n      // Submit resource-intensive tests\n      const heavyTestPromises = [];\n      for (let i = 0; i < 5; i++) {\n        heavyTestPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: Array.from({ length: 20 }, (_, j) => ({\n                id: `heavy-${i}-${j}`,\n                input: `Heavy test ${i}-${j}`,\n                expectedOutput: `Expected ${i}-${j}`\n              })),\n              model: 'gpt-4',\n              parallelism: 5\n            })\n        );\n      }\n\n      await Promise.all(heavyTestPromises);\n\n      // Wait a bit for monitoring data\n      await new Promise(resolve => setTimeout(resolve, 3000));\n\n      // Get resource usage data\n      const resourceResponse = await request(app)\n        .get('/api/test-execution/resources/usage')\n        .expect(200);\n\n      assert(resourceResponse.body.success === true);\n      expect(resourceResponse.body.data).toHaveProperty('cpu');\n      expect(resourceResponse.body.data).toHaveProperty('memory');\n      expect(resourceResponse.body.data).toHaveProperty('activeTests');\n      expect(resourceResponse.body.data).toHaveProperty('queueLength');\n    });\n\n    it('should handle resource exhaustion gracefully', async () => {\n      // Set very low resource limits\n      await resourceManager.setLimits({\n        max_concurrent_tests: 1,\n        max_memory_mb: 100, // 100MB\n        max_cpu_percent: 50\n      });\n\n      // Submit many tests\n      const testPromises = [];\n      for (let i = 0; i < 10; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `resource-test-${i}`,\n                  input: `Resource test ${i}`,\n                  expectedOutput: `Expected ${i}`\n                }\n              ],\n              model: 'gpt-3.5-turbo'\n            })\n        );\n      }\n\n      const responses = await Promise.all(testPromises);\n      \n      // Some should be queued due to resource limits\n      let queuedCount = 0;\n      let runningCount = 0;\n      \n      for (const response of responses) {\n        if (response.body.data.status === 'queued') queuedCount++;\n        if (response.body.data.status === 'running') runningCount++;\n      }\n\n      expect(queuedCount).toBeGreaterThan(0);\n      expect(runningCount).toBeLessThanOrEqual(1);\n    });\n  });\n\n  describe('Semaphore and Concurrency Control', () => {\n    it('should control concurrent execution using semaphores', async () => {\n      const semaphoreResponse = await request(app)\n        .post('/api/test-execution/semaphore/create')\n        .send({\n          name: 'test-semaphore',\n          permits: 3\n        })\n        .expect(200);\n\n      const semaphoreId = semaphoreResponse.body.data.id;\n\n      // Submit 10 tests that should use the semaphore\n      const testPromises = [];\n      for (let i = 0; i < 10; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `semaphore-test-${i}`,\n                  input: `Semaphore test ${i}`,\n                  expectedOutput: `Expected ${i}`\n                }\n              ],\n              model: 'gpt-3.5-turbo',\n              semaphoreId: semaphoreId\n            })\n        );\n      }\n\n      const responses = await Promise.all(testPromises);\n      \n      // Check semaphore status\n      const statusResponse = await request(app)\n        .get(`/api/test-execution/semaphore/${semaphoreId}/status`)\n        .expect(200);\n\n      assert(statusResponse.body.success === true);\n      expect(statusResponse.body.data).toHaveProperty('availablePermits');\n      expect(statusResponse.body.data).toHaveProperty('queuedRequests');\n      expect(statusResponse.body.data.availablePermits).toBeLessThanOrEqual(3);\n    });\n  });\n\n  describe('Error Handling and Recovery', () => {\n    it('should handle test execution failures gracefully', async () => {\n      const response = await request(app)\n        .post('/api/test-execution/parallel')\n        .send({\n          cardId: testCardId,\n          testCases: [\n            {\n              id: 'failing-test',\n              input: 'This test will fail',\n              expectedOutput: 'This should cause an error'\n            }\n          ],\n          model: 'invalid-model', // This should cause an error\n          parallelism: 1\n        })\n        .expect(200);\n\n      const executionId = response.body.data.executionId;\n\n      // Wait for execution to complete\n      await new Promise(resolve => setTimeout(resolve, 2000));\n\n      // Check execution status\n      const statusResponse = await request(app)\n        .get(`/api/test-execution/${executionId}/status`)\n        .expect(200);\n\n      assert(statusResponse.body.success === true);\n      expect(['failed', 'completed']).toContain(statusResponse.body.data.status);\n      \n      if (statusResponse.body.data.status === 'failed') {\n        expect(statusResponse.body.data).toHaveProperty('error');\n      }\n    });\n\n    it('should handle queue overflow gracefully', async () => {\n      // Set a small queue limit\n      await testQueueManager.setQueueLimit(5);\n\n      const testPromises = [];\n      \n      // Submit more tests than the queue can handle\n      for (let i = 0; i < 10; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `overflow-test-${i}`,\n                  input: `Overflow test ${i}`,\n                  expectedOutput: `Expected ${i}`\n                }\n              ],\n              model: 'gpt-3.5-turbo'\n            })\n        );\n      }\n\n      const responses = await Promise.all(testPromises);\n      \n      // Some should be rejected due to queue overflow\n      let acceptedCount = 0;\n      let rejectedCount = 0;\n      \n      for (const response of responses) {\n        if (response.status === 200) {\n          acceptedCount++;\n        } else if (response.status === 429) { // Too many requests\n          rejectedCount++;\n        }\n      }\n\n      expect(acceptedCount).toBeLessThanOrEqual(5);\n      expect(rejectedCount).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Performance and Scalability', () => {\n    it('should handle high-volume parallel test execution', async () => {\n      const startTime = Date.now();\n      \n      // Submit a large number of tests\n      const testPromises = [];\n      for (let i = 0; i < 50; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `volume-test-${i}`,\n                  input: `Volume test ${i}`,\n                  expectedOutput: `Expected ${i}`\n                }\n              ],\n              model: 'gpt-3.5-turbo',\n              parallelism: 3\n            })\n        );\n      }\n\n      const responses = await Promise.all(testPromises);\n      const submissionTime = Date.now() - startTime;\n\n      // All submissions should complete within reasonable time\n      expect(submissionTime).toBeLessThan(10000); // 10 seconds\n      \n      // Most should be accepted\n      const successfulSubmissions = responses.filter(r => r.status === 200).length;\n      expect(successfulSubmissions).toBeGreaterThan(40); // At least 80% success rate\n\n      // Check system performance\n      const performanceResponse = await request(app)\n        .get('/api/test-execution/performance/metrics')\n        .expect(200);\n\n      assert(performanceResponse.body.success === true);\n      expect(performanceResponse.body.data).toHaveProperty('throughput');\n      expect(performanceResponse.body.data).toHaveProperty('averageWaitTime');\n      expect(performanceResponse.body.data).toHaveProperty('systemLoad');\n    });\n  });\n\n  describe('Integration with Analytics', () => {\n    it('should track parallel execution metrics', async () => {\n      // Submit some parallel tests\n      const testPromises = [];\n      for (let i = 0; i < 5; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `analytics-test-${i}`,\n                  input: `Analytics test ${i}`,\n                  expectedOutput: `Expected ${i}`\n                }\n              ],\n              model: 'gpt-3.5-turbo'\n            })\n        );\n      }\n\n      await Promise.all(testPromises);\n\n      // Check analytics data\n      const analyticsResponse = await request(app)\n        .get('/api/analytics/parallel-execution')\n        .expect(200);\n\n      assert(analyticsResponse.body.success === true);\n      expect(analyticsResponse.body.data).toHaveProperty('totalParallelTests');\n      expect(analyticsResponse.body.data).toHaveProperty('averageParallelism');\n      expect(analyticsResponse.body.data).toHaveProperty('resourceEfficiency');\n      expect(analyticsResponse.body.data).toHaveProperty('queueMetrics');\n    });\n  });\n});"],"names":["describe","testQueueManager","resourceManager","semaphore","testCardId","beforeEach","TestQueueManager","ResourceManager","Semaphore","initialize","afterEach","cleanup","it","testPromises","i","push","request","app","post","send","cardId","testCases","id","input","expectedOutput","model","parallelism","responses","Promise","all","response","expect","status","toBe","body","success","data","toHaveProperty","toContain","setLimits","max_concurrent_tests","max_memory_mb","max_cpu_percent","priority","queueStatusResponse","get","assert","running","toBeLessThanOrEqual","lowPriorityResponse","highPriorityResponse","criticalPriorityResponse","queueResponse","Array","isArray","priorities","map","item","monitoringResponse","interval","metrics","heavyTestPromises","from","length","_","j","resolve","setTimeout","resourceResponse","queuedCount","runningCount","toBeGreaterThan","semaphoreResponse","name","permits","semaphoreId","statusResponse","availablePermits","executionId","setQueueLimit","acceptedCount","rejectedCount","startTime","Date","now","submissionTime","toBeLessThan","successfulSubmissions","filter","r","performanceResponse","analyticsResponse"],"mappings":"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"}