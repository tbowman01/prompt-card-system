ebe4aa4762a1ae722304a6dd2959bbb1
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ReportService () {
        return ReportService;
    },
    get reportService () {
        return reportService;
    }
});
const _ReportGenerator = require("./generators/ReportGenerator");
const _PDFExporter = require("./exporters/PDFExporter");
const _ExcelExporter = require("./exporters/ExcelExporter");
const _ReportTemplates = require("./templates/ReportTemplates");
const _connection = require("../../database/connection");
const _events = require("events");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class ReportService extends _events.EventEmitter {
    async initializeDb() {
        this.db = await (0, _connection.initializeDatabase)();
    }
    /**
   * Create test data for a prompt card
   */ async createTestData(promptCardId) {
        // Implementation for creating test data
        console.log(`Creating test data for prompt card: ${promptCardId}`);
    }
    static getInstance() {
        if (!ReportService.instance) {
            ReportService.instance = new ReportService();
        }
        return ReportService.instance;
    }
    initializeDatabase() {
        // Report history table
        this.db.exec(`
      CREATE TABLE IF NOT EXISTS report_history (
        id TEXT PRIMARY KEY,
        template_id TEXT NOT NULL,
        title TEXT NOT NULL,
        description TEXT,
        filters TEXT,
        generated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        generation_time INTEGER,
        total_executions INTEGER,
        total_cost REAL,
        success_rate REAL,
        file_path TEXT,
        file_size INTEGER,
        export_format TEXT,
        created_by TEXT,
        status TEXT DEFAULT 'completed'
      )
    `);
        // Report schedules table
        this.db.exec(`
      CREATE TABLE IF NOT EXISTS report_schedules (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        template_id TEXT NOT NULL,
        filters TEXT,
        frequency TEXT NOT NULL,
        recipients TEXT,
        export_format TEXT NOT NULL,
        next_execution DATETIME,
        last_execution DATETIME,
        enabled BOOLEAN DEFAULT 1,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `);
        // Report exports table
        this.db.exec(`
      CREATE TABLE IF NOT EXISTS report_exports (
        id TEXT PRIMARY KEY,
        report_id TEXT NOT NULL,
        format TEXT NOT NULL,
        file_path TEXT,
        file_size INTEGER,
        download_count INTEGER DEFAULT 0,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        expires_at DATETIME,
        FOREIGN KEY (report_id) REFERENCES report_history(id) ON DELETE CASCADE
      )
    `);
        // Indexes
        this.db.exec(`
      CREATE INDEX IF NOT EXISTS idx_report_history_template_id ON report_history(template_id);
      CREATE INDEX IF NOT EXISTS idx_report_history_generated_at ON report_history(generated_at);
      CREATE INDEX IF NOT EXISTS idx_report_schedules_next_execution ON report_schedules(next_execution);
      CREATE INDEX IF NOT EXISTS idx_report_exports_report_id ON report_exports(report_id);
    `);
        console.log('Report service database initialized');
    }
    // Report Generation Methods
    async generateReport(templateId, filters = {}, options = {}) {
        const cacheKey = this.generateCacheKey(templateId, filters);
        // Check cache first
        if (this.reportCache.has(cacheKey)) {
            const cachedReport = this.reportCache.get(cacheKey);
            // Return cached report if it's less than 30 minutes old
            if (Date.now() - cachedReport.generatedAt.getTime() < 30 * 60 * 1000) {
                return cachedReport;
            }
        }
        // Check if generation is already in progress
        if (this.generationQueue.has(cacheKey)) {
            return this.generationQueue.get(cacheKey);
        }
        // Generate new report
        const generationPromise = this.generateReportInternal(templateId, filters, options);
        this.generationQueue.set(cacheKey, generationPromise);
        try {
            const report = await generationPromise;
            // Cache the report
            this.reportCache.set(cacheKey, report);
            // Save to history if requested
            if (options.saveToHistory !== false) {
                await this.saveReportToHistory(report, options.userId);
            }
            return report;
        } finally{
            this.generationQueue.delete(cacheKey);
        }
    }
    async generateReportInternal(templateId, filters, options) {
        // Validate template
        const template = _ReportTemplates.ReportTemplates.getTemplate(templateId);
        if (!template) {
            throw new Error(`Template not found: ${templateId}`);
        }
        // Generate report with progress tracking
        const report = await this.reportGenerator.generateReport(templateId, filters, (progress)=>{
            this.emit('reportProgress', progress);
        });
        // Emit completion event
        this.emit('reportGenerated', {
            reportId: report.id,
            templateId,
            filters,
            userId: options.userId,
            generationTime: report.metadata.generationTime
        });
        return report;
    }
    // Export Methods
    async exportReport(reportId, format, options = {
        format,
        includeCharts: true,
        includeRawData: false
    }) {
        // Get report from cache or history
        const report = await this.getReportById(reportId);
        if (!report) {
            throw new Error(`Report not found: ${reportId}`);
        }
        let exportBuffer;
        switch(format){
            case 'pdf':
                exportBuffer = await this.pdfExporter.exportToPDF(report, options);
                break;
            case 'excel':
                exportBuffer = await this.excelExporter.exportToExcel(report, options);
                break;
            case 'json':
                exportBuffer = Buffer.from(JSON.stringify(report, null, 2));
                break;
            case 'csv':
                exportBuffer = await this.exportToCSV(report);
                break;
            default:
                throw new Error(`Unsupported export format: ${format}`);
        }
        // Save export record
        await this.saveExportRecord(reportId, format, exportBuffer.length);
        // Emit export event
        this.emit('reportExported', {
            reportId,
            format,
            fileSize: exportBuffer.length,
            timestamp: new Date()
        });
        return exportBuffer;
    }
    async exportToCSV(report) {
        const csvLines = [];
        // Add header
        csvLines.push('Report,Template,Generated,Section,Type,Data');
        // Add report metadata
        csvLines.push(`"${report.title}","${report.template.name}","${report.generatedAt.toISOString()}","Metadata","Info","Total Executions: ${report.metadata.totalExecutions}"`);
        csvLines.push(`"${report.title}","${report.template.name}","${report.generatedAt.toISOString()}","Metadata","Info","Total Cost: $${report.metadata.totalCost.toFixed(2)}"`);
        csvLines.push(`"${report.title}","${report.template.name}","${report.generatedAt.toISOString()}","Metadata","Info","Success Rate: ${report.metadata.successRate.toFixed(1)}%"`);
        // Add section data
        for (const section of report.sections){
            if (section.type === 'tables' && section.content?.rows) {
                const tableData = section.content;
                // Add table headers
                const headers = tableData.headers.map((h)=>`"${h}"`).join(',');
                csvLines.push(`"${report.title}","${report.template.name}","${report.generatedAt.toISOString()}","${section.title}","TableHeader","${headers}"`);
                // Add table rows
                tableData.rows.forEach((row)=>{
                    const rowData = row.map((cell)=>`"${cell}"`).join(',');
                    csvLines.push(`"${report.title}","${report.template.name}","${report.generatedAt.toISOString()}","${section.title}","TableRow","${rowData}"`);
                });
            }
        }
        return Buffer.from(csvLines.join('\n'));
    }
    // Template Methods
    getTemplates() {
        return _ReportTemplates.ReportTemplates.getAllTemplates();
    }
    getTemplate(templateId) {
        return _ReportTemplates.ReportTemplates.getTemplate(templateId);
    }
    getTemplatesByType(type) {
        return _ReportTemplates.ReportTemplates.getTemplatesByType(type);
    }
    async createCustomTemplate(template) {
        const errors = _ReportTemplates.ReportTemplates.validateTemplate(template);
        if (errors.length > 0) {
            throw new Error(`Template validation failed: ${errors.join(', ')}`);
        }
        _ReportTemplates.ReportTemplates.addCustomTemplate(template);
        // Emit template created event
        this.emit('templateCreated', {
            templateId: template.id,
            templateName: template.name,
            timestamp: new Date()
        });
        return template;
    }
    // Report History Methods
    async getReportHistory(limit = 50, offset = 0, filters = {}) {
        let query = `
      SELECT * FROM report_history 
      WHERE 1=1
    `;
        const params = [];
        if (filters.templateId) {
            query += ` AND template_id = ?`;
            params.push(filters.templateId);
        }
        if (filters.userId) {
            query += ` AND created_by = ?`;
            params.push(filters.userId);
        }
        if (filters.startDate) {
            query += ` AND generated_at >= ?`;
            params.push(filters.startDate);
        }
        if (filters.endDate) {
            query += ` AND generated_at <= ?`;
            params.push(filters.endDate);
        }
        query += ` ORDER BY generated_at DESC LIMIT ? OFFSET ?`;
        params.push(limit, offset);
        const reports = this.db.prepare(query).all(...params);
        // Get total count
        const countQuery = query.replace(/SELECT \* FROM/, 'SELECT COUNT(*) as count FROM').replace(/ORDER BY.*$/, '');
        const totalResult = this.db.prepare(countQuery).get(...params.slice(0, -2));
        const total = totalResult?.count || 0;
        return {
            reports,
            total
        };
    }
    async getReportById(reportId) {
        // Check cache first
        const cacheKey = Array.from(this.reportCache.keys()).find((key)=>this.reportCache.get(key)?.id === reportId);
        if (cacheKey) {
            return this.reportCache.get(cacheKey);
        }
        // Check database
        const record = this.db.prepare(`
      SELECT * FROM report_history WHERE id = ?
    `).get(reportId);
        if (!record) {
            return null;
        }
        // Reconstruct report data (this is a simplified version)
        // In a real implementation, you might want to store the full report data
        const template = _ReportTemplates.ReportTemplates.getTemplate(record.template_id);
        if (!template) {
            return null;
        }
        const filters = record.filters ? JSON.parse(record.filters) : {};
        // Regenerate report (this could be optimized by storing the full report)
        return await this.generateReport(record.template_id, filters, {
            saveToHistory: false
        });
    }
    async deleteReport(reportId) {
        const result = this.db.prepare(`
      DELETE FROM report_history WHERE id = ?
    `).run(reportId);
        if (result.changes > 0) {
            // Remove from cache
            const cacheKey = Array.from(this.reportCache.keys()).find((key)=>this.reportCache.get(key)?.id === reportId);
            if (cacheKey) {
                this.reportCache.delete(cacheKey);
            }
            this.emit('reportDeleted', {
                reportId,
                timestamp: new Date()
            });
            return true;
        }
        return false;
    }
    // Schedule Methods
    async createSchedule(schedule) {
        const scheduleId = `schedule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const fullSchedule = {
            id: scheduleId,
            ...schedule
        };
        this.db.prepare(`
      INSERT INTO report_schedules 
      (id, name, template_id, filters, frequency, recipients, export_format, next_execution, enabled)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(scheduleId, schedule.name, schedule.templateId, JSON.stringify(schedule.filters), schedule.frequency, JSON.stringify(schedule.recipients), schedule.format, schedule.nextExecution.toISOString(), schedule.enabled ? 1 : 0);
        this.emit('scheduleCreated', {
            scheduleId,
            scheduleName: schedule.name,
            timestamp: new Date()
        });
        return fullSchedule;
    }
    async getSchedules() {
        const schedules = this.db.prepare(`
      SELECT * FROM report_schedules ORDER BY created_at DESC
    `).all();
        return schedules.map((schedule)=>({
                id: schedule.id,
                name: schedule.name,
                templateId: schedule.template_id,
                filters: schedule.filters ? JSON.parse(schedule.filters) : {},
                frequency: schedule.frequency,
                recipients: schedule.recipients ? JSON.parse(schedule.recipients) : [],
                format: schedule.export_format,
                nextExecution: new Date(schedule.next_execution),
                lastExecution: schedule.last_execution ? new Date(schedule.last_execution) : undefined,
                enabled: Boolean(schedule.enabled)
            }));
    }
    async executeScheduledReports() {
        const now = new Date();
        const dueSchedules = this.db.prepare(`
      SELECT * FROM report_schedules 
      WHERE enabled = 1 AND next_execution <= ?
    `).all(now.toISOString());
        for (const schedule of dueSchedules){
            try {
                const filters = schedule.filters ? JSON.parse(schedule.filters) : {};
                const report = await this.generateReport(schedule.template_id, filters, {
                    saveToHistory: true
                });
                const exportBuffer = await this.exportReport(report.id, schedule.export_format);
                // In a real implementation, you would send the report to recipients
                // For now, we just log the execution
                console.log(`Executed scheduled report: ${schedule.name}`);
                // Update schedule
                const nextExecution = this.calculateNextExecution(schedule.frequency, now);
                this.db.prepare(`
          UPDATE report_schedules 
          SET last_execution = ?, next_execution = ?
          WHERE id = ?
        `).run(now.toISOString(), nextExecution.toISOString(), schedule.id);
                this.emit('scheduleExecuted', {
                    scheduleId: schedule.id,
                    scheduleName: schedule.name,
                    reportId: report.id,
                    timestamp: now
                });
            } catch (error) {
                console.error(`Failed to execute scheduled report ${schedule.name}:`, error);
                this.emit('scheduleExecutionFailed', {
                    scheduleId: schedule.id,
                    scheduleName: schedule.name,
                    error: error.message,
                    timestamp: now
                });
            }
        }
    }
    // Utility Methods
    generateCacheKey(templateId, filters) {
        return `${templateId}:${JSON.stringify(filters)}`;
    }
    async saveReportToHistory(report, userId) {
        this.db.prepare(`
      INSERT INTO report_history 
      (id, template_id, title, description, filters, generated_at, generation_time, 
       total_executions, total_cost, success_rate, created_by, status)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).run(report.id, report.template.id, report.title, report.description, JSON.stringify(report.filters), report.generatedAt.toISOString(), report.metadata.generationTime, report.metadata.totalExecutions, report.metadata.totalCost, report.metadata.successRate, userId || 'system', 'completed');
    }
    async saveExportRecord(reportId, format, fileSize) {
        const exportId = `export_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        this.db.prepare(`
      INSERT INTO report_exports (id, report_id, format, file_size)
      VALUES (?, ?, ?, ?)
    `).run(exportId, reportId, format, fileSize);
    }
    calculateNextExecution(frequency, fromDate) {
        const next = new Date(fromDate);
        switch(frequency){
            case 'daily':
                next.setDate(next.getDate() + 1);
                break;
            case 'weekly':
                next.setDate(next.getDate() + 7);
                break;
            case 'monthly':
                next.setMonth(next.getMonth() + 1);
                break;
            case 'quarterly':
                next.setMonth(next.getMonth() + 3);
                break;
            default:
                next.setDate(next.getDate() + 1);
        }
        return next;
    }
    // Cleanup Methods
    async cleanup() {
        // Clear old cache entries
        const oneHourAgo = Date.now() - 60 * 60 * 1000;
        for (const [key, report] of this.reportCache.entries()){
            if (report.generatedAt.getTime() < oneHourAgo) {
                this.reportCache.delete(key);
            }
        }
        // Clean up old export records
        const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        this.db.prepare(`
      DELETE FROM report_exports 
      WHERE created_at < ?
    `).run(thirtyDaysAgo.toISOString());
        console.log('Report service cleanup completed');
    }
    constructor(){
        super(), _define_property(this, "reportGenerator", void 0), _define_property(this, "pdfExporter", void 0), _define_property(this, "excelExporter", void 0), _define_property(this, "db", void 0), _define_property(this, "reportCache", void 0), _define_property(this, "generationQueue", void 0);
        this.reportGenerator = new _ReportGenerator.ReportGenerator();
        this.pdfExporter = new _PDFExporter.PDFExporter();
        this.excelExporter = new _ExcelExporter.ExcelExporter();
        this.initializeDb();
        this.reportCache = new Map();
        this.generationQueue = new Map();
        this.initializeDatabase();
    }
}
_define_property(ReportService, "instance", void 0);
const reportService = ReportService.getInstance();
