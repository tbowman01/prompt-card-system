c5a0e0b5bf66a19f62ce59d96e0fb98f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ProgressService", {
    enumerable: true,
    get: function() {
        return ProgressService;
    }
});
const _perf_hooks = require("perf_hooks");
const _events = require("events");
const _lrucache = require("lru-cache");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class ProgressService extends _events.EventEmitter {
    /**
   * Emit progress update to subscribed clients with batching
   */ emitProgressUpdate(progress) {
        const startTime = _perf_hooks.performance.now();
        const roomName = `test-${progress.job_id}`;
        // Cache the progress
        this.progressCache.set(progress.job_id, progress);
        // Add to batch queue for efficient processing
        this.queueMessage(roomName, 'progress', progress);
        // Track performance
        this.trackPerformance('emitProgressUpdate', _perf_hooks.performance.now() - startTime);
    }
    /**
   * Emit test result to subscribed clients with compression
   */ emitTestResult(testId, result) {
        const startTime = _perf_hooks.performance.now();
        const roomName = `test-${testId}`;
        // Compress large results if enabled
        const compressedResult = this.compressionEnabled ? this.compressTestResult(result) : result;
        this.queueMessage(roomName, 'test-complete', compressedResult);
        // Track performance
        this.trackPerformance('emitTestResult', _perf_hooks.performance.now() - startTime);
    }
    /**
   * Emit system resource updates with rate limiting
   */ emitResourceUpdate(resources) {
        const now = Date.now();
        const lastEmit = this.lastActivity.get('system-resources') || 0;
        // Rate limit to prevent overwhelming clients (max 1 per second)
        if (now - lastEmit < 1000) {
            return;
        }
        this.lastActivity.set('system-resources', now);
        this.queueMessage('system-resources', 'system-resources', resources);
    }
    /**
   * Emit queue statistics updates with rate limiting
   */ emitQueueStats(stats) {
        const now = Date.now();
        const lastEmit = this.lastActivity.get('queue-stats') || 0;
        // Rate limit to prevent overwhelming clients (max 1 per 2 seconds)
        if (now - lastEmit < 2000) {
            return;
        }
        this.lastActivity.set('queue-stats', now);
        this.queueMessage('queue-stats', 'queue-stats', stats);
    }
    /**
   * Get connected clients count
   */ getConnectedClientsCount() {
        return this.io.sockets.sockets.size;
    }
    /**
   * Get subscriptions for a specific execution
   */ getSubscriptionCount(executionId) {
        return this.io.sockets.adapter.rooms.get(`test-${executionId}`)?.size || 0;
    }
    /**
   * Setup WebSocket event handlers
   */ setupEventHandlers() {
        this.io.on('connection', (socket)=>{
            console.log(`WebSocket client connected: ${socket.id}`);
            this.connectedClients.set(socket.id, new Set());
            // Handle test execution subscription
            socket.on('subscribe-test', (executionId)=>{
                if (typeof executionId === 'string' && executionId.length > 0) {
                    socket.join(`test-${executionId}`);
                    this.connectedClients.get(socket.id)?.add(executionId);
                    console.log(`Client ${socket.id} subscribed to test ${executionId}`);
                    // Send acknowledgment
                    socket.emit('subscription-confirmed', {
                        executionId,
                        status: 'subscribed'
                    });
                }
            });
            // Handle test execution unsubscription
            socket.on('unsubscribe-test', (executionId)=>{
                if (typeof executionId === 'string' && executionId.length > 0) {
                    socket.leave(`test-${executionId}`);
                    this.connectedClients.get(socket.id)?.delete(executionId);
                    console.log(`Client ${socket.id} unsubscribed from test ${executionId}`);
                    // Send acknowledgment
                    socket.emit('subscription-confirmed', {
                        executionId,
                        status: 'unsubscribed'
                    });
                }
            });
            // Handle request for current progress
            socket.on('get-progress', (executionId)=>{
                if (typeof executionId === 'string' && executionId.length > 0) {
                    // This would typically query the TestQueueManager for current progress
                    // For now, we'll emit a response indicating the request was received
                    socket.emit('progress-request-received', {
                        executionId
                    });
                }
            });
            // Handle system resource subscription
            socket.on('subscribe-system-resources', ()=>{
                socket.join('system-resources');
                console.log(`Client ${socket.id} subscribed to system resources`);
                socket.emit('subscription-confirmed', {
                    type: 'system-resources',
                    status: 'subscribed'
                });
            });
            // Handle system resource unsubscription
            socket.on('unsubscribe-system-resources', ()=>{
                socket.leave('system-resources');
                console.log(`Client ${socket.id} unsubscribed from system resources`);
                socket.emit('subscription-confirmed', {
                    type: 'system-resources',
                    status: 'unsubscribed'
                });
            });
            // Handle queue statistics subscription
            socket.on('subscribe-queue-stats', ()=>{
                socket.join('queue-stats');
                console.log(`Client ${socket.id} subscribed to queue statistics`);
                socket.emit('subscription-confirmed', {
                    type: 'queue-stats',
                    status: 'subscribed'
                });
            });
            // Handle queue statistics unsubscription
            socket.on('unsubscribe-queue-stats', ()=>{
                socket.leave('queue-stats');
                console.log(`Client ${socket.id} unsubscribed from queue statistics`);
                socket.emit('subscription-confirmed', {
                    type: 'queue-stats',
                    status: 'unsubscribed'
                });
            });
            // Handle client disconnect
            socket.on('disconnect', (reason)=>{
                console.log(`WebSocket client disconnected: ${socket.id}, reason: ${reason}`);
                this.connectedClients.delete(socket.id);
            });
            // Handle errors
            socket.on('error', (error)=>{
                console.error(`WebSocket error for client ${socket.id}:`, error);
            });
        });
        // Handle adapter errors
        this.io.on('error', (error)=>{
            console.error('Socket.IO server error:', error);
        });
    }
    /**
   * Broadcast message to all connected clients
   */ broadcastMessage(event, data) {
        this.io.emit(event, data);
    }
    /**
   * Send message to specific client
   */ sendToClient(socketId, event, data) {
        this.io.to(socketId).emit(event, data);
    }
    /**
   * Get all active rooms (subscriptions)
   */ getActiveRooms() {
        return Array.from(this.io.sockets.adapter.rooms.keys());
    }
    /**
   * Cleanup resources
   */ destroy() {
        this.connectedClients.clear();
        this.messageQueue.clear();
        this.progressCache.clear();
        this.performanceMetrics.clear();
        this.rateLimitMap.clear();
        this.lastActivity.clear();
        if (this.batchTimer) {
            clearInterval(this.batchTimer);
        }
        this.io.removeAllListeners();
        this.removeAllListeners();
    }
    /**
   * Queue message for batch processing
   */ queueMessage(room, event, data) {
        if (!this.messageQueue.has(room)) {
            this.messageQueue.set(room, []);
        }
        const queue = this.messageQueue.get(room);
        queue.push({
            event,
            data,
            timestamp: Date.now()
        });
        // Limit queue size to prevent memory issues
        if (queue.length > 100) {
            queue.shift();
        }
    }
    /**
   * Start batch processor for efficient message delivery
   */ startBatchProcessor() {
        this.batchTimer = setInterval(()=>{
            this.processBatchedMessages();
        }, 100); // Process every 100ms
    }
    /**
   * Process batched messages
   */ processBatchedMessages() {
        const startTime = _perf_hooks.performance.now();
        let processedCount = 0;
        for (const [room, messages] of this.messageQueue){
            if (messages.length === 0) continue;
            // Group messages by event type
            const eventGroups = new Map();
            messages.forEach((msg)=>{
                if (!eventGroups.has(msg.event)) {
                    eventGroups.set(msg.event, []);
                }
                eventGroups.get(msg.event).push(msg.data);
            });
            // Send grouped messages
            for (const [event, dataArray] of eventGroups){
                if (dataArray.length === 1) {
                    this.io.to(room).emit(event, dataArray[0]);
                } else {
                    // Send as batch if multiple messages
                    this.io.to(room).emit(`${event}-batch`, dataArray);
                }
            }
            processedCount += messages.length;
            messages.length = 0; // Clear the queue
        }
        if (processedCount > 0) {
            this.trackPerformance('processBatchedMessages', _perf_hooks.performance.now() - startTime);
        }
    }
    /**
   * Compress test result for efficient transmission
   */ compressTestResult(result) {
        // Create a compressed version by removing or truncating large fields
        const compressed = {
            ...result,
            llm_output: result.llm_output.length > 1000 ? result.llm_output.substring(0, 1000) + '...[truncated]' : result.llm_output,
            prompt_used: result.prompt_used.length > 500 ? result.prompt_used.substring(0, 500) + '...[truncated]' : result.prompt_used
        };
        return compressed;
    }
    /**
   * Optimize Socket.IO configuration
   */ optimizeSocketIO() {
        // Note: In Socket.IO v4, these configurations are set during server initialization
        // The engine properties are read-only and cannot be modified after creation
        console.log('WebSocket optimizations applied (using default Socket.IO v4 settings)');
    }
    /**
   * Start health monitoring
   */ startHealthMonitoring() {
        setInterval(()=>{
            this.cleanupInactiveClients();
            this.logPerformanceStats();
        }, 1000 * 60 * 5); // Every 5 minutes
    }
    /**
   * Clean up inactive clients
   */ cleanupInactiveClients() {
        const now = Date.now();
        const inactiveThreshold = 1000 * 60 * 10; // 10 minutes
        for (const [clientId, lastActivity] of this.lastActivity){
            if (now - lastActivity > inactiveThreshold) {
                this.lastActivity.delete(clientId);
                this.connectedClients.delete(clientId);
                this.rateLimitMap.delete(clientId);
            }
        }
    }
    /**
   * Track performance metrics
   */ trackPerformance(operation, duration) {
        if (!this.performanceMetrics.has(operation)) {
            this.performanceMetrics.set(operation, []);
        }
        const metrics = this.performanceMetrics.get(operation);
        metrics.push(duration);
        // Keep only last 100 measurements
        if (metrics.length > 100) {
            metrics.shift();
        }
        // Log slow operations
        if (duration > 50) {
            console.warn(`Slow WebSocket operation: ${operation} took ${duration.toFixed(2)}ms`);
        }
    }
    /**
   * Log performance statistics
   */ logPerformanceStats() {
        const stats = {};
        for (const [operation, metrics] of this.performanceMetrics){
            if (metrics.length > 0) {
                const avg = metrics.reduce((sum, time)=>sum + time, 0) / metrics.length;
                const max = Math.max(...metrics);
                stats[operation] = {
                    avg: Math.round(avg * 100) / 100,
                    max: Math.round(max * 100) / 100,
                    count: metrics.length
                };
            }
        }
        if (Object.keys(stats).length > 0) {
            console.log('WebSocket Performance Stats:', stats);
        }
    }
    /**
   * Get current progress for a job
   */ getCurrentProgress(jobId) {
        return this.progressCache.get(jobId) || null;
    }
    /**
   * Get performance statistics
   */ getPerformanceStats() {
        const stats = {};
        for (const [operation, metrics] of this.performanceMetrics){
            if (metrics.length > 0) {
                const avg = metrics.reduce((sum, time)=>sum + time, 0) / metrics.length;
                const max = Math.max(...metrics);
                const min = Math.min(...metrics);
                stats[operation] = {
                    avg: Math.round(avg * 100) / 100,
                    max: Math.round(max * 100) / 100,
                    min: Math.round(min * 100) / 100,
                    count: metrics.length
                };
            }
        }
        return stats;
    }
    /**
   * Get connection statistics
   */ getConnectionStats() {
        return {
            totalConnections: this.connectedClients.size,
            activeRooms: this.getActiveRooms().length,
            messageQueueSize: Array.from(this.messageQueue.values()).reduce((sum, queue)=>sum + queue.length, 0),
            cacheSize: this.progressCache.size
        };
    }
    constructor(io){
        super(), _define_property(this, "io", void 0), _define_property(this, "connectedClients", new Map()) // socketId -> subscribed executionIds
        , _define_property(this, "messageQueue", new Map()) // Room -> queued messages
        , _define_property(this, "progressCache", void 0), _define_property(this, "performanceMetrics", void 0), _define_property(this, "batchTimer", null), _define_property(this, "compressionEnabled", void 0), _define_property(this, "rateLimitMap", new Map()), _define_property(this, "lastActivity", new Map());
        this.io = io;
        // Initialize performance optimizations
        this.progressCache = new _lrucache.LRUCache({
            max: 1000,
            ttl: 1000 * 60 * 5 // 5 minutes
        });
        this.performanceMetrics = new Map();
        this.compressionEnabled = true;
        // Configure Socket.IO for better performance
        this.optimizeSocketIO();
        this.setupEventHandlers();
        this.startBatchProcessor();
        this.startHealthMonitoring();
    }
}
