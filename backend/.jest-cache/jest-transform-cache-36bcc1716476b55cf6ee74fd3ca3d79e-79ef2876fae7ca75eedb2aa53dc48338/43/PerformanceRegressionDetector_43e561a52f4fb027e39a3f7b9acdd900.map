{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/performance/PerformanceRegressionDetector.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport { db } from '../../database/connection';\nimport { LoadTestResults } from './LoadTestingFramework';\nimport { performanceMonitor } from './PerformanceMonitor';\nimport { alertingSystem, AlertType } from '../health/AlertingSystem';\nimport { LRUCache } from 'lru-cache';\nimport * as tf from '@tensorflow/tfjs-node';\n\nexport interface RegressionBaseline {\n  id: string;\n  scenarioId: string;\n  metrics: PerformanceMetrics;\n  timestamp: Date;\n  version?: string;\n  environment?: string;\n  sampleSize: number;\n  confidence: number;\n}\n\nexport interface PerformanceMetrics {\n  responseTime: {\n    mean: number;\n    p50: number;\n    p95: number;\n    p99: number;\n    std: number;\n  };\n  throughput: {\n    mean: number;\n    std: number;\n  };\n  errorRate: number;\n  availability: number;\n  resourceUsage: {\n    cpu: number;\n    memory: number;\n    io: number;\n  };\n}\n\nexport interface RegressionAlert {\n  id: string;\n  scenarioId: string;\n  metric: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  degradation: number; // Percentage\n  baseline: number;\n  current: number;\n  threshold: number;\n  confidence: number;\n  timestamp: Date;\n  additionalContext: {\n    trend: 'improving' | 'stable' | 'degrading';\n    changePoints: number[];\n    seasonality?: string;\n    correlatedMetrics: string[];\n  };\n  recommendations: string[];\n}\n\nexport interface RegressionThreshold {\n  metric: string;\n  warning: number; // Percentage change\n  critical: number; // Percentage change\n  method: 'absolute' | 'statistical' | 'adaptive';\n  confidence: number; // Statistical confidence level\n  minSampleSize: number;\n}\n\nexport interface ChangePointDetection {\n  timestamp: number;\n  confidence: number;\n  changeType: 'level' | 'trend' | 'variance';\n  magnitude: number;\n  metrics: string[];\n}\n\nexport interface TrendAnalysis {\n  metric: string;\n  period: string;\n  trend: 'improving' | 'stable' | 'degrading';\n  slope: number;\n  correlation: number;\n  seasonality: {\n    detected: boolean;\n    period?: number;\n    amplitude?: number;\n  };\n  forecast: {\n    nextValue: number;\n    confidence: number;\n    upperBound: number;\n    lowerBound: number;\n  };\n}\n\nclass StatisticalAnalyzer {\n  /**\n   * Calculate statistical significance using Student's t-test\n   */\n  static tTest(baseline: number[], current: number[], alpha: number = 0.05): {\n    significant: boolean;\n    pValue: number;\n    tStatistic: number;\n    degreesOfFreedom: number;\n  } {\n    const n1 = baseline.length;\n    const n2 = current.length;\n    \n    if (n1 < 2 || n2 < 2) {\n      return { significant: false, pValue: 1, tStatistic: 0, degreesOfFreedom: 0 };\n    }\n\n    const mean1 = baseline.reduce((sum, val) => sum + val, 0) / n1;\n    const mean2 = current.reduce((sum, val) => sum + val, 0) / n2;\n    \n    const var1 = baseline.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / (n1 - 1);\n    const var2 = current.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / (n2 - 1);\n    \n    const pooledVar = ((n1 - 1) * var1 + (n2 - 1) * var2) / (n1 + n2 - 2);\n    const standardError = Math.sqrt(pooledVar * (1/n1 + 1/n2));\n    \n    const tStatistic = (mean2 - mean1) / standardError;\n    const degreesOfFreedom = n1 + n2 - 2;\n    \n    // Simplified p-value calculation (in production, use proper statistical library)\n    const pValue = this.calculatePValue(Math.abs(tStatistic), degreesOfFreedom);\n    \n    return {\n      significant: pValue < alpha,\n      pValue,\n      tStatistic,\n      degreesOfFreedom\n    };\n  }\n\n  /**\n   * Detect change points in time series using CUSUM\n   */\n  static detectChangePoints(values: number[], threshold: number = 5): ChangePointDetection[] {\n    if (values.length < 10) return [];\n    \n    const mean = values.reduce((sum, val) => sum + val, 0) / values.length;\n    const std = Math.sqrt(values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length);\n    \n    let cusum = 0;\n    const changePoints: ChangePointDetection[] = [];\n    \n    for (let i = 1; i < values.length; i++) {\n      cusum = Math.max(0, cusum + (values[i] - mean) / std - 0.5);\n      \n      if (cusum > threshold) {\n        const magnitude = Math.abs(values[i] - mean) / std;\n        changePoints.push({\n          timestamp: i,\n          confidence: Math.min(cusum / threshold, 1),\n          changeType: this.classifyChange(values, i),\n          magnitude,\n          metrics: ['responseTime'] // Simplified\n        });\n        cusum = 0; // Reset after detection\n      }\n    }\n    \n    return changePoints;\n  }\n\n  /**\n   * Calculate Mann-Kendall trend test\n   */\n  static mannKendallTrend(values: number[]): {\n    trend: 'improving' | 'stable' | 'degrading';\n    slope: number;\n    significance: number;\n  } {\n    const n = values.length;\n    if (n < 4) {\n      return { trend: 'stable', slope: 0, significance: 0 };\n    }\n\n    let s = 0;\n    for (let i = 0; i < n - 1; i++) {\n      for (let j = i + 1; j < n; j++) {\n        s += Math.sign(values[j] - values[i]);\n      }\n    }\n\n    const variance = n * (n - 1) * (2 * n + 5) / 18;\n    const z = s / Math.sqrt(variance);\n    \n    // Calculate Theil-Sen slope estimator\n    const slopes: number[] = [];\n    for (let i = 0; i < n - 1; i++) {\n      for (let j = i + 1; j < n; j++) {\n        slopes.push((values[j] - values[i]) / (j - i));\n      }\n    }\n    slopes.sort((a, b) => a - b);\n    const slope = slopes[Math.floor(slopes.length / 2)];\n\n    const significance = Math.abs(z);\n    let trend: 'improving' | 'stable' | 'degrading' = 'stable';\n    \n    if (significance > 1.96) { // 95% confidence\n      trend = slope > 0 ? 'degrading' : 'improving';\n    }\n\n    return { trend, slope, significance };\n  }\n\n  /**\n   * Detect seasonality using FFT\n   */\n  static detectSeasonality(values: number[]): {\n    detected: boolean;\n    period?: number;\n    amplitude?: number;\n    confidence: number;\n  } {\n    if (values.length < 24) {\n      return { detected: false, confidence: 0 };\n    }\n\n    // Simplified seasonality detection\n    // In production, use proper FFT implementation\n    const autocorrelations: number[] = [];\n    const maxLag = Math.min(values.length / 3, 48);\n    \n    for (let lag = 1; lag <= maxLag; lag++) {\n      let correlation = 0;\n      for (let i = lag; i < values.length; i++) {\n        correlation += values[i] * values[i - lag];\n      }\n      autocorrelations.push(correlation / (values.length - lag));\n    }\n\n    // Find peaks in autocorrelation\n    const peaks: { lag: number; value: number }[] = [];\n    for (let i = 1; i < autocorrelations.length - 1; i++) {\n      if (autocorrelations[i] > autocorrelations[i - 1] && \n          autocorrelations[i] > autocorrelations[i + 1]) {\n        peaks.push({ lag: i + 1, value: autocorrelations[i] });\n      }\n    }\n\n    if (peaks.length === 0) {\n      return { detected: false, confidence: 0 };\n    }\n\n    const strongestPeak = peaks.reduce((max, peak) => \n      peak.value > max.value ? peak : max);\n\n    const threshold = Math.max(...autocorrelations) * 0.3;\n    const detected = strongestPeak.value > threshold;\n\n    return {\n      detected,\n      period: detected ? strongestPeak.lag : undefined,\n      amplitude: detected ? strongestPeak.value : undefined,\n      confidence: detected ? strongestPeak.value / Math.max(...autocorrelations) : 0\n    };\n  }\n\n  private static calculatePValue(tStat: number, df: number): number {\n    // Simplified p-value calculation\n    // In production, use proper statistical library\n    const t = Math.abs(tStat);\n    if (df >= 30) {\n      // Approximate with normal distribution for large df\n      return 2 * (1 - this.normalCDF(t));\n    }\n    \n    // Simplified approximation for small df\n    const p = 1 / (1 + t * t / df);\n    return 2 * Math.pow(p, df / 2);\n  }\n\n  private static normalCDF(x: number): number {\n    // Approximation of normal CDF\n    return 0.5 * (1 + this.erf(x / Math.sqrt(2)));\n  }\n\n  private static erf(x: number): number {\n    // Approximation of error function\n    const a1 =  0.254829592;\n    const a2 = -0.284496736;\n    const a3 =  1.421413741;\n    const a4 = -1.453152027;\n    const a5 =  1.061405429;\n    const p  =  0.3275911;\n\n    const sign = x >= 0 ? 1 : -1;\n    x = Math.abs(x);\n\n    const t = 1.0 / (1.0 + p * x);\n    const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);\n\n    return sign * y;\n  }\n\n  private static classifyChange(values: number[], index: number): 'level' | 'trend' | 'variance' {\n    const before = values.slice(Math.max(0, index - 5), index);\n    const after = values.slice(index, Math.min(values.length, index + 5));\n    \n    if (before.length < 2 || after.length < 2) return 'level';\n    \n    const meanBefore = before.reduce((sum, val) => sum + val, 0) / before.length;\n    const meanAfter = after.reduce((sum, val) => sum + val, 0) / after.length;\n    const varBefore = before.reduce((sum, val) => sum + Math.pow(val - meanBefore, 2), 0) / before.length;\n    const varAfter = after.reduce((sum, val) => sum + Math.pow(val - meanAfter, 2), 0) / after.length;\n    \n    const levelChange = Math.abs(meanAfter - meanBefore);\n    const varianceChange = Math.abs(varAfter - varBefore);\n    \n    if (varianceChange > levelChange * 2) return 'variance';\n    return 'level';\n  }\n}\n\nexport class PerformanceRegressionDetector extends EventEmitter {\n  private baselines: Map<string, RegressionBaseline> = new Map();\n  private thresholds: Map<string, RegressionThreshold> = new Map();\n  private cache: LRUCache<string, any>;\n  private isMonitoring: boolean = false;\n  private monitoringInterval: NodeJS.Timeout | null = null;\n  private neuralModel: tf.LayersModel | null = null;\n  private trainingData: Array<{ features: number[]; label: number }> = [];\n\n  constructor() {\n    super();\n    this.cache = new LRUCache({\n      max: 1000,\n      ttl: 1000 * 60 * 15 // 15 minutes\n    });\n    \n    this.setupDefaultThresholds();\n    this.initializeNeuralModel();\n    this.loadBaselinesFromDatabase();\n  }\n\n  /**\n   * Start automated regression monitoring\n   */\n  startMonitoring(intervalMinutes: number = 15): void {\n    if (this.isMonitoring) return;\n\n    this.isMonitoring = true;\n    this.monitoringInterval = setInterval(() => {\n      this.performRegressionCheck().catch(error => {\n        console.error('Regression monitoring failed:', error);\n        this.emit('monitoringError', error);\n      });\n    }, intervalMinutes * 60 * 1000);\n\n    console.log(`Performance regression monitoring started (${intervalMinutes}min interval)`);\n    this.emit('monitoringStarted', { intervalMinutes });\n  }\n\n  /**\n   * Stop automated monitoring\n   */\n  stopMonitoring(): void {\n    if (!this.isMonitoring) return;\n\n    this.isMonitoring = false;\n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n\n    console.log('Performance regression monitoring stopped');\n    this.emit('monitoringStopped');\n  }\n\n  /**\n   * Analyze load test results for regressions\n   */\n  async analyzeResults(scenarioId: string, results: LoadTestResults): Promise<RegressionAlert[]> {\n    const baseline = this.baselines.get(scenarioId);\n    if (!baseline) {\n      console.log(`No baseline found for scenario: ${scenarioId}`);\n      return [];\n    }\n\n    const alerts: RegressionAlert[] = [];\n    const currentMetrics = this.extractMetrics(results);\n\n    // Analyze each metric\n    const metricsToAnalyze = [\n      { key: 'responseTime.p95', current: currentMetrics.responseTime.p95, baseline: baseline.metrics.responseTime.p95 },\n      { key: 'responseTime.mean', current: currentMetrics.responseTime.mean, baseline: baseline.metrics.responseTime.mean },\n      { key: 'throughput.mean', current: currentMetrics.throughput.mean, baseline: baseline.metrics.throughput.mean },\n      { key: 'errorRate', current: currentMetrics.errorRate, baseline: baseline.metrics.errorRate }\n    ];\n\n    for (const metric of metricsToAnalyze) {\n      const threshold = this.thresholds.get(metric.key);\n      if (!threshold) continue;\n\n      const regression = await this.detectRegression(metric.key, metric.current, metric.baseline, threshold);\n      if (regression) {\n        alerts.push(regression);\n      }\n    }\n\n    // Perform trend analysis\n    const trendAnalysis = await this.analyzeTrends(scenarioId);\n    if (trendAnalysis && trendAnalysis.trend === 'degrading') {\n      alerts.push({\n        id: `trend-${scenarioId}-${Date.now()}`,\n        scenarioId,\n        metric: 'trend',\n        severity: 'medium',\n        degradation: Math.abs(trendAnalysis.slope) * 100,\n        baseline: 0,\n        current: trendAnalysis.slope,\n        threshold: 0.1,\n        confidence: trendAnalysis.correlation,\n        timestamp: new Date(),\n        additionalContext: {\n          trend: trendAnalysis.trend,\n          changePoints: [],\n          correlatedMetrics: []\n        },\n        recommendations: [\n          'Performance trend is degrading over time',\n          'Consider investigating recent changes or increased load',\n          'Monitor system resources for potential bottlenecks'\n        ]\n      });\n    }\n\n    // Use neural model for anomaly detection\n    if (this.neuralModel) {\n      const anomalyScore = await this.detectAnomalies(currentMetrics);\n      if (anomalyScore > 0.8) {\n        alerts.push({\n          id: `anomaly-${scenarioId}-${Date.now()}`,\n          scenarioId,\n          metric: 'anomaly',\n          severity: 'high',\n          degradation: anomalyScore * 100,\n          baseline: 0.5,\n          current: anomalyScore,\n          threshold: 0.8,\n          confidence: anomalyScore,\n          timestamp: new Date(),\n          additionalContext: {\n            trend: 'stable',\n            changePoints: [],\n            correlatedMetrics: []\n          },\n          recommendations: [\n            'Neural network detected performance anomaly',\n            'Current metrics deviate significantly from learned patterns',\n            'Investigate system changes or unusual load patterns'\n          ]\n        });\n      }\n    }\n\n    // Send alerts\n    for (const alert of alerts) {\n      await this.sendAlert(alert);\n    }\n\n    this.emit('regressionAnalysisComplete', { scenarioId, alerts, currentMetrics, baseline });\n    return alerts;\n  }\n\n  /**\n   * Set or update baseline for a scenario\n   */\n  async setBaseline(scenarioId: string, results: LoadTestResults, options?: {\n    version?: string;\n    environment?: string;\n    confidence?: number;\n  }): Promise<void> {\n    const metrics = this.extractMetrics(results);\n    const baseline: RegressionBaseline = {\n      id: `${scenarioId}-${Date.now()}`,\n      scenarioId,\n      metrics,\n      timestamp: new Date(),\n      version: options?.version,\n      environment: options?.environment || process.env.NODE_ENV || 'unknown',\n      sampleSize: results.summary.totalRequests,\n      confidence: options?.confidence || 0.95\n    };\n\n    this.baselines.set(scenarioId, baseline);\n    await this.saveBaseline(baseline);\n    \n    // Add to training data for neural model\n    this.addTrainingData(metrics);\n    \n    this.emit('baselineUpdated', baseline);\n    console.log(`Baseline updated for scenario: ${scenarioId}`);\n  }\n\n  /**\n   * Configure regression thresholds\n   */\n  setThreshold(metric: string, threshold: RegressionThreshold): void {\n    this.thresholds.set(metric, threshold);\n    this.emit('thresholdUpdated', { metric, threshold });\n  }\n\n  /**\n   * Get all baselines\n   */\n  getBaselines(): RegressionBaseline[] {\n    return Array.from(this.baselines.values());\n  }\n\n  /**\n   * Get regression alerts for a time period\n   */\n  async getRegressionAlerts(period?: { start: Date; end: Date }): Promise<RegressionAlert[]> {\n    try {\n      let query = 'SELECT * FROM regression_alerts ORDER BY timestamp DESC';\n      const params: any[] = [];\n\n      if (period) {\n        query = 'SELECT * FROM regression_alerts WHERE timestamp BETWEEN ? AND ? ORDER BY timestamp DESC';\n        params.push(period.start.toISOString(), period.end.toISOString());\n      }\n\n      const stmt = db.prepare(query);\n      const rows = stmt.all(...params) as any[];\n      \n      return rows.map(row => ({\n        ...JSON.parse(row.alert_data),\n        timestamp: new Date(row.timestamp)\n      }));\n    } catch (error) {\n      console.error('Failed to fetch regression alerts:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Generate regression report\n   */\n  async generateRegressionReport(scenarioId: string, period: { start: Date; end: Date }): Promise<{\n    summary: {\n      totalAlerts: number;\n      criticalAlerts: number;\n      mostAffectedMetrics: string[];\n      overallTrend: 'improving' | 'stable' | 'degrading';\n    };\n    alerts: RegressionAlert[];\n    trends: TrendAnalysis[];\n    recommendations: string[];\n  }> {\n    const alerts = await this.getRegressionAlerts(period);\n    const scenarioAlerts = alerts.filter(a => a.scenarioId === scenarioId);\n    \n    const trends = await this.analyzeTrends(scenarioId, period);\n    \n    const summary = {\n      totalAlerts: scenarioAlerts.length,\n      criticalAlerts: scenarioAlerts.filter(a => a.severity === 'critical').length,\n      mostAffectedMetrics: this.getMostAffectedMetrics(scenarioAlerts),\n      overallTrend: trends?.trend || 'stable' as 'improving' | 'stable' | 'degrading'\n    };\n\n    const recommendations = this.generateRecommendations(scenarioAlerts, trends);\n\n    return {\n      summary,\n      alerts: scenarioAlerts,\n      trends: trends ? [trends] : [],\n      recommendations\n    };\n  }\n\n  /**\n   * Train neural model for anomaly detection\n   */\n  async trainNeuralModel(): Promise<void> {\n    if (this.trainingData.length < 100) {\n      console.log('Insufficient training data for neural model');\n      return;\n    }\n\n    console.log('Training neural model for anomaly detection...');\n    \n    const features = this.trainingData.map(d => d.features);\n    const labels = this.trainingData.map(d => d.label);\n    \n    const xs = tf.tensor2d(features);\n    const ys = tf.tensor1d(labels);\n    \n    // Create autoencoder for anomaly detection\n    const model = tf.sequential({\n      layers: [\n        tf.layers.dense({ inputShape: [features[0].length], units: 64, activation: 'relu' }),\n        tf.layers.dense({ units: 32, activation: 'relu' }),\n        tf.layers.dense({ units: 16, activation: 'relu' }),\n        tf.layers.dense({ units: 32, activation: 'relu' }),\n        tf.layers.dense({ units: 64, activation: 'relu' }),\n        tf.layers.dense({ units: features[0].length, activation: 'linear' })\n      ]\n    });\n    \n    model.compile({\n      optimizer: 'adam',\n      loss: 'meanSquaredError'\n    });\n    \n    await model.fit(xs, xs, {\n      epochs: 100,\n      batchSize: 32,\n      validationSplit: 0.2,\n      verbose: 0\n    });\n    \n    this.neuralModel = model;\n    console.log('Neural model training completed');\n    \n    xs.dispose();\n    ys.dispose();\n  }\n\n  /**\n   * Private methods\n   */\n  private async performRegressionCheck(): Promise<void> {\n    console.log('Performing automated regression check...');\n    \n    // Get recent performance data\n    const recentMetrics = await this.getRecentMetrics();\n    \n    for (const [scenarioId, baseline] of this.baselines) {\n      const currentMetrics = recentMetrics.get(scenarioId);\n      if (!currentMetrics) continue;\n      \n      // Mock LoadTestResults for compatibility\n      const mockResults: LoadTestResults = {\n        scenario: { id: scenarioId } as any,\n        summary: { totalRequests: 100 } as any,\n        metrics: {\n          responseTime: currentMetrics.responseTime,\n          throughput: currentMetrics.throughput,\n          errorRate: currentMetrics.errorRate\n        } as any,\n        timeline: [],\n        errors: [],\n        thresholdResults: [],\n        recommendations: []\n      };\n      \n      await this.analyzeResults(scenarioId, mockResults);\n    }\n  }\n\n  private async detectRegression(\n    metricKey: string,\n    current: number,\n    baseline: number,\n    threshold: RegressionThreshold\n  ): Promise<RegressionAlert | null> {\n    let degradation = 0;\n    let severity: 'low' | 'medium' | 'high' | 'critical' = 'low';\n    \n    // Calculate degradation based on metric type\n    if (metricKey.includes('responseTime') || metricKey.includes('errorRate')) {\n      degradation = ((current - baseline) / baseline) * 100;\n    } else if (metricKey.includes('throughput')) {\n      degradation = ((baseline - current) / baseline) * 100;\n    }\n    \n    // Determine if regression occurred\n    const isRegression = Math.abs(degradation) > threshold.warning;\n    if (!isRegression) return null;\n    \n    // Determine severity\n    if (Math.abs(degradation) > threshold.critical) {\n      severity = 'critical';\n    } else if (Math.abs(degradation) > threshold.warning * 1.5) {\n      severity = 'high';\n    } else {\n      severity = 'medium';\n    }\n    \n    return {\n      id: `regression-${metricKey}-${Date.now()}`,\n      scenarioId: metricKey.split('.')[0],\n      metric: metricKey,\n      severity,\n      degradation: Math.abs(degradation),\n      baseline,\n      current,\n      threshold: threshold.warning,\n      confidence: 0.95,\n      timestamp: new Date(),\n      additionalContext: {\n        trend: degradation > 0 ? 'degrading' : 'improving',\n        changePoints: [],\n        correlatedMetrics: []\n      },\n      recommendations: this.getMetricRecommendations(metricKey, degradation)\n    };\n  }\n\n  private async analyzeTrends(scenarioId: string, period?: { start: Date; end: Date }): Promise<TrendAnalysis | null> {\n    try {\n      // Get historical data\n      const historicalData = await this.getHistoricalData(scenarioId, period);\n      if (historicalData.length < 10) return null;\n      \n      const values = historicalData.map(d => d.value);\n      const trend = StatisticalAnalyzer.mannKendallTrend(values);\n      const seasonality = StatisticalAnalyzer.detectSeasonality(values);\n      \n      // Simple forecast (last value + trend)\n      const lastValue = values[values.length - 1];\n      const forecast = {\n        nextValue: lastValue + trend.slope,\n        confidence: trend.significance / 10,\n        upperBound: lastValue + trend.slope * 1.2,\n        lowerBound: lastValue + trend.slope * 0.8\n      };\n      \n      return {\n        metric: scenarioId,\n        period: period ? `${period.start.toISOString()}-${period.end.toISOString()}` : 'recent',\n        trend: trend.trend,\n        slope: trend.slope,\n        correlation: trend.significance / 10,\n        seasonality,\n        forecast\n      };\n    } catch (error) {\n      console.error('Failed to analyze trends:', error);\n      return null;\n    }\n  }\n\n  private async detectAnomalies(metrics: PerformanceMetrics): Promise<number> {\n    if (!this.neuralModel) return 0;\n    \n    try {\n      const features = this.metricsToFeatures(metrics);\n      const input = tf.tensor2d([features]);\n      const reconstruction = this.neuralModel.predict(input) as tf.Tensor;\n      \n      // Calculate reconstruction error\n      const error = tf.losses.meanSquaredError(input, reconstruction);\n      const errorValue = await error.data();\n      \n      input.dispose();\n      reconstruction.dispose();\n      error.dispose();\n      \n      // Normalize error to 0-1 scale\n      return Math.min(errorValue[0] * 10, 1);\n    } catch (error) {\n      console.error('Anomaly detection failed:', error);\n      return 0;\n    }\n  }\n\n  private async sendAlert(alert: RegressionAlert): Promise<void> {\n    // Save to database\n    try {\n      const stmt = db.prepare(`\n        INSERT INTO regression_alerts \n        (scenario_id, metric, severity, degradation, timestamp, alert_data)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `);\n      \n      stmt.run(\n        alert.scenarioId,\n        alert.metric,\n        alert.severity,\n        alert.degradation,\n        alert.timestamp.toISOString(),\n        JSON.stringify(alert)\n      );\n    } catch (error) {\n      console.error('Failed to save regression alert:', error);\n    }\n    \n    // Send to alerting system\n    alertingSystem.checkAndCreateAlert({\n      type: AlertType.PERFORMANCE,\n      service: 'performance-regression-detector',\n      message: `${alert.metric} degraded by ${alert.degradation.toFixed(1)}% (${alert.current} vs baseline ${alert.baseline})`,\n      details: {\n        scenarioId: alert.scenarioId,\n        metric: alert.metric,\n        degradation: alert.degradation,\n        recommendations: alert.recommendations\n      }\n    });\n    \n    this.emit('regressionAlert', alert);\n  }\n\n  private extractMetrics(results: LoadTestResults): PerformanceMetrics {\n    return {\n      responseTime: {\n        mean: results.metrics.responseTime.avg,\n        p50: results.metrics.responseTime.p50,\n        p95: results.metrics.responseTime.p95,\n        p99: results.metrics.responseTime.p99,\n        std: 0 // Would calculate from raw data\n      },\n      throughput: {\n        mean: results.metrics.throughput.avg,\n        std: 0 // Would calculate from timeline data\n      },\n      errorRate: results.metrics.errorRate,\n      availability: 100 - results.metrics.errorRate,\n      resourceUsage: {\n        cpu: 0, // Would get from system metrics\n        memory: 0,\n        io: 0\n      }\n    };\n  }\n\n  private setupDefaultThresholds(): void {\n    this.setThreshold('responseTime.p95', {\n      metric: 'responseTime.p95',\n      warning: 20, // 20% increase\n      critical: 50, // 50% increase\n      method: 'statistical',\n      confidence: 0.95,\n      minSampleSize: 30\n    });\n    \n    this.setThreshold('responseTime.mean', {\n      metric: 'responseTime.mean',\n      warning: 15,\n      critical: 40,\n      method: 'statistical',\n      confidence: 0.95,\n      minSampleSize: 30\n    });\n    \n    this.setThreshold('throughput.mean', {\n      metric: 'throughput.mean',\n      warning: 15, // 15% decrease\n      critical: 30, // 30% decrease\n      method: 'statistical',\n      confidence: 0.95,\n      minSampleSize: 30\n    });\n    \n    this.setThreshold('errorRate', {\n      metric: 'errorRate',\n      warning: 100, // 100% increase (double)\n      critical: 300, // 300% increase (4x)\n      method: 'absolute',\n      confidence: 0.95,\n      minSampleSize: 10\n    });\n  }\n\n  private async initializeNeuralModel(): Promise<void> {\n    // Initialize with a simple autoencoder\n    // In production, load pre-trained model or train with historical data\n    try {\n      this.neuralModel = tf.sequential({\n        layers: [\n          tf.layers.dense({ inputShape: [8], units: 16, activation: 'relu' }),\n          tf.layers.dense({ units: 8, activation: 'relu' }),\n          tf.layers.dense({ units: 4, activation: 'relu' }),\n          tf.layers.dense({ units: 8, activation: 'relu' }),\n          tf.layers.dense({ units: 16, activation: 'relu' }),\n          tf.layers.dense({ units: 8, activation: 'linear' })\n        ]\n      });\n      \n      this.neuralModel.compile({\n        optimizer: 'adam',\n        loss: 'meanSquaredError'\n      });\n    } catch (error) {\n      console.error('Failed to initialize neural model:', error);\n    }\n  }\n\n  private async loadBaselinesFromDatabase(): Promise<void> {\n    try {\n      const stmt = db.prepare('SELECT * FROM regression_baselines ORDER BY timestamp DESC');\n      const rows = stmt.all() as any[];\n      \n      for (const row of rows) {\n        const baseline = JSON.parse(row.baseline_data);\n        baseline.timestamp = new Date(row.timestamp);\n        this.baselines.set(baseline.scenarioId, baseline);\n      }\n      \n      console.log(`Loaded ${rows.length} baselines from database`);\n    } catch (error) {\n      console.error('Failed to load baselines:', error);\n    }\n  }\n\n  private async saveBaseline(baseline: RegressionBaseline): Promise<void> {\n    try {\n      const stmt = db.prepare(`\n        INSERT OR REPLACE INTO regression_baselines \n        (scenario_id, timestamp, baseline_data)\n        VALUES (?, ?, ?)\n      `);\n      \n      stmt.run(\n        baseline.scenarioId,\n        baseline.timestamp.toISOString(),\n        JSON.stringify(baseline)\n      );\n    } catch (error) {\n      console.error('Failed to save baseline:', error);\n    }\n  }\n\n  private addTrainingData(metrics: PerformanceMetrics): void {\n    const features = this.metricsToFeatures(metrics);\n    this.trainingData.push({\n      features,\n      label: 0 // Normal performance (for autoencoder)\n    });\n    \n    // Keep only recent training data\n    if (this.trainingData.length > 10000) {\n      this.trainingData = this.trainingData.slice(-5000);\n    }\n  }\n\n  private metricsToFeatures(metrics: PerformanceMetrics): number[] {\n    return [\n      metrics.responseTime.mean,\n      metrics.responseTime.p95,\n      metrics.responseTime.p99,\n      metrics.throughput.mean,\n      metrics.errorRate,\n      metrics.availability,\n      metrics.resourceUsage.cpu,\n      metrics.resourceUsage.memory\n    ];\n  }\n\n  private async getRecentMetrics(): Promise<Map<string, PerformanceMetrics>> {\n    // Mock implementation - would get from performance monitor\n    const metrics = new Map<string, PerformanceMetrics>();\n    \n    // This would typically fetch recent performance data\n    // For now, return empty map\n    return metrics;\n  }\n\n  private async getHistoricalData(scenarioId: string, period?: { start: Date; end: Date }): Promise<Array<{ timestamp: Date; value: number }>> {\n    // Mock implementation - would fetch from database\n    return [];\n  }\n\n  private getMostAffectedMetrics(alerts: RegressionAlert[]): string[] {\n    const metricCounts = new Map<string, number>();\n    \n    alerts.forEach(alert => {\n      const count = metricCounts.get(alert.metric) || 0;\n      metricCounts.set(alert.metric, count + 1);\n    });\n    \n    return Array.from(metricCounts.entries())\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([metric]) => metric);\n  }\n\n  private generateRecommendations(alerts: RegressionAlert[], trends?: TrendAnalysis): string[] {\n    const recommendations = new Set<string>();\n    \n    if (alerts.some(a => a.metric.includes('responseTime'))) {\n      recommendations.add('Consider optimizing database queries and adding caching');\n      recommendations.add('Review recent code changes that might affect response times');\n    }\n    \n    if (alerts.some(a => a.metric.includes('throughput'))) {\n      recommendations.add('Investigate resource bottlenecks (CPU, memory, I/O)');\n      recommendations.add('Consider horizontal scaling or load balancing improvements');\n    }\n    \n    if (alerts.some(a => a.metric.includes('errorRate'))) {\n      recommendations.add('Review error logs for patterns and implement better error handling');\n      recommendations.add('Check system dependencies and external service availability');\n    }\n    \n    if (trends?.trend === 'degrading') {\n      recommendations.add('Performance is degrading over time - schedule maintenance review');\n      recommendations.add('Monitor for memory leaks or resource accumulation issues');\n    }\n    \n    if (alerts.some(a => a.severity === 'critical')) {\n      recommendations.add('CRITICAL: Immediate investigation required for production stability');\n    }\n    \n    return Array.from(recommendations);\n  }\n\n  private getMetricRecommendations(metricKey: string, degradation: number): string[] {\n    const recommendations = [];\n    \n    if (metricKey.includes('responseTime')) {\n      recommendations.push('Response time degradation detected');\n      if (degradation > 50) {\n        recommendations.push('SEVERE: Response time increased by >50% - immediate action required');\n      }\n      recommendations.push('Check database performance and query optimization');\n      recommendations.push('Review caching strategies and hit rates');\n    } else if (metricKey.includes('throughput')) {\n      recommendations.push('Throughput degradation detected');\n      recommendations.push('Monitor system resources (CPU, memory, I/O)');\n      recommendations.push('Consider scaling or load balancing adjustments');\n    } else if (metricKey.includes('errorRate')) {\n      recommendations.push('Error rate increase detected');\n      recommendations.push('Review application logs for error patterns');\n      recommendations.push('Check external dependencies and service health');\n    }\n    \n    return recommendations;\n  }\n\n  /**\n   * Clean up resources\n   */\n  async cleanup(): Promise<void> {\n    this.stopMonitoring();\n    \n    if (this.neuralModel) {\n      this.neuralModel.dispose();\n    }\n    \n    this.cache.clear();\n    this.removeAllListeners();\n  }\n}\n\n// Export singleton instance\nexport const performanceRegressionDetector = new PerformanceRegressionDetector();"],"names":["PerformanceRegressionDetector","performanceRegressionDetector","StatisticalAnalyzer","tTest","baseline","current","alpha","n1","length","n2","significant","pValue","tStatistic","degreesOfFreedom","mean1","reduce","sum","val","mean2","var1","Math","pow","var2","pooledVar","standardError","sqrt","calculatePValue","abs","detectChangePoints","values","threshold","mean","std","cusum","changePoints","i","max","magnitude","push","timestamp","confidence","min","changeType","classifyChange","metrics","mannKendallTrend","n","trend","slope","significance","s","j","sign","variance","z","slopes","sort","a","b","floor","detectSeasonality","detected","autocorrelations","maxLag","lag","correlation","peaks","value","strongestPeak","peak","period","undefined","amplitude","tStat","df","t","normalCDF","p","x","erf","a1","a2","a3","a4","a5","y","exp","index","before","slice","after","meanBefore","meanAfter","varBefore","varAfter","levelChange","varianceChange","EventEmitter","startMonitoring","intervalMinutes","isMonitoring","monitoringInterval","setInterval","performRegressionCheck","catch","error","console","emit","log","stopMonitoring","clearInterval","analyzeResults","scenarioId","results","baselines","get","alerts","currentMetrics","extractMetrics","metricsToAnalyze","key","responseTime","p95","throughput","errorRate","metric","thresholds","regression","detectRegression","trendAnalysis","analyzeTrends","id","Date","now","severity","degradation","additionalContext","correlatedMetrics","recommendations","neuralModel","anomalyScore","detectAnomalies","alert","sendAlert","setBaseline","options","version","environment","process","env","NODE_ENV","sampleSize","summary","totalRequests","set","saveBaseline","addTrainingData","setThreshold","getBaselines","Array","from","getRegressionAlerts","query","params","start","toISOString","end","stmt","db","prepare","rows","all","map","row","JSON","parse","alert_data","generateRegressionReport","scenarioAlerts","filter","trends","totalAlerts","criticalAlerts","mostAffectedMetrics","getMostAffectedMetrics","overallTrend","generateRecommendations","trainNeuralModel","trainingData","features","d","labels","label","xs","tf","tensor2d","ys","tensor1d","model","sequential","layers","dense","inputShape","units","activation","compile","optimizer","loss","fit","epochs","batchSize","validationSplit","verbose","dispose","recentMetrics","getRecentMetrics","mockResults","scenario","timeline","errors","thresholdResults","metricKey","includes","isRegression","warning","critical","split","getMetricRecommendations","historicalData","getHistoricalData","seasonality","lastValue","forecast","nextValue","upperBound","lowerBound","metricsToFeatures","input","reconstruction","predict","losses","meanSquaredError","errorValue","data","run","stringify","alertingSystem","checkAndCreateAlert","type","AlertType","PERFORMANCE","service","message","toFixed","details","avg","p50","p99","availability","resourceUsage","cpu","memory","io","setupDefaultThresholds","method","minSampleSize","initializeNeuralModel","loadBaselinesFromDatabase","baseline_data","Map","metricCounts","forEach","count","entries","Set","some","add","cleanup","cache","clear","removeAllListeners","LRUCache","ttl"],"mappings":"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"}