15ef8f94bdd1cec8ef20dab68a82d6a5
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get AnomalyDetector () {
        return AnomalyDetector;
    },
    get anomalyDetector () {
        return anomalyDetector;
    }
});
const _tfjsnode = /*#__PURE__*/ _interop_require_wildcard(require("@tensorflow/tfjs-node"));
const _events = require("events");
const _lrucache = require("lru-cache");
const _AnalyticsEngine = require("./AnalyticsEngine");
const _PerformanceMonitor = require("../performance/PerformanceMonitor");
const _EventStore = require("./EventStore");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class AnomalyDetector extends _events.EventEmitter {
    /**
   * Start real-time anomaly detection
   */ startDetection(intervalMs = 30000) {
        if (this.isRunning) {
            console.log('Anomaly detection already running');
            return;
        }
        this.isRunning = true;
        console.log(`Starting anomaly detection with ${intervalMs}ms interval`);
        this.detectionInterval = setInterval(async ()=>{
            try {
                await this.performDetection();
            } catch (error) {
                console.error('Error during anomaly detection:', error);
                this.emit('error', error);
            }
        }, intervalMs);
        // Start performance monitoring if not already running
        this.performanceMonitor.startMonitoring(5000);
        this.emit('detection_started');
    }
    /**
   * Stop anomaly detection
   */ stopDetection() {
        if (!this.isRunning) {
            return;
        }
        this.isRunning = false;
        if (this.detectionInterval) {
            clearInterval(this.detectionInterval);
            this.detectionInterval = null;
        }
        console.log('Anomaly detection stopped');
        this.emit('detection_stopped');
    }
    /**
   * Train autoencoder model for anomaly detection
   */ async trainAutoencoderModel(metrics, trainingDays = 7) {
        console.log(`Training autoencoder model for metrics: ${metrics.join(', ')}`);
        // Collect training data
        const trainingData = await this.collectTrainingData(metrics, trainingDays);
        if (trainingData.length < this.config.minSamples) {
            throw new Error(`Insufficient training data: ${trainingData.length} samples`);
        }
        // Normalize data
        const { normalizedData, normalizationParams } = this.normalizeData(trainingData);
        // Create autoencoder model
        const inputDim = metrics.length;
        const model = this.createAutoencoderModel(inputDim);
        // Prepare training tensors
        const xTrain = _tfjsnode.tensor2d(normalizedData);
        const splitIndex = Math.floor(normalizedData.length * 0.8);
        const xTrainSplit = xTrain.slice([
            0,
            0
        ], [
            splitIndex,
            -1
        ]);
        const xVal = xTrain.slice([
            splitIndex,
            0
        ], [
            -1,
            -1
        ]);
        // Train model
        const history = await model.fit(xTrainSplit, xTrainSplit, {
            epochs: 50,
            batchSize: 32,
            validationData: [
                xVal,
                xVal
            ],
            shuffle: true,
            verbose: 0,
            callbacks: {
                onEpochEnd: (epoch, logs)=>{
                    if (epoch % 10 === 0) {
                        console.log(`Epoch ${epoch}: loss = ${logs?.loss?.toFixed(4)}`);
                    }
                }
            }
        });
        // Calculate reconstruction threshold
        const predictions = model.predict(xVal);
        const reconstructionErrors = await this.calculateReconstructionErrors(xVal, predictions);
        const threshold = this.calculateThreshold(reconstructionErrors);
        // Evaluate model
        const finalLoss = history.history.loss[history.history.loss.length - 1];
        const accuracy = Math.max(0, 1 - finalLoss);
        // Create model object
        const anomalyModel = {
            id: `autoencoder_${metrics.join('_')}_${Date.now()}`,
            name: `Autoencoder Anomaly Detection - ${metrics.join(', ')}`,
            algorithm: 'autoencoder',
            model,
            parameters: {
                threshold,
                normalizationParams,
                reconstructionErrorStats: {
                    mean: reconstructionErrors.reduce((sum, e)=>sum + e, 0) / reconstructionErrors.length,
                    std: this.calculateStandardDeviation(reconstructionErrors)
                }
            },
            trainedAt: new Date(),
            accuracy,
            features: metrics,
            isActive: true
        };
        // Store model
        this.models.set(anomalyModel.id, anomalyModel);
        // Clean up tensors
        xTrain.dispose();
        xTrainSplit.dispose();
        xVal.dispose();
        predictions.dispose();
        console.log(`Autoencoder model trained with accuracy: ${accuracy.toFixed(4)}, threshold: ${threshold.toFixed(4)}`);
        return anomalyModel;
    }
    /**
   * Update statistical thresholds for a metric
   */ async updateStatisticalThresholds(metric, windowDays = 7) {
        console.log(`Updating statistical thresholds for ${metric}`);
        // Get historical data
        const historicalData = await this.getHistoricalData(metric, windowDays);
        if (historicalData.length < this.config.minSamples) {
            throw new Error(`Insufficient data for ${metric}: ${historicalData.length} samples`);
        }
        // Calculate statistics
        const values = historicalData.map((d)=>d.value);
        const mean = values.reduce((sum, v)=>sum + v, 0) / values.length;
        const variance = values.reduce((sum, v)=>sum + Math.pow(v - mean, 2), 0) / values.length;
        const stdDev = Math.sqrt(variance);
        // Set confidence based on sensitivity
        const confidenceMap = {
            low: 2.0,
            medium: 2.5,
            high: 3.0
        };
        const confidence = confidenceMap[this.config.sensitivity];
        const thresholds = {
            metric,
            mean,
            stdDev,
            upperBound: mean + confidence * stdDev,
            lowerBound: mean - confidence * stdDev,
            confidence,
            sampleSize: values.length,
            lastUpdated: new Date()
        };
        this.statisticalThresholds.set(metric, thresholds);
        console.log(`Statistical thresholds updated for ${metric}: [${thresholds.lowerBound.toFixed(2)}, ${thresholds.upperBound.toFixed(2)}]`);
        return thresholds;
    }
    /**
   * Detect anomalies in current data
   */ async detectAnomalies(metrics) {
        const targetMetrics = metrics || Object.keys(this.config.metricWeights);
        const alerts = [];
        // Get current metric values
        const currentData = await this.getCurrentMetricValues(targetMetrics);
        if (Object.keys(currentData).length === 0) {
            return alerts;
        }
        // Run enabled detection algorithms
        for (const algorithm of this.config.enabledAlgorithms){
            try {
                const algorithmAlerts = await this.runDetectionAlgorithm(algorithm, currentData, targetMetrics);
                alerts.push(...algorithmAlerts);
            } catch (error) {
                console.error(`Error running ${algorithm} detection:`, error);
            }
        }
        // Deduplicate and prioritize alerts
        const uniqueAlerts = this.deduplicateAlerts(alerts);
        // Store new alerts
        for (const alert of uniqueAlerts){
            this.alerts.set(alert.id, alert);
            this.alertHistory.push(alert);
            // Emit alert event
            this.emit('anomaly_detected', alert);
            // Auto-acknowledge low severity alerts
            if (alert.severity === 'low') {
                setTimeout(()=>this.acknowledgeAlert(alert.id), 5 * 60 * 1000); // 5 minutes
            }
        }
        return uniqueAlerts;
    }
    /**
   * Acknowledge an alert
   */ acknowledgeAlert(alertId, userId) {
        const alert = this.alerts.get(alertId);
        if (!alert) {
            return false;
        }
        alert.acknowledged = true;
        this.emit('alert_acknowledged', {
            alert,
            userId
        });
        return true;
    }
    /**
   * Resolve an alert
   */ resolveAlert(alertId, userId) {
        const alert = this.alerts.get(alertId);
        if (!alert) {
            return false;
        }
        alert.resolved = true;
        alert.resolvedAt = new Date();
        this.emit('alert_resolved', {
            alert,
            userId
        });
        return true;
    }
    /**
   * Get active alerts
   */ getActiveAlerts() {
        return Array.from(this.alerts.values()).filter((alert)=>!alert.resolved).sort((a, b)=>{
            // Sort by severity then timestamp
            const severityOrder = {
                critical: 4,
                high: 3,
                medium: 2,
                low: 1
            };
            const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
            if (severityDiff !== 0) return severityDiff;
            return b.timestamp.getTime() - a.timestamp.getTime();
        });
    }
    /**
   * Get detection statistics
   */ getDetectionStats() {
        const alerts = Array.from(this.alerts.values());
        const activeAlerts = alerts.filter((a)=>!a.resolved);
        const alertsByseverity = alerts.reduce((acc, alert)=>{
            acc[alert.severity] = (acc[alert.severity] || 0) + 1;
            return acc;
        }, {});
        // Calculate accuracy (simplified - would need labeled data for real accuracy)
        const acknowledgedAlerts = alerts.filter((a)=>a.acknowledged);
        const accuracy = alerts.length > 0 ? acknowledgedAlerts.length / alerts.length : 0;
        // Estimate false positive rate
        const resolvedQuickly = alerts.filter((a)=>a.resolved && a.resolvedAt && a.resolvedAt.getTime() - a.timestamp.getTime() < 300000 // 5 minutes
        );
        const falsePositiveRate = alerts.length > 0 ? resolvedQuickly.length / alerts.length : 0;
        const lastDetection = alerts.length > 0 ? new Date(Math.max(...alerts.map((a)=>a.timestamp.getTime()))) : null;
        return {
            totalAlerts: alerts.length,
            activeAlerts: activeAlerts.length,
            alertsByseverity,
            detectionAccuracy: accuracy,
            falsePositiveRate,
            modelCount: this.models.size,
            lastDetection
        };
    }
    /**
   * Update detection configuration
   */ updateConfig(newConfig) {
        this.config = {
            ...this.config,
            ...newConfig
        };
        console.log('Anomaly detection configuration updated');
        this.emit('config_updated', this.config);
    }
    /**
   * Export detection data
   */ exportData() {
        return {
            config: this.config,
            models: Array.from(this.models.values()).map((m)=>({
                    ...m,
                    model: undefined // Don't export TensorFlow models
                })),
            alerts: this.alertHistory,
            thresholds: Array.from(this.statisticalThresholds.values()),
            stats: this.getDetectionStats()
        };
    }
    // Private methods
    async initializeModels() {
        try {
            // Initialize statistical thresholds for key metrics
            const keyMetrics = Object.keys(this.config.metricWeights);
            for (const metric of keyMetrics){
                try {
                    await this.updateStatisticalThresholds(metric);
                } catch (error) {
                    console.warn(`Failed to initialize thresholds for ${metric}:`, error.message);
                }
            }
            // Train initial autoencoder model if enabled
            if (this.config.enabledAlgorithms.includes('autoencoder')) {
                try {
                    await this.trainAutoencoderModel(keyMetrics);
                } catch (error) {
                    console.warn('Failed to train initial autoencoder model:', error.message);
                }
            }
        } catch (error) {
            console.error('Error initializing anomaly detection models:', error);
        }
    }
    createAutoencoderModel(inputDim) {
        const model = _tfjsnode.sequential({
            layers: [
                // Encoder
                _tfjsnode.layers.dense({
                    inputShape: [
                        inputDim
                    ],
                    units: Math.max(8, Math.floor(inputDim * 0.8)),
                    activation: 'relu',
                    kernelRegularizer: _tfjsnode.regularizers.l2({
                        l2: 0.01
                    })
                }),
                _tfjsnode.layers.dropout({
                    rate: 0.1
                }),
                _tfjsnode.layers.dense({
                    units: Math.max(4, Math.floor(inputDim * 0.5)),
                    activation: 'relu'
                }),
                _tfjsnode.layers.dense({
                    units: Math.max(2, Math.floor(inputDim * 0.3)),
                    activation: 'relu'
                }),
                // Decoder
                _tfjsnode.layers.dense({
                    units: Math.max(4, Math.floor(inputDim * 0.5)),
                    activation: 'relu'
                }),
                _tfjsnode.layers.dense({
                    units: Math.max(8, Math.floor(inputDim * 0.8)),
                    activation: 'relu'
                }),
                _tfjsnode.layers.dense({
                    units: inputDim,
                    activation: 'linear'
                })
            ]
        });
        model.compile({
            optimizer: _tfjsnode.train.adam(0.001),
            loss: 'meanSquaredError'
        });
        return model;
    }
    async performDetection() {
        const alerts = await this.detectAnomalies();
        // Update cache with detection results
        this.cache.set('last_detection', {
            timestamp: new Date(),
            alertCount: alerts.length,
            alerts: alerts.map((a)=>({
                    id: a.id,
                    severity: a.severity,
                    metric: a.metric
                }))
        });
        // Clean up old alerts (keep only last 1000)
        if (this.alertHistory.length > 1000) {
            this.alertHistory = this.alertHistory.slice(-1000);
        }
        // Clean up resolved alerts from active alerts map
        for (const [id, alert] of this.alerts.entries()){
            if (alert.resolved && Date.now() - alert.timestamp.getTime() > 24 * 60 * 60 * 1000) {
                this.alerts.delete(id);
            }
        }
    }
    async runDetectionAlgorithm(algorithm, currentData, metrics) {
        switch(algorithm){
            case 'statistical':
                return this.runStatisticalDetection(currentData, metrics);
            case 'autoencoder':
                return this.runAutoencoderDetection(currentData, metrics);
            case 'ensemble':
                return this.runEnsembleDetection(currentData, metrics);
            default:
                console.warn(`Unknown detection algorithm: ${algorithm}`);
                return [];
        }
    }
    async runStatisticalDetection(currentData, metrics) {
        const alerts = [];
        for (const metric of metrics){
            const value = currentData[metric];
            if (value === undefined) continue;
            const thresholds = this.statisticalThresholds.get(metric);
            if (!thresholds) continue;
            // Check if value is outside thresholds
            if (value > thresholds.upperBound || value < thresholds.lowerBound) {
                const deviation = Math.max(Math.abs(value - thresholds.upperBound), Math.abs(value - thresholds.lowerBound));
                const severity = this.calculateSeverity(deviation, thresholds.stdDev);
                const confidence = Math.min(deviation / thresholds.stdDev, 1.0);
                // Check cooldown period
                if (this.isInCooldown(metric)) continue;
                const alert = {
                    id: `stat_${metric}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
                    timestamp: new Date(),
                    metric,
                    value,
                    expectedRange: {
                        min: thresholds.lowerBound,
                        max: thresholds.upperBound
                    },
                    severity,
                    confidence,
                    description: `${metric} value ${value.toFixed(2)} is outside expected range [${thresholds.lowerBound.toFixed(2)}, ${thresholds.upperBound.toFixed(2)}]`,
                    context: {
                        relatedMetrics: {
                            ...currentData
                        },
                        historicalComparison: await this.getHistoricalComparison(metric),
                        patterns: [
                            'statistical_outlier'
                        ]
                    },
                    recommendations: this.generateRecommendations(metric, value, 'statistical'),
                    acknowledged: false,
                    resolved: false
                };
                alerts.push(alert);
            }
        }
        return alerts;
    }
    async runAutoencoderDetection(currentData, metrics) {
        const alerts = [];
        // Find suitable autoencoder model
        const model = this.findAutoencoderModel(metrics);
        if (!model || !model.model) return alerts;
        try {
            // Prepare input data
            const inputVector = model.features.map((feature)=>currentData[feature] || 0);
            const { normalizedVector } = this.normalizeVector(inputVector, model.parameters.normalizationParams);
            // Get reconstruction
            const inputTensor = _tfjsnode.tensor2d([
                normalizedVector
            ]);
            const reconstruction = model.model.predict(inputTensor);
            const reconstructedVector = await reconstruction.data();
            // Calculate reconstruction error
            const reconstructionError = this.calculateReconstructionError(normalizedVector, Array.from(reconstructedVector));
            // Check against threshold
            const threshold = model.parameters.threshold;
            if (reconstructionError > threshold) {
                // Determine which metrics contributed most to the anomaly
                const contributingMetrics = this.identifyContributingMetrics(normalizedVector, Array.from(reconstructedVector), model.features);
                for (const { metric, contribution } of contributingMetrics){
                    if (contribution > 0.3 && !this.isInCooldown(metric)) {
                        const value = currentData[metric];
                        const severity = this.calculateSeverity(reconstructionError, threshold);
                        const confidence = Math.min(reconstructionError / threshold, 1.0);
                        const alert = {
                            id: `ae_${metric}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
                            timestamp: new Date(),
                            metric,
                            value,
                            expectedRange: {
                                min: 0,
                                max: 0
                            },
                            severity,
                            confidence,
                            description: `Autoencoder detected anomaly in ${metric} (reconstruction error: ${reconstructionError.toFixed(4)})`,
                            context: {
                                relatedMetrics: {
                                    ...currentData
                                },
                                historicalComparison: await this.getHistoricalComparison(metric),
                                patterns: [
                                    'autoencoder_anomaly',
                                    `contribution_${(contribution * 100).toFixed(1)}%`
                                ]
                            },
                            recommendations: this.generateRecommendations(metric, value, 'autoencoder'),
                            acknowledged: false,
                            resolved: false
                        };
                        alerts.push(alert);
                    }
                }
            }
            // Cleanup tensors
            inputTensor.dispose();
            reconstruction.dispose();
        } catch (error) {
            console.error('Error in autoencoder detection:', error);
        }
        return alerts;
    }
    async runEnsembleDetection(currentData, metrics) {
        // Run both statistical and autoencoder detection
        const [statAlerts, aeAlerts] = await Promise.all([
            this.runStatisticalDetection(currentData, metrics),
            this.runAutoencoderDetection(currentData, metrics)
        ]);
        // Combine and weigh results
        const combinedAlerts = [];
        const metricAlerts = new Map();
        // Group alerts by metric
        [
            ...statAlerts,
            ...aeAlerts
        ].forEach((alert)=>{
            if (!metricAlerts.has(alert.metric)) {
                metricAlerts.set(alert.metric, []);
            }
            metricAlerts.get(alert.metric).push(alert);
        });
        // Create ensemble alerts
        for (const [metric, alerts] of metricAlerts.entries()){
            if (alerts.length > 1) {
                // Multiple algorithms detected anomaly - high confidence
                const avgConfidence = alerts.reduce((sum, a)=>sum + a.confidence, 0) / alerts.length;
                const maxSeverity = alerts.reduce((max, a)=>{
                    const severityOrder = {
                        low: 1,
                        medium: 2,
                        high: 3,
                        critical: 4
                    };
                    return severityOrder[a.severity] > severityOrder[max.severity] ? a : max;
                });
                const ensembleAlert = {
                    ...maxSeverity,
                    id: `ensemble_${metric}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,
                    confidence: Math.min(avgConfidence * 1.2, 1.0),
                    description: `Multiple algorithms detected anomaly in ${metric}`,
                    context: {
                        ...maxSeverity.context,
                        patterns: [
                            ...new Set(alerts.flatMap((a)=>a.context.patterns)),
                            'ensemble_detection'
                        ]
                    }
                };
                combinedAlerts.push(ensembleAlert);
            } else {
                // Single algorithm detection
                combinedAlerts.push(alerts[0]);
            }
        }
        return combinedAlerts;
    }
    // Additional helper methods...
    async collectTrainingData(metrics, days) {
        // Implementation to collect training data for specified metrics and time period
        return [];
    }
    normalizeData(data) {
        // Implementation for data normalization
        return {
            normalizedData: data,
            normalizationParams: {}
        };
    }
    normalizeVector(vector, params) {
        // Implementation for vector normalization
        return {
            normalizedVector: vector
        };
    }
    async calculateReconstructionErrors(original, reconstructed) {
        // Implementation for calculating reconstruction errors
        return [];
    }
    calculateThreshold(errors) {
        // Use 95th percentile as threshold
        const sorted = errors.sort((a, b)=>a - b);
        return sorted[Math.floor(sorted.length * 0.95)];
    }
    calculateStandardDeviation(values) {
        const mean = values.reduce((sum, v)=>sum + v, 0) / values.length;
        const variance = values.reduce((sum, v)=>sum + Math.pow(v - mean, 2), 0) / values.length;
        return Math.sqrt(variance);
    }
    async getHistoricalData(metric, days) {
        // Implementation to get historical data for a metric
        return [];
    }
    async getCurrentMetricValues(metrics) {
        // Implementation to get current metric values
        return {};
    }
    calculateSeverity(deviation, reference) {
        const ratio = deviation / reference;
        if (ratio > 3) return 'critical';
        if (ratio > 2) return 'high';
        if (ratio > 1.5) return 'medium';
        return 'low';
    }
    isInCooldown(metric) {
        const recentAlerts = Array.from(this.alerts.values()).filter((alert)=>alert.metric === metric && !alert.resolved && Date.now() - alert.timestamp.getTime() < this.config.cooldownPeriod * 60 * 1000);
        return recentAlerts.length > 0;
    }
    async getHistoricalComparison(metric) {
        // Implementation to get historical comparison data
        return {
            lastHour: 0,
            lastDay: 0,
            lastWeek: 0
        };
    }
    generateRecommendations(metric, value, algorithm) {
        const recommendations = [];
        recommendations.push(`Investigate ${metric} anomaly detected by ${algorithm}`);
        recommendations.push('Check system logs for related events');
        recommendations.push('Monitor related metrics for cascading effects');
        if (metric.includes('cpu') || metric.includes('memory')) {
            recommendations.push('Consider scaling resources if pattern persists');
        }
        if (metric.includes('response_time')) {
            recommendations.push('Check for database query performance issues');
            recommendations.push('Review application bottlenecks');
        }
        return recommendations;
    }
    deduplicateAlerts(alerts) {
        // Remove duplicate alerts for the same metric within a short time window
        const seen = new Set();
        const unique = [];
        for (const alert of alerts.sort((a, b)=>b.confidence - a.confidence)){
            const key = `${alert.metric}_${Math.floor(alert.timestamp.getTime() / (5 * 60 * 1000))}`; // 5-minute windows
            if (!seen.has(key)) {
                seen.add(key);
                unique.push(alert);
            }
        }
        return unique;
    }
    findAutoencoderModel(metrics) {
        const candidates = Array.from(this.models.values()).filter((model)=>model.algorithm === 'autoencoder' && model.isActive && metrics.every((m)=>model.features.includes(m))).sort((a, b)=>b.accuracy - a.accuracy);
        return candidates[0] || null;
    }
    calculateReconstructionError(original, reconstructed) {
        let sumSquaredDiff = 0;
        for(let i = 0; i < original.length; i++){
            sumSquaredDiff += Math.pow(original[i] - reconstructed[i], 2);
        }
        return Math.sqrt(sumSquaredDiff / original.length);
    }
    identifyContributingMetrics(original, reconstructed, features) {
        const contributions = [];
        let totalError = 0;
        const errors = original.map((val, idx)=>{
            const error = Math.abs(val - reconstructed[idx]);
            totalError += error;
            return error;
        });
        features.forEach((feature, idx)=>{
            const contribution = totalError > 0 ? errors[idx] / totalError : 0;
            contributions.push({
                metric: feature,
                contribution
            });
        });
        return contributions.sort((a, b)=>b.contribution - a.contribution);
    }
    constructor(config){
        super(), _define_property(this, "models", void 0), _define_property(this, "alerts", void 0), _define_property(this, "cache", void 0), _define_property(this, "config", void 0), _define_property(this, "statisticalThresholds", void 0), _define_property(this, "isRunning", false), _define_property(this, "detectionInterval", null), _define_property(this, "analyticsEngine", void 0), _define_property(this, "performanceMonitor", void 0), _define_property(this, "eventStore", void 0), _define_property(this, "alertHistory", []);
        this.models = new Map();
        this.alerts = new Map();
        this.statisticalThresholds = new Map();
        this.alertHistory = [];
        this.cache = new _lrucache.LRUCache({
            max: 1000,
            ttl: 1000 * 60 * 5 // 5 minutes
        });
        this.config = {
            sensitivity: 'medium',
            windowSize: 10,
            minSamples: 30,
            alertThreshold: 0.7,
            cooldownPeriod: 15,
            enabledAlgorithms: [
                'autoencoder',
                'statistical'
            ],
            metricWeights: {
                'cpu_usage': 1.0,
                'memory_usage': 1.0,
                'app_response_time': 1.2,
                'app_error_rate': 1.5,
                'app_queue_size': 0.8
            },
            ...config
        };
        this.analyticsEngine = _AnalyticsEngine.AnalyticsEngine.getInstance();
        this.performanceMonitor = new _PerformanceMonitor.PerformanceMonitor();
        this.eventStore = _EventStore.EventStore.getInstance();
        // Initialize default models
        this.initializeModels();
    }
}
const anomalyDetector = new AnomalyDetector();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3Byb21wdC1jYXJkLXN5c3RlbS9iYWNrZW5kL3NyYy9zZXJ2aWNlcy9hbmFseXRpY3MvQW5vbWFseURldGVjdG9yLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRmIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtbm9kZSc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgTFJVQ2FjaGUgfSBmcm9tICdscnUtY2FjaGUnO1xuaW1wb3J0IHsgQW5hbHl0aWNzRW5naW5lIH0gZnJvbSAnLi9BbmFseXRpY3NFbmdpbmUnO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VNb25pdG9yIH0gZnJvbSAnLi4vcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VNb25pdG9yJztcbmltcG9ydCB7IEV2ZW50U3RvcmUgfSBmcm9tICcuL0V2ZW50U3RvcmUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEFub21hbHlNb2RlbCB7XG4gIGlkOiBzdHJpbmc7XG4gIG5hbWU6IHN0cmluZztcbiAgYWxnb3JpdGhtOiAnaXNvbGF0aW9uX2ZvcmVzdCcgfCAnYXV0b2VuY29kZXInIHwgJ3N0YXRpc3RpY2FsJyB8ICdlbnNlbWJsZSc7XG4gIG1vZGVsPzogdGYuTGF5ZXJzTW9kZWw7XG4gIHBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIHRyYWluZWRBdDogRGF0ZTtcbiAgYWNjdXJhY3k6IG51bWJlcjtcbiAgZmVhdHVyZXM6IHN0cmluZ1tdO1xuICBpc0FjdGl2ZTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBBbm9tYWx5QWxlcnQge1xuICBpZDogc3RyaW5nO1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIG1ldHJpYzogc3RyaW5nO1xuICB2YWx1ZTogbnVtYmVyO1xuICBleHBlY3RlZFJhbmdlOiB7IG1pbjogbnVtYmVyOyBtYXg6IG51bWJlciB9O1xuICBzZXZlcml0eTogJ2xvdycgfCAnbWVkaXVtJyB8ICdoaWdoJyB8ICdjcml0aWNhbCc7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgZGVzY3JpcHRpb246IHN0cmluZztcbiAgY29udGV4dDoge1xuICAgIHJlbGF0ZWRNZXRyaWNzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICAgIGhpc3RvcmljYWxDb21wYXJpc29uOiB7XG4gICAgICBsYXN0SG91cjogbnVtYmVyO1xuICAgICAgbGFzdERheTogbnVtYmVyO1xuICAgICAgbGFzdFdlZWs6IG51bWJlcjtcbiAgICB9O1xuICAgIHBhdHRlcm5zOiBzdHJpbmdbXTtcbiAgfTtcbiAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbiAgYWNrbm93bGVkZ2VkOiBib29sZWFuO1xuICByZXNvbHZlZDogYm9vbGVhbjtcbiAgcmVzb2x2ZWRBdD86IERhdGU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGV0ZWN0aW9uQ29uZmlnIHtcbiAgc2Vuc2l0aXZpdHk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCc7XG4gIHdpbmRvd1NpemU6IG51bWJlcjsgLy8gbWludXRlc1xuICBtaW5TYW1wbGVzOiBudW1iZXI7XG4gIGFsZXJ0VGhyZXNob2xkOiBudW1iZXI7XG4gIGNvb2xkb3duUGVyaW9kOiBudW1iZXI7IC8vIG1pbnV0ZXNcbiAgZW5hYmxlZEFsZ29yaXRobXM6IHN0cmluZ1tdO1xuICBtZXRyaWNXZWlnaHRzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFN0YXRpc3RpY2FsVGhyZXNob2xkcyB7XG4gIG1ldHJpYzogc3RyaW5nO1xuICBtZWFuOiBudW1iZXI7XG4gIHN0ZERldjogbnVtYmVyO1xuICB1cHBlckJvdW5kOiBudW1iZXI7XG4gIGxvd2VyQm91bmQ6IG51bWJlcjtcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xuICBzYW1wbGVTaXplOiBudW1iZXI7XG4gIGxhc3RVcGRhdGVkOiBEYXRlO1xufVxuXG5leHBvcnQgY2xhc3MgQW5vbWFseURldGVjdG9yIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgcHJpdmF0ZSBtb2RlbHM6IE1hcDxzdHJpbmcsIEFub21hbHlNb2RlbD47XG4gIHByaXZhdGUgYWxlcnRzOiBNYXA8c3RyaW5nLCBBbm9tYWx5QWxlcnQ+O1xuICBwcml2YXRlIGNhY2hlOiBMUlVDYWNoZTxzdHJpbmcsIGFueT47XG4gIHByaXZhdGUgY29uZmlnOiBEZXRlY3Rpb25Db25maWc7XG4gIHByaXZhdGUgc3RhdGlzdGljYWxUaHJlc2hvbGRzOiBNYXA8c3RyaW5nLCBTdGF0aXN0aWNhbFRocmVzaG9sZHM+O1xuICBwcml2YXRlIGlzUnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGRldGVjdGlvbkludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGFuYWx5dGljc0VuZ2luZTogQW5hbHl0aWNzRW5naW5lO1xuICBwcml2YXRlIHBlcmZvcm1hbmNlTW9uaXRvcjogUGVyZm9ybWFuY2VNb25pdG9yO1xuICBwcml2YXRlIGV2ZW50U3RvcmU6IEV2ZW50U3RvcmU7XG4gIHByaXZhdGUgYWxlcnRIaXN0b3J5OiBBbm9tYWx5QWxlcnRbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZz86IFBhcnRpYWw8RGV0ZWN0aW9uQ29uZmlnPikge1xuICAgIHN1cGVyKCk7XG4gICAgXG4gICAgdGhpcy5tb2RlbHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGVydHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdGF0aXN0aWNhbFRocmVzaG9sZHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbGVydEhpc3RvcnkgPSBbXTtcbiAgICBcbiAgICB0aGlzLmNhY2hlID0gbmV3IExSVUNhY2hlKHtcbiAgICAgIG1heDogMTAwMCxcbiAgICAgIHR0bDogMTAwMCAqIDYwICogNSAvLyA1IG1pbnV0ZXNcbiAgICB9KTtcblxuICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgc2Vuc2l0aXZpdHk6ICdtZWRpdW0nLFxuICAgICAgd2luZG93U2l6ZTogMTAsXG4gICAgICBtaW5TYW1wbGVzOiAzMCxcbiAgICAgIGFsZXJ0VGhyZXNob2xkOiAwLjcsXG4gICAgICBjb29sZG93blBlcmlvZDogMTUsXG4gICAgICBlbmFibGVkQWxnb3JpdGhtczogWydhdXRvZW5jb2RlcicsICdzdGF0aXN0aWNhbCddLFxuICAgICAgbWV0cmljV2VpZ2h0czoge1xuICAgICAgICAnY3B1X3VzYWdlJzogMS4wLFxuICAgICAgICAnbWVtb3J5X3VzYWdlJzogMS4wLFxuICAgICAgICAnYXBwX3Jlc3BvbnNlX3RpbWUnOiAxLjIsXG4gICAgICAgICdhcHBfZXJyb3JfcmF0ZSc6IDEuNSxcbiAgICAgICAgJ2FwcF9xdWV1ZV9zaXplJzogMC44XG4gICAgICB9LFxuICAgICAgLi4uY29uZmlnXG4gICAgfTtcblxuICAgIHRoaXMuYW5hbHl0aWNzRW5naW5lID0gQW5hbHl0aWNzRW5naW5lLmdldEluc3RhbmNlKCk7XG4gICAgdGhpcy5wZXJmb3JtYW5jZU1vbml0b3IgPSBuZXcgUGVyZm9ybWFuY2VNb25pdG9yKCk7XG4gICAgdGhpcy5ldmVudFN0b3JlID0gRXZlbnRTdG9yZS5nZXRJbnN0YW5jZSgpO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBkZWZhdWx0IG1vZGVsc1xuICAgIHRoaXMuaW5pdGlhbGl6ZU1vZGVscygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHJlYWwtdGltZSBhbm9tYWx5IGRldGVjdGlvblxuICAgKi9cbiAgcHVibGljIHN0YXJ0RGV0ZWN0aW9uKGludGVydmFsTXM6IG51bWJlciA9IDMwMDAwKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICBjb25zb2xlLmxvZygnQW5vbWFseSBkZXRlY3Rpb24gYWxyZWFkeSBydW5uaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgIFxuICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBhbm9tYWx5IGRldGVjdGlvbiB3aXRoICR7aW50ZXJ2YWxNc31tcyBpbnRlcnZhbGApO1xuICAgIFxuICAgIHRoaXMuZGV0ZWN0aW9uSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLnBlcmZvcm1EZXRlY3Rpb24oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBhbm9tYWx5IGRldGVjdGlvbjonLCBlcnJvcik7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSwgaW50ZXJ2YWxNcyk7XG5cbiAgICAvLyBTdGFydCBwZXJmb3JtYW5jZSBtb25pdG9yaW5nIGlmIG5vdCBhbHJlYWR5IHJ1bm5pbmdcbiAgICB0aGlzLnBlcmZvcm1hbmNlTW9uaXRvci5zdGFydE1vbml0b3JpbmcoNTAwMCk7XG5cbiAgICB0aGlzLmVtaXQoJ2RldGVjdGlvbl9zdGFydGVkJyk7XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhbm9tYWx5IGRldGVjdGlvblxuICAgKi9cbiAgcHVibGljIHN0b3BEZXRlY3Rpb24oKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmlzUnVubmluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5kZXRlY3Rpb25JbnRlcnZhbCkge1xuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmRldGVjdGlvbkludGVydmFsKTtcbiAgICAgIHRoaXMuZGV0ZWN0aW9uSW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cblxuICAgIGNvbnNvbGUubG9nKCdBbm9tYWx5IGRldGVjdGlvbiBzdG9wcGVkJyk7XG4gICAgdGhpcy5lbWl0KCdkZXRlY3Rpb25fc3RvcHBlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWluIGF1dG9lbmNvZGVyIG1vZGVsIGZvciBhbm9tYWx5IGRldGVjdGlvblxuICAgKi9cbiAgcHVibGljIGFzeW5jIHRyYWluQXV0b2VuY29kZXJNb2RlbChcbiAgICBtZXRyaWNzOiBzdHJpbmdbXSxcbiAgICB0cmFpbmluZ0RheXM6IG51bWJlciA9IDdcbiAgKTogUHJvbWlzZTxBbm9tYWx5TW9kZWw+IHtcbiAgICBjb25zb2xlLmxvZyhgVHJhaW5pbmcgYXV0b2VuY29kZXIgbW9kZWwgZm9yIG1ldHJpY3M6ICR7bWV0cmljcy5qb2luKCcsICcpfWApO1xuXG4gICAgLy8gQ29sbGVjdCB0cmFpbmluZyBkYXRhXG4gICAgY29uc3QgdHJhaW5pbmdEYXRhID0gYXdhaXQgdGhpcy5jb2xsZWN0VHJhaW5pbmdEYXRhKG1ldHJpY3MsIHRyYWluaW5nRGF5cyk7XG4gICAgXG4gICAgaWYgKHRyYWluaW5nRGF0YS5sZW5ndGggPCB0aGlzLmNvbmZpZy5taW5TYW1wbGVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEluc3VmZmljaWVudCB0cmFpbmluZyBkYXRhOiAke3RyYWluaW5nRGF0YS5sZW5ndGh9IHNhbXBsZXNgKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgZGF0YVxuICAgIGNvbnN0IHsgbm9ybWFsaXplZERhdGEsIG5vcm1hbGl6YXRpb25QYXJhbXMgfSA9IHRoaXMubm9ybWFsaXplRGF0YSh0cmFpbmluZ0RhdGEpO1xuXG4gICAgLy8gQ3JlYXRlIGF1dG9lbmNvZGVyIG1vZGVsXG4gICAgY29uc3QgaW5wdXREaW0gPSBtZXRyaWNzLmxlbmd0aDtcbiAgICBjb25zdCBtb2RlbCA9IHRoaXMuY3JlYXRlQXV0b2VuY29kZXJNb2RlbChpbnB1dERpbSk7XG5cbiAgICAvLyBQcmVwYXJlIHRyYWluaW5nIHRlbnNvcnNcbiAgICBjb25zdCB4VHJhaW4gPSB0Zi50ZW5zb3IyZChub3JtYWxpemVkRGF0YSk7XG4gICAgY29uc3Qgc3BsaXRJbmRleCA9IE1hdGguZmxvb3Iobm9ybWFsaXplZERhdGEubGVuZ3RoICogMC44KTtcbiAgICBjb25zdCB4VHJhaW5TcGxpdCA9IHhUcmFpbi5zbGljZShbMCwgMF0sIFtzcGxpdEluZGV4LCAtMV0pO1xuICAgIGNvbnN0IHhWYWwgPSB4VHJhaW4uc2xpY2UoW3NwbGl0SW5kZXgsIDBdLCBbLTEsIC0xXSk7XG5cbiAgICAvLyBUcmFpbiBtb2RlbFxuICAgIGNvbnN0IGhpc3RvcnkgPSBhd2FpdCBtb2RlbC5maXQoeFRyYWluU3BsaXQsIHhUcmFpblNwbGl0LCB7XG4gICAgICBlcG9jaHM6IDUwLFxuICAgICAgYmF0Y2hTaXplOiAzMixcbiAgICAgIHZhbGlkYXRpb25EYXRhOiBbeFZhbCwgeFZhbF0sXG4gICAgICBzaHVmZmxlOiB0cnVlLFxuICAgICAgdmVyYm9zZTogMCxcbiAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICBvbkVwb2NoRW5kOiAoZXBvY2gsIGxvZ3MpID0+IHtcbiAgICAgICAgICBpZiAoZXBvY2ggJSAxMCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYEVwb2NoICR7ZXBvY2h9OiBsb3NzID0gJHtsb2dzPy5sb3NzPy50b0ZpeGVkKDQpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHJlY29uc3RydWN0aW9uIHRocmVzaG9sZFxuICAgIGNvbnN0IHByZWRpY3Rpb25zID0gbW9kZWwucHJlZGljdCh4VmFsKSBhcyB0Zi5UZW5zb3I7XG4gICAgY29uc3QgcmVjb25zdHJ1Y3Rpb25FcnJvcnMgPSBhd2FpdCB0aGlzLmNhbGN1bGF0ZVJlY29uc3RydWN0aW9uRXJyb3JzKHhWYWwsIHByZWRpY3Rpb25zKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLmNhbGN1bGF0ZVRocmVzaG9sZChyZWNvbnN0cnVjdGlvbkVycm9ycyk7XG5cbiAgICAvLyBFdmFsdWF0ZSBtb2RlbFxuICAgIGNvbnN0IGZpbmFsTG9zcyA9IGhpc3RvcnkuaGlzdG9yeS5sb3NzW2hpc3RvcnkuaGlzdG9yeS5sb3NzLmxlbmd0aCAtIDFdIGFzIG51bWJlcjtcbiAgICBjb25zdCBhY2N1cmFjeSA9IE1hdGgubWF4KDAsIDEgLSBmaW5hbExvc3MpO1xuXG4gICAgLy8gQ3JlYXRlIG1vZGVsIG9iamVjdFxuICAgIGNvbnN0IGFub21hbHlNb2RlbDogQW5vbWFseU1vZGVsID0ge1xuICAgICAgaWQ6IGBhdXRvZW5jb2Rlcl8ke21ldHJpY3Muam9pbignXycpfV8ke0RhdGUubm93KCl9YCxcbiAgICAgIG5hbWU6IGBBdXRvZW5jb2RlciBBbm9tYWx5IERldGVjdGlvbiAtICR7bWV0cmljcy5qb2luKCcsICcpfWAsXG4gICAgICBhbGdvcml0aG06ICdhdXRvZW5jb2RlcicsXG4gICAgICBtb2RlbCxcbiAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgdGhyZXNob2xkLFxuICAgICAgICBub3JtYWxpemF0aW9uUGFyYW1zLFxuICAgICAgICByZWNvbnN0cnVjdGlvbkVycm9yU3RhdHM6IHtcbiAgICAgICAgICBtZWFuOiByZWNvbnN0cnVjdGlvbkVycm9ycy5yZWR1Y2UoKHN1bSwgZSkgPT4gc3VtICsgZSwgMCkgLyByZWNvbnN0cnVjdGlvbkVycm9ycy5sZW5ndGgsXG4gICAgICAgICAgc3RkOiB0aGlzLmNhbGN1bGF0ZVN0YW5kYXJkRGV2aWF0aW9uKHJlY29uc3RydWN0aW9uRXJyb3JzKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdHJhaW5lZEF0OiBuZXcgRGF0ZSgpLFxuICAgICAgYWNjdXJhY3ksXG4gICAgICBmZWF0dXJlczogbWV0cmljcyxcbiAgICAgIGlzQWN0aXZlOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIFN0b3JlIG1vZGVsXG4gICAgdGhpcy5tb2RlbHMuc2V0KGFub21hbHlNb2RlbC5pZCwgYW5vbWFseU1vZGVsKTtcblxuICAgIC8vIENsZWFuIHVwIHRlbnNvcnNcbiAgICB4VHJhaW4uZGlzcG9zZSgpO1xuICAgIHhUcmFpblNwbGl0LmRpc3Bvc2UoKTtcbiAgICB4VmFsLmRpc3Bvc2UoKTtcbiAgICBwcmVkaWN0aW9ucy5kaXNwb3NlKCk7XG5cbiAgICBjb25zb2xlLmxvZyhgQXV0b2VuY29kZXIgbW9kZWwgdHJhaW5lZCB3aXRoIGFjY3VyYWN5OiAke2FjY3VyYWN5LnRvRml4ZWQoNCl9LCB0aHJlc2hvbGQ6ICR7dGhyZXNob2xkLnRvRml4ZWQoNCl9YCk7XG4gICAgXG4gICAgcmV0dXJuIGFub21hbHlNb2RlbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgc3RhdGlzdGljYWwgdGhyZXNob2xkcyBmb3IgYSBtZXRyaWNcbiAgICovXG4gIHB1YmxpYyBhc3luYyB1cGRhdGVTdGF0aXN0aWNhbFRocmVzaG9sZHMoXG4gICAgbWV0cmljOiBzdHJpbmcsXG4gICAgd2luZG93RGF5czogbnVtYmVyID0gN1xuICApOiBQcm9taXNlPFN0YXRpc3RpY2FsVGhyZXNob2xkcz4ge1xuICAgIGNvbnNvbGUubG9nKGBVcGRhdGluZyBzdGF0aXN0aWNhbCB0aHJlc2hvbGRzIGZvciAke21ldHJpY31gKTtcblxuICAgIC8vIEdldCBoaXN0b3JpY2FsIGRhdGFcbiAgICBjb25zdCBoaXN0b3JpY2FsRGF0YSA9IGF3YWl0IHRoaXMuZ2V0SGlzdG9yaWNhbERhdGEobWV0cmljLCB3aW5kb3dEYXlzKTtcbiAgICBcbiAgICBpZiAoaGlzdG9yaWNhbERhdGEubGVuZ3RoIDwgdGhpcy5jb25maWcubWluU2FtcGxlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnN1ZmZpY2llbnQgZGF0YSBmb3IgJHttZXRyaWN9OiAke2hpc3RvcmljYWxEYXRhLmxlbmd0aH0gc2FtcGxlc2ApO1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSBzdGF0aXN0aWNzXG4gICAgY29uc3QgdmFsdWVzID0gaGlzdG9yaWNhbERhdGEubWFwKGQgPT4gZC52YWx1ZSk7XG4gICAgY29uc3QgbWVhbiA9IHZhbHVlcy5yZWR1Y2UoKHN1bSwgdikgPT4gc3VtICsgdiwgMCkgLyB2YWx1ZXMubGVuZ3RoO1xuICAgIGNvbnN0IHZhcmlhbmNlID0gdmFsdWVzLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyBNYXRoLnBvdyh2IC0gbWVhbiwgMiksIDApIC8gdmFsdWVzLmxlbmd0aDtcbiAgICBjb25zdCBzdGREZXYgPSBNYXRoLnNxcnQodmFyaWFuY2UpO1xuXG4gICAgLy8gU2V0IGNvbmZpZGVuY2UgYmFzZWQgb24gc2Vuc2l0aXZpdHlcbiAgICBjb25zdCBjb25maWRlbmNlTWFwID0geyBsb3c6IDIuMCwgbWVkaXVtOiAyLjUsIGhpZ2g6IDMuMCB9O1xuICAgIGNvbnN0IGNvbmZpZGVuY2UgPSBjb25maWRlbmNlTWFwW3RoaXMuY29uZmlnLnNlbnNpdGl2aXR5XTtcblxuICAgIGNvbnN0IHRocmVzaG9sZHM6IFN0YXRpc3RpY2FsVGhyZXNob2xkcyA9IHtcbiAgICAgIG1ldHJpYyxcbiAgICAgIG1lYW4sXG4gICAgICBzdGREZXYsXG4gICAgICB1cHBlckJvdW5kOiBtZWFuICsgKGNvbmZpZGVuY2UgKiBzdGREZXYpLFxuICAgICAgbG93ZXJCb3VuZDogbWVhbiAtIChjb25maWRlbmNlICogc3RkRGV2KSxcbiAgICAgIGNvbmZpZGVuY2UsXG4gICAgICBzYW1wbGVTaXplOiB2YWx1ZXMubGVuZ3RoLFxuICAgICAgbGFzdFVwZGF0ZWQ6IG5ldyBEYXRlKClcbiAgICB9O1xuXG4gICAgdGhpcy5zdGF0aXN0aWNhbFRocmVzaG9sZHMuc2V0KG1ldHJpYywgdGhyZXNob2xkcyk7XG5cbiAgICBjb25zb2xlLmxvZyhgU3RhdGlzdGljYWwgdGhyZXNob2xkcyB1cGRhdGVkIGZvciAke21ldHJpY306IFske3RocmVzaG9sZHMubG93ZXJCb3VuZC50b0ZpeGVkKDIpfSwgJHt0aHJlc2hvbGRzLnVwcGVyQm91bmQudG9GaXhlZCgyKX1dYCk7XG4gICAgXG4gICAgcmV0dXJuIHRocmVzaG9sZHM7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGFub21hbGllcyBpbiBjdXJyZW50IGRhdGFcbiAgICovXG4gIHB1YmxpYyBhc3luYyBkZXRlY3RBbm9tYWxpZXMobWV0cmljcz86IHN0cmluZ1tdKTogUHJvbWlzZTxBbm9tYWx5QWxlcnRbXT4ge1xuICAgIGNvbnN0IHRhcmdldE1ldHJpY3MgPSBtZXRyaWNzIHx8IE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLm1ldHJpY1dlaWdodHMpO1xuICAgIGNvbnN0IGFsZXJ0czogQW5vbWFseUFsZXJ0W10gPSBbXTtcblxuICAgIC8vIEdldCBjdXJyZW50IG1ldHJpYyB2YWx1ZXNcbiAgICBjb25zdCBjdXJyZW50RGF0YSA9IGF3YWl0IHRoaXMuZ2V0Q3VycmVudE1ldHJpY1ZhbHVlcyh0YXJnZXRNZXRyaWNzKTtcbiAgICBcbiAgICBpZiAoT2JqZWN0LmtleXMoY3VycmVudERhdGEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGFsZXJ0cztcbiAgICB9XG5cbiAgICAvLyBSdW4gZW5hYmxlZCBkZXRlY3Rpb24gYWxnb3JpdGhtc1xuICAgIGZvciAoY29uc3QgYWxnb3JpdGhtIG9mIHRoaXMuY29uZmlnLmVuYWJsZWRBbGdvcml0aG1zKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBhbGdvcml0aG1BbGVydHMgPSBhd2FpdCB0aGlzLnJ1bkRldGVjdGlvbkFsZ29yaXRobShcbiAgICAgICAgICBhbGdvcml0aG0sXG4gICAgICAgICAgY3VycmVudERhdGEsXG4gICAgICAgICAgdGFyZ2V0TWV0cmljc1xuICAgICAgICApO1xuICAgICAgICBhbGVydHMucHVzaCguLi5hbGdvcml0aG1BbGVydHMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcnVubmluZyAke2FsZ29yaXRobX0gZGV0ZWN0aW9uOmAsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEZWR1cGxpY2F0ZSBhbmQgcHJpb3JpdGl6ZSBhbGVydHNcbiAgICBjb25zdCB1bmlxdWVBbGVydHMgPSB0aGlzLmRlZHVwbGljYXRlQWxlcnRzKGFsZXJ0cyk7XG5cbiAgICAvLyBTdG9yZSBuZXcgYWxlcnRzXG4gICAgZm9yIChjb25zdCBhbGVydCBvZiB1bmlxdWVBbGVydHMpIHtcbiAgICAgIHRoaXMuYWxlcnRzLnNldChhbGVydC5pZCwgYWxlcnQpO1xuICAgICAgdGhpcy5hbGVydEhpc3RvcnkucHVzaChhbGVydCk7XG4gICAgICBcbiAgICAgIC8vIEVtaXQgYWxlcnQgZXZlbnRcbiAgICAgIHRoaXMuZW1pdCgnYW5vbWFseV9kZXRlY3RlZCcsIGFsZXJ0KTtcbiAgICAgIFxuICAgICAgLy8gQXV0by1hY2tub3dsZWRnZSBsb3cgc2V2ZXJpdHkgYWxlcnRzXG4gICAgICBpZiAoYWxlcnQuc2V2ZXJpdHkgPT09ICdsb3cnKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2tub3dsZWRnZUFsZXJ0KGFsZXJ0LmlkKSwgNSAqIDYwICogMTAwMCk7IC8vIDUgbWludXRlc1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVBbGVydHM7XG4gIH1cblxuICAvKipcbiAgICogQWNrbm93bGVkZ2UgYW4gYWxlcnRcbiAgICovXG4gIHB1YmxpYyBhY2tub3dsZWRnZUFsZXJ0KGFsZXJ0SWQ6IHN0cmluZywgdXNlcklkPzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgYWxlcnQgPSB0aGlzLmFsZXJ0cy5nZXQoYWxlcnRJZCk7XG4gICAgaWYgKCFhbGVydCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGFsZXJ0LmFja25vd2xlZGdlZCA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdhbGVydF9hY2tub3dsZWRnZWQnLCB7IGFsZXJ0LCB1c2VySWQgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSBhbiBhbGVydFxuICAgKi9cbiAgcHVibGljIHJlc29sdmVBbGVydChhbGVydElkOiBzdHJpbmcsIHVzZXJJZD86IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGFsZXJ0ID0gdGhpcy5hbGVydHMuZ2V0KGFsZXJ0SWQpO1xuICAgIGlmICghYWxlcnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBhbGVydC5yZXNvbHZlZCA9IHRydWU7XG4gICAgYWxlcnQucmVzb2x2ZWRBdCA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5lbWl0KCdhbGVydF9yZXNvbHZlZCcsIHsgYWxlcnQsIHVzZXJJZCB9KTtcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYWN0aXZlIGFsZXJ0c1xuICAgKi9cbiAgcHVibGljIGdldEFjdGl2ZUFsZXJ0cygpOiBBbm9tYWx5QWxlcnRbXSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5hbGVydHMudmFsdWVzKCkpXG4gICAgICAuZmlsdGVyKGFsZXJ0ID0+ICFhbGVydC5yZXNvbHZlZClcbiAgICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIC8vIFNvcnQgYnkgc2V2ZXJpdHkgdGhlbiB0aW1lc3RhbXBcbiAgICAgICAgY29uc3Qgc2V2ZXJpdHlPcmRlciA9IHsgY3JpdGljYWw6IDQsIGhpZ2g6IDMsIG1lZGl1bTogMiwgbG93OiAxIH07XG4gICAgICAgIGNvbnN0IHNldmVyaXR5RGlmZiA9IHNldmVyaXR5T3JkZXJbYi5zZXZlcml0eV0gLSBzZXZlcml0eU9yZGVyW2Euc2V2ZXJpdHldO1xuICAgICAgICBpZiAoc2V2ZXJpdHlEaWZmICE9PSAwKSByZXR1cm4gc2V2ZXJpdHlEaWZmO1xuICAgICAgICByZXR1cm4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpO1xuICAgICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRldGVjdGlvbiBzdGF0aXN0aWNzXG4gICAqL1xuICBwdWJsaWMgZ2V0RGV0ZWN0aW9uU3RhdHMoKToge1xuICAgIHRvdGFsQWxlcnRzOiBudW1iZXI7XG4gICAgYWN0aXZlQWxlcnRzOiBudW1iZXI7XG4gICAgYWxlcnRzQnlzZXZlcml0eTogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbiAgICBkZXRlY3Rpb25BY2N1cmFjeTogbnVtYmVyO1xuICAgIGZhbHNlUG9zaXRpdmVSYXRlOiBudW1iZXI7XG4gICAgbW9kZWxDb3VudDogbnVtYmVyO1xuICAgIGxhc3REZXRlY3Rpb246IERhdGUgfCBudWxsO1xuICB9IHtcbiAgICBjb25zdCBhbGVydHMgPSBBcnJheS5mcm9tKHRoaXMuYWxlcnRzLnZhbHVlcygpKTtcbiAgICBjb25zdCBhY3RpdmVBbGVydHMgPSBhbGVydHMuZmlsdGVyKGEgPT4gIWEucmVzb2x2ZWQpO1xuICAgIFxuICAgIGNvbnN0IGFsZXJ0c0J5c2V2ZXJpdHkgPSBhbGVydHMucmVkdWNlKChhY2MsIGFsZXJ0KSA9PiB7XG4gICAgICBhY2NbYWxlcnQuc2V2ZXJpdHldID0gKGFjY1thbGVydC5zZXZlcml0eV0gfHwgMCkgKyAxO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+KTtcblxuICAgIC8vIENhbGN1bGF0ZSBhY2N1cmFjeSAoc2ltcGxpZmllZCAtIHdvdWxkIG5lZWQgbGFiZWxlZCBkYXRhIGZvciByZWFsIGFjY3VyYWN5KVxuICAgIGNvbnN0IGFja25vd2xlZGdlZEFsZXJ0cyA9IGFsZXJ0cy5maWx0ZXIoYSA9PiBhLmFja25vd2xlZGdlZCk7XG4gICAgY29uc3QgYWNjdXJhY3kgPSBhbGVydHMubGVuZ3RoID4gMCA/IGFja25vd2xlZGdlZEFsZXJ0cy5sZW5ndGggLyBhbGVydHMubGVuZ3RoIDogMDtcblxuICAgIC8vIEVzdGltYXRlIGZhbHNlIHBvc2l0aXZlIHJhdGVcbiAgICBjb25zdCByZXNvbHZlZFF1aWNrbHkgPSBhbGVydHMuZmlsdGVyKGEgPT4gXG4gICAgICBhLnJlc29sdmVkICYmIGEucmVzb2x2ZWRBdCAmJiBcbiAgICAgIChhLnJlc29sdmVkQXQuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpKSA8IDMwMDAwMCAvLyA1IG1pbnV0ZXNcbiAgICApO1xuICAgIGNvbnN0IGZhbHNlUG9zaXRpdmVSYXRlID0gYWxlcnRzLmxlbmd0aCA+IDAgPyByZXNvbHZlZFF1aWNrbHkubGVuZ3RoIC8gYWxlcnRzLmxlbmd0aCA6IDA7XG5cbiAgICBjb25zdCBsYXN0RGV0ZWN0aW9uID0gYWxlcnRzLmxlbmd0aCA+IDAgXG4gICAgICA/IG5ldyBEYXRlKE1hdGgubWF4KC4uLmFsZXJ0cy5tYXAoYSA9PiBhLnRpbWVzdGFtcC5nZXRUaW1lKCkpKSlcbiAgICAgIDogbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbEFsZXJ0czogYWxlcnRzLmxlbmd0aCxcbiAgICAgIGFjdGl2ZUFsZXJ0czogYWN0aXZlQWxlcnRzLmxlbmd0aCxcbiAgICAgIGFsZXJ0c0J5c2V2ZXJpdHksXG4gICAgICBkZXRlY3Rpb25BY2N1cmFjeTogYWNjdXJhY3ksXG4gICAgICBmYWxzZVBvc2l0aXZlUmF0ZSxcbiAgICAgIG1vZGVsQ291bnQ6IHRoaXMubW9kZWxzLnNpemUsXG4gICAgICBsYXN0RGV0ZWN0aW9uXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgZGV0ZWN0aW9uIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVDb25maWcobmV3Q29uZmlnOiBQYXJ0aWFsPERldGVjdGlvbkNvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLm5ld0NvbmZpZyB9O1xuICAgIGNvbnNvbGUubG9nKCdBbm9tYWx5IGRldGVjdGlvbiBjb25maWd1cmF0aW9uIHVwZGF0ZWQnKTtcbiAgICB0aGlzLmVtaXQoJ2NvbmZpZ191cGRhdGVkJywgdGhpcy5jb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydCBkZXRlY3Rpb24gZGF0YVxuICAgKi9cbiAgcHVibGljIGV4cG9ydERhdGEoKToge1xuICAgIGNvbmZpZzogRGV0ZWN0aW9uQ29uZmlnO1xuICAgIG1vZGVsczogYW55W107XG4gICAgYWxlcnRzOiBBbm9tYWx5QWxlcnRbXTtcbiAgICB0aHJlc2hvbGRzOiBTdGF0aXN0aWNhbFRocmVzaG9sZHNbXTtcbiAgICBzdGF0czogYW55O1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIG1vZGVsczogQXJyYXkuZnJvbSh0aGlzLm1vZGVscy52YWx1ZXMoKSkubWFwKG0gPT4gKHtcbiAgICAgICAgLi4ubSxcbiAgICAgICAgbW9kZWw6IHVuZGVmaW5lZCAvLyBEb24ndCBleHBvcnQgVGVuc29yRmxvdyBtb2RlbHNcbiAgICAgIH0pKSxcbiAgICAgIGFsZXJ0czogdGhpcy5hbGVydEhpc3RvcnksXG4gICAgICB0aHJlc2hvbGRzOiBBcnJheS5mcm9tKHRoaXMuc3RhdGlzdGljYWxUaHJlc2hvbGRzLnZhbHVlcygpKSxcbiAgICAgIHN0YXRzOiB0aGlzLmdldERldGVjdGlvblN0YXRzKClcbiAgICB9O1xuICB9XG5cbiAgLy8gUHJpdmF0ZSBtZXRob2RzXG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplTW9kZWxzKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBJbml0aWFsaXplIHN0YXRpc3RpY2FsIHRocmVzaG9sZHMgZm9yIGtleSBtZXRyaWNzXG4gICAgICBjb25zdCBrZXlNZXRyaWNzID0gT2JqZWN0LmtleXModGhpcy5jb25maWcubWV0cmljV2VpZ2h0cyk7XG4gICAgICBcbiAgICAgIGZvciAoY29uc3QgbWV0cmljIG9mIGtleU1ldHJpY3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZVN0YXRpc3RpY2FsVGhyZXNob2xkcyhtZXRyaWMpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGluaXRpYWxpemUgdGhyZXNob2xkcyBmb3IgJHttZXRyaWN9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYWluIGluaXRpYWwgYXV0b2VuY29kZXIgbW9kZWwgaWYgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZWRBbGdvcml0aG1zLmluY2x1ZGVzKCdhdXRvZW5jb2RlcicpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy50cmFpbkF1dG9lbmNvZGVyTW9kZWwoa2V5TWV0cmljcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdGYWlsZWQgdG8gdHJhaW4gaW5pdGlhbCBhdXRvZW5jb2RlciBtb2RlbDonLCBlcnJvci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBhbm9tYWx5IGRldGVjdGlvbiBtb2RlbHM6JywgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY3JlYXRlQXV0b2VuY29kZXJNb2RlbChpbnB1dERpbTogbnVtYmVyKTogdGYuTGF5ZXJzTW9kZWwge1xuICAgIGNvbnN0IG1vZGVsID0gdGYuc2VxdWVudGlhbCh7XG4gICAgICBsYXllcnM6IFtcbiAgICAgICAgLy8gRW5jb2RlclxuICAgICAgICB0Zi5sYXllcnMuZGVuc2Uoe1xuICAgICAgICAgIGlucHV0U2hhcGU6IFtpbnB1dERpbV0sXG4gICAgICAgICAgdW5pdHM6IE1hdGgubWF4KDgsIE1hdGguZmxvb3IoaW5wdXREaW0gKiAwLjgpKSxcbiAgICAgICAgICBhY3RpdmF0aW9uOiAncmVsdScsXG4gICAgICAgICAga2VybmVsUmVndWxhcml6ZXI6IHRmLnJlZ3VsYXJpemVycy5sMih7IGwyOiAwLjAxIH0pXG4gICAgICAgIH0pLFxuICAgICAgICB0Zi5sYXllcnMuZHJvcG91dCh7IHJhdGU6IDAuMSB9KSxcbiAgICAgICAgdGYubGF5ZXJzLmRlbnNlKHtcbiAgICAgICAgICB1bml0czogTWF0aC5tYXgoNCwgTWF0aC5mbG9vcihpbnB1dERpbSAqIDAuNSkpLFxuICAgICAgICAgIGFjdGl2YXRpb246ICdyZWx1J1xuICAgICAgICB9KSxcbiAgICAgICAgdGYubGF5ZXJzLmRlbnNlKHtcbiAgICAgICAgICB1bml0czogTWF0aC5tYXgoMiwgTWF0aC5mbG9vcihpbnB1dERpbSAqIDAuMykpLFxuICAgICAgICAgIGFjdGl2YXRpb246ICdyZWx1J1xuICAgICAgICB9KSxcbiAgICAgICAgLy8gRGVjb2RlclxuICAgICAgICB0Zi5sYXllcnMuZGVuc2Uoe1xuICAgICAgICAgIHVuaXRzOiBNYXRoLm1heCg0LCBNYXRoLmZsb29yKGlucHV0RGltICogMC41KSksXG4gICAgICAgICAgYWN0aXZhdGlvbjogJ3JlbHUnXG4gICAgICAgIH0pLFxuICAgICAgICB0Zi5sYXllcnMuZGVuc2Uoe1xuICAgICAgICAgIHVuaXRzOiBNYXRoLm1heCg4LCBNYXRoLmZsb29yKGlucHV0RGltICogMC44KSksXG4gICAgICAgICAgYWN0aXZhdGlvbjogJ3JlbHUnXG4gICAgICAgIH0pLFxuICAgICAgICB0Zi5sYXllcnMuZGVuc2Uoe1xuICAgICAgICAgIHVuaXRzOiBpbnB1dERpbSxcbiAgICAgICAgICBhY3RpdmF0aW9uOiAnbGluZWFyJ1xuICAgICAgICB9KVxuICAgICAgXVxuICAgIH0pO1xuXG4gICAgbW9kZWwuY29tcGlsZSh7XG4gICAgICBvcHRpbWl6ZXI6IHRmLnRyYWluLmFkYW0oMC4wMDEpLFxuICAgICAgbG9zczogJ21lYW5TcXVhcmVkRXJyb3InXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBlcmZvcm1EZXRlY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgYWxlcnRzID0gYXdhaXQgdGhpcy5kZXRlY3RBbm9tYWxpZXMoKTtcbiAgICBcbiAgICAvLyBVcGRhdGUgY2FjaGUgd2l0aCBkZXRlY3Rpb24gcmVzdWx0c1xuICAgIHRoaXMuY2FjaGUuc2V0KCdsYXN0X2RldGVjdGlvbicsIHtcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIGFsZXJ0Q291bnQ6IGFsZXJ0cy5sZW5ndGgsXG4gICAgICBhbGVydHM6IGFsZXJ0cy5tYXAoYSA9PiAoeyBpZDogYS5pZCwgc2V2ZXJpdHk6IGEuc2V2ZXJpdHksIG1ldHJpYzogYS5tZXRyaWMgfSkpXG4gICAgfSk7XG5cbiAgICAvLyBDbGVhbiB1cCBvbGQgYWxlcnRzIChrZWVwIG9ubHkgbGFzdCAxMDAwKVxuICAgIGlmICh0aGlzLmFsZXJ0SGlzdG9yeS5sZW5ndGggPiAxMDAwKSB7XG4gICAgICB0aGlzLmFsZXJ0SGlzdG9yeSA9IHRoaXMuYWxlcnRIaXN0b3J5LnNsaWNlKC0xMDAwKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbiB1cCByZXNvbHZlZCBhbGVydHMgZnJvbSBhY3RpdmUgYWxlcnRzIG1hcFxuICAgIGZvciAoY29uc3QgW2lkLCBhbGVydF0gb2YgdGhpcy5hbGVydHMuZW50cmllcygpKSB7XG4gICAgICBpZiAoYWxlcnQucmVzb2x2ZWQgJiYgXG4gICAgICAgICAgKERhdGUubm93KCkgLSBhbGVydC50aW1lc3RhbXAuZ2V0VGltZSgpKSA+IDI0ICogNjAgKiA2MCAqIDEwMDApIHsgLy8gMjQgaG91cnNcbiAgICAgICAgdGhpcy5hbGVydHMuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJ1bkRldGVjdGlvbkFsZ29yaXRobShcbiAgICBhbGdvcml0aG06IHN0cmluZyxcbiAgICBjdXJyZW50RGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBtZXRyaWNzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPEFub21hbHlBbGVydFtdPiB7XG4gICAgc3dpdGNoIChhbGdvcml0aG0pIHtcbiAgICAgIGNhc2UgJ3N0YXRpc3RpY2FsJzpcbiAgICAgICAgcmV0dXJuIHRoaXMucnVuU3RhdGlzdGljYWxEZXRlY3Rpb24oY3VycmVudERhdGEsIG1ldHJpY3MpO1xuICAgICAgY2FzZSAnYXV0b2VuY29kZXInOlxuICAgICAgICByZXR1cm4gdGhpcy5ydW5BdXRvZW5jb2RlckRldGVjdGlvbihjdXJyZW50RGF0YSwgbWV0cmljcyk7XG4gICAgICBjYXNlICdlbnNlbWJsZSc6XG4gICAgICAgIHJldHVybiB0aGlzLnJ1bkVuc2VtYmxlRGV0ZWN0aW9uKGN1cnJlbnREYXRhLCBtZXRyaWNzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihgVW5rbm93biBkZXRlY3Rpb24gYWxnb3JpdGhtOiAke2FsZ29yaXRobX1gKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcnVuU3RhdGlzdGljYWxEZXRlY3Rpb24oXG4gICAgY3VycmVudERhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgbWV0cmljczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxBbm9tYWx5QWxlcnRbXT4ge1xuICAgIGNvbnN0IGFsZXJ0czogQW5vbWFseUFsZXJ0W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbWV0cmljIG9mIG1ldHJpY3MpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gY3VycmVudERhdGFbbWV0cmljXTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb250aW51ZTtcblxuICAgICAgY29uc3QgdGhyZXNob2xkcyA9IHRoaXMuc3RhdGlzdGljYWxUaHJlc2hvbGRzLmdldChtZXRyaWMpO1xuICAgICAgaWYgKCF0aHJlc2hvbGRzKSBjb250aW51ZTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgb3V0c2lkZSB0aHJlc2hvbGRzXG4gICAgICBpZiAodmFsdWUgPiB0aHJlc2hvbGRzLnVwcGVyQm91bmQgfHwgdmFsdWUgPCB0aHJlc2hvbGRzLmxvd2VyQm91bmQpIHtcbiAgICAgICAgY29uc3QgZGV2aWF0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgICAgTWF0aC5hYnModmFsdWUgLSB0aHJlc2hvbGRzLnVwcGVyQm91bmQpLFxuICAgICAgICAgIE1hdGguYWJzKHZhbHVlIC0gdGhyZXNob2xkcy5sb3dlckJvdW5kKVxuICAgICAgICApO1xuICAgICAgICBcbiAgICAgICAgY29uc3Qgc2V2ZXJpdHkgPSB0aGlzLmNhbGN1bGF0ZVNldmVyaXR5KGRldmlhdGlvbiwgdGhyZXNob2xkcy5zdGREZXYpO1xuICAgICAgICBjb25zdCBjb25maWRlbmNlID0gTWF0aC5taW4oZGV2aWF0aW9uIC8gdGhyZXNob2xkcy5zdGREZXYsIDEuMCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgY29vbGRvd24gcGVyaW9kXG4gICAgICAgIGlmICh0aGlzLmlzSW5Db29sZG93bihtZXRyaWMpKSBjb250aW51ZTtcblxuICAgICAgICBjb25zdCBhbGVydDogQW5vbWFseUFsZXJ0ID0ge1xuICAgICAgICAgIGlkOiBgc3RhdF8ke21ldHJpY31fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA2KX1gLFxuICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgICAgICBtZXRyaWMsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgZXhwZWN0ZWRSYW5nZToge1xuICAgICAgICAgICAgbWluOiB0aHJlc2hvbGRzLmxvd2VyQm91bmQsXG4gICAgICAgICAgICBtYXg6IHRocmVzaG9sZHMudXBwZXJCb3VuZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V2ZXJpdHksXG4gICAgICAgICAgY29uZmlkZW5jZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7bWV0cmljfSB2YWx1ZSAke3ZhbHVlLnRvRml4ZWQoMil9IGlzIG91dHNpZGUgZXhwZWN0ZWQgcmFuZ2UgWyR7dGhyZXNob2xkcy5sb3dlckJvdW5kLnRvRml4ZWQoMil9LCAke3RocmVzaG9sZHMudXBwZXJCb3VuZC50b0ZpeGVkKDIpfV1gLFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIHJlbGF0ZWRNZXRyaWNzOiB7IC4uLmN1cnJlbnREYXRhIH0sXG4gICAgICAgICAgICBoaXN0b3JpY2FsQ29tcGFyaXNvbjogYXdhaXQgdGhpcy5nZXRIaXN0b3JpY2FsQ29tcGFyaXNvbihtZXRyaWMpLFxuICAgICAgICAgICAgcGF0dGVybnM6IFsnc3RhdGlzdGljYWxfb3V0bGllciddXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZWNvbW1lbmRhdGlvbnM6IHRoaXMuZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMobWV0cmljLCB2YWx1ZSwgJ3N0YXRpc3RpY2FsJyksXG4gICAgICAgICAgYWNrbm93bGVkZ2VkOiBmYWxzZSxcbiAgICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBhbGVydHMucHVzaChhbGVydCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFsZXJ0cztcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcnVuQXV0b2VuY29kZXJEZXRlY3Rpb24oXG4gICAgY3VycmVudERhdGE6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4sXG4gICAgbWV0cmljczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTxBbm9tYWx5QWxlcnRbXT4ge1xuICAgIGNvbnN0IGFsZXJ0czogQW5vbWFseUFsZXJ0W10gPSBbXTtcblxuICAgIC8vIEZpbmQgc3VpdGFibGUgYXV0b2VuY29kZXIgbW9kZWxcbiAgICBjb25zdCBtb2RlbCA9IHRoaXMuZmluZEF1dG9lbmNvZGVyTW9kZWwobWV0cmljcyk7XG4gICAgaWYgKCFtb2RlbCB8fCAhbW9kZWwubW9kZWwpIHJldHVybiBhbGVydHM7XG5cbiAgICB0cnkge1xuICAgICAgLy8gUHJlcGFyZSBpbnB1dCBkYXRhXG4gICAgICBjb25zdCBpbnB1dFZlY3RvciA9IG1vZGVsLmZlYXR1cmVzLm1hcChmZWF0dXJlID0+IGN1cnJlbnREYXRhW2ZlYXR1cmVdIHx8IDApO1xuICAgICAgY29uc3QgeyBub3JtYWxpemVkVmVjdG9yIH0gPSB0aGlzLm5vcm1hbGl6ZVZlY3RvcihpbnB1dFZlY3RvciwgbW9kZWwucGFyYW1ldGVycy5ub3JtYWxpemF0aW9uUGFyYW1zKTtcblxuICAgICAgLy8gR2V0IHJlY29uc3RydWN0aW9uXG4gICAgICBjb25zdCBpbnB1dFRlbnNvciA9IHRmLnRlbnNvcjJkKFtub3JtYWxpemVkVmVjdG9yXSk7XG4gICAgICBjb25zdCByZWNvbnN0cnVjdGlvbiA9IG1vZGVsLm1vZGVsLnByZWRpY3QoaW5wdXRUZW5zb3IpIGFzIHRmLlRlbnNvcjtcbiAgICAgIGNvbnN0IHJlY29uc3RydWN0ZWRWZWN0b3IgPSBhd2FpdCByZWNvbnN0cnVjdGlvbi5kYXRhKCk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSByZWNvbnN0cnVjdGlvbiBlcnJvclxuICAgICAgY29uc3QgcmVjb25zdHJ1Y3Rpb25FcnJvciA9IHRoaXMuY2FsY3VsYXRlUmVjb25zdHJ1Y3Rpb25FcnJvcihcbiAgICAgICAgbm9ybWFsaXplZFZlY3RvcixcbiAgICAgICAgQXJyYXkuZnJvbShyZWNvbnN0cnVjdGVkVmVjdG9yKVxuICAgICAgKTtcblxuICAgICAgLy8gQ2hlY2sgYWdhaW5zdCB0aHJlc2hvbGRcbiAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG1vZGVsLnBhcmFtZXRlcnMudGhyZXNob2xkO1xuICAgICAgXG4gICAgICBpZiAocmVjb25zdHJ1Y3Rpb25FcnJvciA+IHRocmVzaG9sZCkge1xuICAgICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggbWV0cmljcyBjb250cmlidXRlZCBtb3N0IHRvIHRoZSBhbm9tYWx5XG4gICAgICAgIGNvbnN0IGNvbnRyaWJ1dGluZ01ldHJpY3MgPSB0aGlzLmlkZW50aWZ5Q29udHJpYnV0aW5nTWV0cmljcyhcbiAgICAgICAgICBub3JtYWxpemVkVmVjdG9yLFxuICAgICAgICAgIEFycmF5LmZyb20ocmVjb25zdHJ1Y3RlZFZlY3RvciksXG4gICAgICAgICAgbW9kZWwuZmVhdHVyZXNcbiAgICAgICAgKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHsgbWV0cmljLCBjb250cmlidXRpb24gfSBvZiBjb250cmlidXRpbmdNZXRyaWNzKSB7XG4gICAgICAgICAgaWYgKGNvbnRyaWJ1dGlvbiA+IDAuMyAmJiAhdGhpcy5pc0luQ29vbGRvd24obWV0cmljKSkgeyAvLyAzMCUgY29udHJpYnV0aW9uIHRocmVzaG9sZFxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdXJyZW50RGF0YVttZXRyaWNdO1xuICAgICAgICAgICAgY29uc3Qgc2V2ZXJpdHkgPSB0aGlzLmNhbGN1bGF0ZVNldmVyaXR5KHJlY29uc3RydWN0aW9uRXJyb3IsIHRocmVzaG9sZCk7XG4gICAgICAgICAgICBjb25zdCBjb25maWRlbmNlID0gTWF0aC5taW4ocmVjb25zdHJ1Y3Rpb25FcnJvciAvIHRocmVzaG9sZCwgMS4wKTtcblxuICAgICAgICAgICAgY29uc3QgYWxlcnQ6IEFub21hbHlBbGVydCA9IHtcbiAgICAgICAgICAgICAgaWQ6IGBhZV8ke21ldHJpY31fJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA2KX1gLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgIG1ldHJpYyxcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIGV4cGVjdGVkUmFuZ2U6IHsgbWluOiAwLCBtYXg6IDAgfSwgLy8gQXV0b2VuY29kZXIgZG9lc24ndCBwcm92aWRlIGV4cGxpY2l0IHJhbmdlc1xuICAgICAgICAgICAgICBzZXZlcml0eSxcbiAgICAgICAgICAgICAgY29uZmlkZW5jZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGBBdXRvZW5jb2RlciBkZXRlY3RlZCBhbm9tYWx5IGluICR7bWV0cmljfSAocmVjb25zdHJ1Y3Rpb24gZXJyb3I6ICR7cmVjb25zdHJ1Y3Rpb25FcnJvci50b0ZpeGVkKDQpfSlgLFxuICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgcmVsYXRlZE1ldHJpY3M6IHsgLi4uY3VycmVudERhdGEgfSxcbiAgICAgICAgICAgICAgICBoaXN0b3JpY2FsQ29tcGFyaXNvbjogYXdhaXQgdGhpcy5nZXRIaXN0b3JpY2FsQ29tcGFyaXNvbihtZXRyaWMpLFxuICAgICAgICAgICAgICAgIHBhdHRlcm5zOiBbJ2F1dG9lbmNvZGVyX2Fub21hbHknLCBgY29udHJpYnV0aW9uXyR7KGNvbnRyaWJ1dGlvbiAqIDEwMCkudG9GaXhlZCgxKX0lYF1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVjb21tZW5kYXRpb25zOiB0aGlzLmdlbmVyYXRlUmVjb21tZW5kYXRpb25zKG1ldHJpYywgdmFsdWUsICdhdXRvZW5jb2RlcicpLFxuICAgICAgICAgICAgICBhY2tub3dsZWRnZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICByZXNvbHZlZDogZmFsc2VcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFsZXJ0cy5wdXNoKGFsZXJ0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2xlYW51cCB0ZW5zb3JzXG4gICAgICBpbnB1dFRlbnNvci5kaXNwb3NlKCk7XG4gICAgICByZWNvbnN0cnVjdGlvbi5kaXNwb3NlKCk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gYXV0b2VuY29kZXIgZGV0ZWN0aW9uOicsIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWxlcnRzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBydW5FbnNlbWJsZURldGVjdGlvbihcbiAgICBjdXJyZW50RGF0YTogUmVjb3JkPHN0cmluZywgbnVtYmVyPixcbiAgICBtZXRyaWNzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPEFub21hbHlBbGVydFtdPiB7XG4gICAgLy8gUnVuIGJvdGggc3RhdGlzdGljYWwgYW5kIGF1dG9lbmNvZGVyIGRldGVjdGlvblxuICAgIGNvbnN0IFtzdGF0QWxlcnRzLCBhZUFsZXJ0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLnJ1blN0YXRpc3RpY2FsRGV0ZWN0aW9uKGN1cnJlbnREYXRhLCBtZXRyaWNzKSxcbiAgICAgIHRoaXMucnVuQXV0b2VuY29kZXJEZXRlY3Rpb24oY3VycmVudERhdGEsIG1ldHJpY3MpXG4gICAgXSk7XG5cbiAgICAvLyBDb21iaW5lIGFuZCB3ZWlnaCByZXN1bHRzXG4gICAgY29uc3QgY29tYmluZWRBbGVydHM6IEFub21hbHlBbGVydFtdID0gW107XG4gICAgY29uc3QgbWV0cmljQWxlcnRzID0gbmV3IE1hcDxzdHJpbmcsIEFub21hbHlBbGVydFtdPigpO1xuXG4gICAgLy8gR3JvdXAgYWxlcnRzIGJ5IG1ldHJpY1xuICAgIFsuLi5zdGF0QWxlcnRzLCAuLi5hZUFsZXJ0c10uZm9yRWFjaChhbGVydCA9PiB7XG4gICAgICBpZiAoIW1ldHJpY0FsZXJ0cy5oYXMoYWxlcnQubWV0cmljKSkge1xuICAgICAgICBtZXRyaWNBbGVydHMuc2V0KGFsZXJ0Lm1ldHJpYywgW10pO1xuICAgICAgfVxuICAgICAgbWV0cmljQWxlcnRzLmdldChhbGVydC5tZXRyaWMpIS5wdXNoKGFsZXJ0KTtcbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBlbnNlbWJsZSBhbGVydHNcbiAgICBmb3IgKGNvbnN0IFttZXRyaWMsIGFsZXJ0c10gb2YgbWV0cmljQWxlcnRzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGFsZXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIE11bHRpcGxlIGFsZ29yaXRobXMgZGV0ZWN0ZWQgYW5vbWFseSAtIGhpZ2ggY29uZmlkZW5jZVxuICAgICAgICBjb25zdCBhdmdDb25maWRlbmNlID0gYWxlcnRzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmNvbmZpZGVuY2UsIDApIC8gYWxlcnRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbWF4U2V2ZXJpdHkgPSBhbGVydHMucmVkdWNlKChtYXgsIGEpID0+IHtcbiAgICAgICAgICBjb25zdCBzZXZlcml0eU9yZGVyID0geyBsb3c6IDEsIG1lZGl1bTogMiwgaGlnaDogMywgY3JpdGljYWw6IDQgfTtcbiAgICAgICAgICByZXR1cm4gc2V2ZXJpdHlPcmRlclthLnNldmVyaXR5XSA+IHNldmVyaXR5T3JkZXJbbWF4LnNldmVyaXR5XSA/IGEgOiBtYXg7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGVuc2VtYmxlQWxlcnQ6IEFub21hbHlBbGVydCA9IHtcbiAgICAgICAgICAuLi5tYXhTZXZlcml0eSxcbiAgICAgICAgICBpZDogYGVuc2VtYmxlXyR7bWV0cmljfV8ke0RhdGUubm93KCl9XyR7TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDYpfWAsXG4gICAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oYXZnQ29uZmlkZW5jZSAqIDEuMiwgMS4wKSwgLy8gQm9vc3QgY29uZmlkZW5jZSBmb3IgZW5zZW1ibGVcbiAgICAgICAgICBkZXNjcmlwdGlvbjogYE11bHRpcGxlIGFsZ29yaXRobXMgZGV0ZWN0ZWQgYW5vbWFseSBpbiAke21ldHJpY31gLFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIC4uLm1heFNldmVyaXR5LmNvbnRleHQsXG4gICAgICAgICAgICBwYXR0ZXJuczogWy4uLm5ldyBTZXQoYWxlcnRzLmZsYXRNYXAoYSA9PiBhLmNvbnRleHQucGF0dGVybnMpKSwgJ2Vuc2VtYmxlX2RldGVjdGlvbiddXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbWJpbmVkQWxlcnRzLnB1c2goZW5zZW1ibGVBbGVydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTaW5nbGUgYWxnb3JpdGhtIGRldGVjdGlvblxuICAgICAgICBjb21iaW5lZEFsZXJ0cy5wdXNoKGFsZXJ0c1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbWJpbmVkQWxlcnRzO1xuICB9XG5cbiAgLy8gQWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kcy4uLlxuXG4gIHByaXZhdGUgYXN5bmMgY29sbGVjdFRyYWluaW5nRGF0YShtZXRyaWNzOiBzdHJpbmdbXSwgZGF5czogbnVtYmVyKTogUHJvbWlzZTxudW1iZXJbXVtdPiB7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gdG8gY29sbGVjdCB0cmFpbmluZyBkYXRhIGZvciBzcGVjaWZpZWQgbWV0cmljcyBhbmQgdGltZSBwZXJpb2RcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZURhdGEoZGF0YTogbnVtYmVyW11bXSk6IHsgbm9ybWFsaXplZERhdGE6IG51bWJlcltdW107IG5vcm1hbGl6YXRpb25QYXJhbXM6IGFueSB9IHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBmb3IgZGF0YSBub3JtYWxpemF0aW9uXG4gICAgcmV0dXJuIHsgbm9ybWFsaXplZERhdGE6IGRhdGEsIG5vcm1hbGl6YXRpb25QYXJhbXM6IHt9IH07XG4gIH1cblxuICBwcml2YXRlIG5vcm1hbGl6ZVZlY3Rvcih2ZWN0b3I6IG51bWJlcltdLCBwYXJhbXM6IGFueSk6IHsgbm9ybWFsaXplZFZlY3RvcjogbnVtYmVyW10gfSB7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gZm9yIHZlY3RvciBub3JtYWxpemF0aW9uXG4gICAgcmV0dXJuIHsgbm9ybWFsaXplZFZlY3RvcjogdmVjdG9yIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGNhbGN1bGF0ZVJlY29uc3RydWN0aW9uRXJyb3JzKG9yaWdpbmFsOiB0Zi5UZW5zb3IsIHJlY29uc3RydWN0ZWQ6IHRmLlRlbnNvcik6IFByb21pc2U8bnVtYmVyW10+IHtcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBmb3IgY2FsY3VsYXRpbmcgcmVjb25zdHJ1Y3Rpb24gZXJyb3JzXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVUaHJlc2hvbGQoZXJyb3JzOiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgLy8gVXNlIDk1dGggcGVyY2VudGlsZSBhcyB0aHJlc2hvbGRcbiAgICBjb25zdCBzb3J0ZWQgPSBlcnJvcnMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHJldHVybiBzb3J0ZWRbTWF0aC5mbG9vcihzb3J0ZWQubGVuZ3RoICogMC45NSldO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVTdGFuZGFyZERldmlhdGlvbih2YWx1ZXM6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBjb25zdCBtZWFuID0gdmFsdWVzLnJlZHVjZSgoc3VtLCB2KSA9PiBzdW0gKyB2LCAwKSAvIHZhbHVlcy5sZW5ndGg7XG4gICAgY29uc3QgdmFyaWFuY2UgPSB2YWx1ZXMucmVkdWNlKChzdW0sIHYpID0+IHN1bSArIE1hdGgucG93KHYgLSBtZWFuLCAyKSwgMCkgLyB2YWx1ZXMubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLnNxcnQodmFyaWFuY2UpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRIaXN0b3JpY2FsRGF0YShtZXRyaWM6IHN0cmluZywgZGF5czogbnVtYmVyKTogUHJvbWlzZTxhbnlbXT4ge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHRvIGdldCBoaXN0b3JpY2FsIGRhdGEgZm9yIGEgbWV0cmljXG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRDdXJyZW50TWV0cmljVmFsdWVzKG1ldHJpY3M6IHN0cmluZ1tdKTogUHJvbWlzZTxSZWNvcmQ8c3RyaW5nLCBudW1iZXI+PiB7XG4gICAgLy8gSW1wbGVtZW50YXRpb24gdG8gZ2V0IGN1cnJlbnQgbWV0cmljIHZhbHVlc1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlU2V2ZXJpdHkoZGV2aWF0aW9uOiBudW1iZXIsIHJlZmVyZW5jZTogbnVtYmVyKTogQW5vbWFseUFsZXJ0WydzZXZlcml0eSddIHtcbiAgICBjb25zdCByYXRpbyA9IGRldmlhdGlvbiAvIHJlZmVyZW5jZTtcbiAgICBpZiAocmF0aW8gPiAzKSByZXR1cm4gJ2NyaXRpY2FsJztcbiAgICBpZiAocmF0aW8gPiAyKSByZXR1cm4gJ2hpZ2gnO1xuICAgIGlmIChyYXRpbyA+IDEuNSkgcmV0dXJuICdtZWRpdW0nO1xuICAgIHJldHVybiAnbG93JztcbiAgfVxuXG4gIHByaXZhdGUgaXNJbkNvb2xkb3duKG1ldHJpYzogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgcmVjZW50QWxlcnRzID0gQXJyYXkuZnJvbSh0aGlzLmFsZXJ0cy52YWx1ZXMoKSlcbiAgICAgIC5maWx0ZXIoYWxlcnQgPT4gXG4gICAgICAgIGFsZXJ0Lm1ldHJpYyA9PT0gbWV0cmljICYmIFxuICAgICAgICAhYWxlcnQucmVzb2x2ZWQgJiZcbiAgICAgICAgKERhdGUubm93KCkgLSBhbGVydC50aW1lc3RhbXAuZ2V0VGltZSgpKSA8ICh0aGlzLmNvbmZpZy5jb29sZG93blBlcmlvZCAqIDYwICogMTAwMClcbiAgICAgICk7XG4gICAgcmV0dXJuIHJlY2VudEFsZXJ0cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZXRIaXN0b3JpY2FsQ29tcGFyaXNvbihtZXRyaWM6IHN0cmluZyk6IFByb21pc2U8eyBsYXN0SG91cjogbnVtYmVyOyBsYXN0RGF5OiBudW1iZXI7IGxhc3RXZWVrOiBudW1iZXIgfT4ge1xuICAgIC8vIEltcGxlbWVudGF0aW9uIHRvIGdldCBoaXN0b3JpY2FsIGNvbXBhcmlzb24gZGF0YVxuICAgIHJldHVybiB7IGxhc3RIb3VyOiAwLCBsYXN0RGF5OiAwLCBsYXN0V2VlazogMCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyhtZXRyaWM6IHN0cmluZywgdmFsdWU6IG51bWJlciwgYWxnb3JpdGhtOiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKGBJbnZlc3RpZ2F0ZSAke21ldHJpY30gYW5vbWFseSBkZXRlY3RlZCBieSAke2FsZ29yaXRobX1gKTtcbiAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnQ2hlY2sgc3lzdGVtIGxvZ3MgZm9yIHJlbGF0ZWQgZXZlbnRzJyk7XG4gICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ01vbml0b3IgcmVsYXRlZCBtZXRyaWNzIGZvciBjYXNjYWRpbmcgZWZmZWN0cycpO1xuICAgIFxuICAgIGlmIChtZXRyaWMuaW5jbHVkZXMoJ2NwdScpIHx8IG1ldHJpYy5pbmNsdWRlcygnbWVtb3J5JykpIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdDb25zaWRlciBzY2FsaW5nIHJlc291cmNlcyBpZiBwYXR0ZXJuIHBlcnNpc3RzJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChtZXRyaWMuaW5jbHVkZXMoJ3Jlc3BvbnNlX3RpbWUnKSkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0NoZWNrIGZvciBkYXRhYmFzZSBxdWVyeSBwZXJmb3JtYW5jZSBpc3N1ZXMnKTtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdSZXZpZXcgYXBwbGljYXRpb24gYm90dGxlbmVja3MnKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgZGVkdXBsaWNhdGVBbGVydHMoYWxlcnRzOiBBbm9tYWx5QWxlcnRbXSk6IEFub21hbHlBbGVydFtdIHtcbiAgICAvLyBSZW1vdmUgZHVwbGljYXRlIGFsZXJ0cyBmb3IgdGhlIHNhbWUgbWV0cmljIHdpdGhpbiBhIHNob3J0IHRpbWUgd2luZG93XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgIGNvbnN0IHVuaXF1ZTogQW5vbWFseUFsZXJ0W10gPSBbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGFsZXJ0IG9mIGFsZXJ0cy5zb3J0KChhLCBiKSA9PiBiLmNvbmZpZGVuY2UgLSBhLmNvbmZpZGVuY2UpKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHthbGVydC5tZXRyaWN9XyR7TWF0aC5mbG9vcihhbGVydC50aW1lc3RhbXAuZ2V0VGltZSgpIC8gKDUgKiA2MCAqIDEwMDApKX1gOyAvLyA1LW1pbnV0ZSB3aW5kb3dzXG4gICAgICBpZiAoIXNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlLnB1c2goYWxlcnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gdW5pcXVlO1xuICB9XG5cbiAgcHJpdmF0ZSBmaW5kQXV0b2VuY29kZXJNb2RlbChtZXRyaWNzOiBzdHJpbmdbXSk6IEFub21hbHlNb2RlbCB8IG51bGwge1xuICAgIGNvbnN0IGNhbmRpZGF0ZXMgPSBBcnJheS5mcm9tKHRoaXMubW9kZWxzLnZhbHVlcygpKVxuICAgICAgLmZpbHRlcihtb2RlbCA9PiBcbiAgICAgICAgbW9kZWwuYWxnb3JpdGhtID09PSAnYXV0b2VuY29kZXInICYmIFxuICAgICAgICBtb2RlbC5pc0FjdGl2ZSAmJlxuICAgICAgICBtZXRyaWNzLmV2ZXJ5KG0gPT4gbW9kZWwuZmVhdHVyZXMuaW5jbHVkZXMobSkpXG4gICAgICApXG4gICAgICAuc29ydCgoYSwgYikgPT4gYi5hY2N1cmFjeSAtIGEuYWNjdXJhY3kpO1xuXG4gICAgcmV0dXJuIGNhbmRpZGF0ZXNbMF0gfHwgbnVsbDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlUmVjb25zdHJ1Y3Rpb25FcnJvcihvcmlnaW5hbDogbnVtYmVyW10sIHJlY29uc3RydWN0ZWQ6IG51bWJlcltdKTogbnVtYmVyIHtcbiAgICBsZXQgc3VtU3F1YXJlZERpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3JpZ2luYWwubGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bVNxdWFyZWREaWZmICs9IE1hdGgucG93KG9yaWdpbmFsW2ldIC0gcmVjb25zdHJ1Y3RlZFtpXSwgMik7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnNxcnQoc3VtU3F1YXJlZERpZmYgLyBvcmlnaW5hbC5sZW5ndGgpO1xuICB9XG5cbiAgcHJpdmF0ZSBpZGVudGlmeUNvbnRyaWJ1dGluZ01ldHJpY3MoXG4gICAgb3JpZ2luYWw6IG51bWJlcltdLFxuICAgIHJlY29uc3RydWN0ZWQ6IG51bWJlcltdLFxuICAgIGZlYXR1cmVzOiBzdHJpbmdbXVxuICApOiBBcnJheTx7IG1ldHJpYzogc3RyaW5nOyBjb250cmlidXRpb246IG51bWJlciB9PiB7XG4gICAgY29uc3QgY29udHJpYnV0aW9uczogQXJyYXk8eyBtZXRyaWM6IHN0cmluZzsgY29udHJpYnV0aW9uOiBudW1iZXIgfT4gPSBbXTtcbiAgICBcbiAgICBsZXQgdG90YWxFcnJvciA9IDA7XG4gICAgY29uc3QgZXJyb3JzID0gb3JpZ2luYWwubWFwKCh2YWwsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBNYXRoLmFicyh2YWwgLSByZWNvbnN0cnVjdGVkW2lkeF0pO1xuICAgICAgdG90YWxFcnJvciArPSBlcnJvcjtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9KTtcblxuICAgIGZlYXR1cmVzLmZvckVhY2goKGZlYXR1cmUsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY29udHJpYnV0aW9uID0gdG90YWxFcnJvciA+IDAgPyBlcnJvcnNbaWR4XSAvIHRvdGFsRXJyb3IgOiAwO1xuICAgICAgY29udHJpYnV0aW9ucy5wdXNoKHsgbWV0cmljOiBmZWF0dXJlLCBjb250cmlidXRpb24gfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29udHJpYnV0aW9ucy5zb3J0KChhLCBiKSA9PiBiLmNvbnRyaWJ1dGlvbiAtIGEuY29udHJpYnV0aW9uKTtcbiAgfVxufVxuXG4vLyBFeHBvcnQgc2luZ2xldG9uIGluc3RhbmNlXG5leHBvcnQgY29uc3QgYW5vbWFseURldGVjdG9yID0gbmV3IEFub21hbHlEZXRlY3RvcigpOyJdLCJuYW1lcyI6WyJBbm9tYWx5RGV0ZWN0b3IiLCJhbm9tYWx5RGV0ZWN0b3IiLCJFdmVudEVtaXR0ZXIiLCJzdGFydERldGVjdGlvbiIsImludGVydmFsTXMiLCJpc1J1bm5pbmciLCJjb25zb2xlIiwibG9nIiwiZGV0ZWN0aW9uSW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsInBlcmZvcm1EZXRlY3Rpb24iLCJlcnJvciIsImVtaXQiLCJwZXJmb3JtYW5jZU1vbml0b3IiLCJzdGFydE1vbml0b3JpbmciLCJzdG9wRGV0ZWN0aW9uIiwiY2xlYXJJbnRlcnZhbCIsInRyYWluQXV0b2VuY29kZXJNb2RlbCIsIm1ldHJpY3MiLCJ0cmFpbmluZ0RheXMiLCJqb2luIiwidHJhaW5pbmdEYXRhIiwiY29sbGVjdFRyYWluaW5nRGF0YSIsImxlbmd0aCIsImNvbmZpZyIsIm1pblNhbXBsZXMiLCJFcnJvciIsIm5vcm1hbGl6ZWREYXRhIiwibm9ybWFsaXphdGlvblBhcmFtcyIsIm5vcm1hbGl6ZURhdGEiLCJpbnB1dERpbSIsIm1vZGVsIiwiY3JlYXRlQXV0b2VuY29kZXJNb2RlbCIsInhUcmFpbiIsInRmIiwidGVuc29yMmQiLCJzcGxpdEluZGV4IiwiTWF0aCIsImZsb29yIiwieFRyYWluU3BsaXQiLCJzbGljZSIsInhWYWwiLCJoaXN0b3J5IiwiZml0IiwiZXBvY2hzIiwiYmF0Y2hTaXplIiwidmFsaWRhdGlvbkRhdGEiLCJzaHVmZmxlIiwidmVyYm9zZSIsImNhbGxiYWNrcyIsIm9uRXBvY2hFbmQiLCJlcG9jaCIsImxvZ3MiLCJsb3NzIiwidG9GaXhlZCIsInByZWRpY3Rpb25zIiwicHJlZGljdCIsInJlY29uc3RydWN0aW9uRXJyb3JzIiwiY2FsY3VsYXRlUmVjb25zdHJ1Y3Rpb25FcnJvcnMiLCJ0aHJlc2hvbGQiLCJjYWxjdWxhdGVUaHJlc2hvbGQiLCJmaW5hbExvc3MiLCJhY2N1cmFjeSIsIm1heCIsImFub21hbHlNb2RlbCIsImlkIiwiRGF0ZSIsIm5vdyIsIm5hbWUiLCJhbGdvcml0aG0iLCJwYXJhbWV0ZXJzIiwicmVjb25zdHJ1Y3Rpb25FcnJvclN0YXRzIiwibWVhbiIsInJlZHVjZSIsInN1bSIsImUiLCJzdGQiLCJjYWxjdWxhdGVTdGFuZGFyZERldmlhdGlvbiIsInRyYWluZWRBdCIsImZlYXR1cmVzIiwiaXNBY3RpdmUiLCJtb2RlbHMiLCJzZXQiLCJkaXNwb3NlIiwidXBkYXRlU3RhdGlzdGljYWxUaHJlc2hvbGRzIiwibWV0cmljIiwid2luZG93RGF5cyIsImhpc3RvcmljYWxEYXRhIiwiZ2V0SGlzdG9yaWNhbERhdGEiLCJ2YWx1ZXMiLCJtYXAiLCJkIiwidmFsdWUiLCJ2IiwidmFyaWFuY2UiLCJwb3ciLCJzdGREZXYiLCJzcXJ0IiwiY29uZmlkZW5jZU1hcCIsImxvdyIsIm1lZGl1bSIsImhpZ2giLCJjb25maWRlbmNlIiwic2Vuc2l0aXZpdHkiLCJ0aHJlc2hvbGRzIiwidXBwZXJCb3VuZCIsImxvd2VyQm91bmQiLCJzYW1wbGVTaXplIiwibGFzdFVwZGF0ZWQiLCJzdGF0aXN0aWNhbFRocmVzaG9sZHMiLCJkZXRlY3RBbm9tYWxpZXMiLCJ0YXJnZXRNZXRyaWNzIiwiT2JqZWN0Iiwia2V5cyIsIm1ldHJpY1dlaWdodHMiLCJhbGVydHMiLCJjdXJyZW50RGF0YSIsImdldEN1cnJlbnRNZXRyaWNWYWx1ZXMiLCJlbmFibGVkQWxnb3JpdGhtcyIsImFsZ29yaXRobUFsZXJ0cyIsInJ1bkRldGVjdGlvbkFsZ29yaXRobSIsInB1c2giLCJ1bmlxdWVBbGVydHMiLCJkZWR1cGxpY2F0ZUFsZXJ0cyIsImFsZXJ0IiwiYWxlcnRIaXN0b3J5Iiwic2V2ZXJpdHkiLCJzZXRUaW1lb3V0IiwiYWNrbm93bGVkZ2VBbGVydCIsImFsZXJ0SWQiLCJ1c2VySWQiLCJnZXQiLCJhY2tub3dsZWRnZWQiLCJyZXNvbHZlQWxlcnQiLCJyZXNvbHZlZCIsInJlc29sdmVkQXQiLCJnZXRBY3RpdmVBbGVydHMiLCJBcnJheSIsImZyb20iLCJmaWx0ZXIiLCJzb3J0IiwiYSIsImIiLCJzZXZlcml0eU9yZGVyIiwiY3JpdGljYWwiLCJzZXZlcml0eURpZmYiLCJ0aW1lc3RhbXAiLCJnZXRUaW1lIiwiZ2V0RGV0ZWN0aW9uU3RhdHMiLCJhY3RpdmVBbGVydHMiLCJhbGVydHNCeXNldmVyaXR5IiwiYWNjIiwiYWNrbm93bGVkZ2VkQWxlcnRzIiwicmVzb2x2ZWRRdWlja2x5IiwiZmFsc2VQb3NpdGl2ZVJhdGUiLCJsYXN0RGV0ZWN0aW9uIiwidG90YWxBbGVydHMiLCJkZXRlY3Rpb25BY2N1cmFjeSIsIm1vZGVsQ291bnQiLCJzaXplIiwidXBkYXRlQ29uZmlnIiwibmV3Q29uZmlnIiwiZXhwb3J0RGF0YSIsIm0iLCJ1bmRlZmluZWQiLCJzdGF0cyIsImluaXRpYWxpemVNb2RlbHMiLCJrZXlNZXRyaWNzIiwid2FybiIsIm1lc3NhZ2UiLCJpbmNsdWRlcyIsInNlcXVlbnRpYWwiLCJsYXllcnMiLCJkZW5zZSIsImlucHV0U2hhcGUiLCJ1bml0cyIsImFjdGl2YXRpb24iLCJrZXJuZWxSZWd1bGFyaXplciIsInJlZ3VsYXJpemVycyIsImwyIiwiZHJvcG91dCIsInJhdGUiLCJjb21waWxlIiwib3B0aW1pemVyIiwidHJhaW4iLCJhZGFtIiwiY2FjaGUiLCJhbGVydENvdW50IiwiZW50cmllcyIsImRlbGV0ZSIsInJ1blN0YXRpc3RpY2FsRGV0ZWN0aW9uIiwicnVuQXV0b2VuY29kZXJEZXRlY3Rpb24iLCJydW5FbnNlbWJsZURldGVjdGlvbiIsImRldmlhdGlvbiIsImFicyIsImNhbGN1bGF0ZVNldmVyaXR5IiwibWluIiwiaXNJbkNvb2xkb3duIiwicmFuZG9tIiwidG9TdHJpbmciLCJzdWJzdHIiLCJleHBlY3RlZFJhbmdlIiwiZGVzY3JpcHRpb24iLCJjb250ZXh0IiwicmVsYXRlZE1ldHJpY3MiLCJoaXN0b3JpY2FsQ29tcGFyaXNvbiIsImdldEhpc3RvcmljYWxDb21wYXJpc29uIiwicGF0dGVybnMiLCJyZWNvbW1lbmRhdGlvbnMiLCJnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyIsImZpbmRBdXRvZW5jb2Rlck1vZGVsIiwiaW5wdXRWZWN0b3IiLCJmZWF0dXJlIiwibm9ybWFsaXplZFZlY3RvciIsIm5vcm1hbGl6ZVZlY3RvciIsImlucHV0VGVuc29yIiwicmVjb25zdHJ1Y3Rpb24iLCJyZWNvbnN0cnVjdGVkVmVjdG9yIiwiZGF0YSIsInJlY29uc3RydWN0aW9uRXJyb3IiLCJjYWxjdWxhdGVSZWNvbnN0cnVjdGlvbkVycm9yIiwiY29udHJpYnV0aW5nTWV0cmljcyIsImlkZW50aWZ5Q29udHJpYnV0aW5nTWV0cmljcyIsImNvbnRyaWJ1dGlvbiIsInN0YXRBbGVydHMiLCJhZUFsZXJ0cyIsIlByb21pc2UiLCJhbGwiLCJjb21iaW5lZEFsZXJ0cyIsIm1ldHJpY0FsZXJ0cyIsIk1hcCIsImZvckVhY2giLCJoYXMiLCJhdmdDb25maWRlbmNlIiwibWF4U2V2ZXJpdHkiLCJlbnNlbWJsZUFsZXJ0IiwiU2V0IiwiZmxhdE1hcCIsImRheXMiLCJ2ZWN0b3IiLCJwYXJhbXMiLCJvcmlnaW5hbCIsInJlY29uc3RydWN0ZWQiLCJlcnJvcnMiLCJzb3J0ZWQiLCJyZWZlcmVuY2UiLCJyYXRpbyIsInJlY2VudEFsZXJ0cyIsImNvb2xkb3duUGVyaW9kIiwibGFzdEhvdXIiLCJsYXN0RGF5IiwibGFzdFdlZWsiLCJzZWVuIiwidW5pcXVlIiwia2V5IiwiYWRkIiwiY2FuZGlkYXRlcyIsImV2ZXJ5Iiwic3VtU3F1YXJlZERpZmYiLCJpIiwiY29udHJpYnV0aW9ucyIsInRvdGFsRXJyb3IiLCJ2YWwiLCJpZHgiLCJhbmFseXRpY3NFbmdpbmUiLCJldmVudFN0b3JlIiwiTFJVQ2FjaGUiLCJ0dGwiLCJ3aW5kb3dTaXplIiwiYWxlcnRUaHJlc2hvbGQiLCJBbmFseXRpY3NFbmdpbmUiLCJnZXRJbnN0YW5jZSIsIlBlcmZvcm1hbmNlTW9uaXRvciIsIkV2ZW50U3RvcmUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O1FBZ0VhQTtl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