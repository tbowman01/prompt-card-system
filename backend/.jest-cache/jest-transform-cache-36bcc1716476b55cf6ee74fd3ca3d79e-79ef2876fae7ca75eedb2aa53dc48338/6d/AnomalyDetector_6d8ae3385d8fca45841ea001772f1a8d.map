{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/analytics/AnomalyDetector.ts"],"sourcesContent":["import * as tf from '@tensorflow/tfjs-node';\nimport { EventEmitter } from 'events';\nimport { LRUCache } from 'lru-cache';\nimport { AnalyticsEngine } from './AnalyticsEngine';\nimport { PerformanceMonitor } from '../performance/PerformanceMonitor';\nimport { EventStore } from './EventStore';\n\nexport interface AnomalyModel {\n  id: string;\n  name: string;\n  algorithm: 'isolation_forest' | 'autoencoder' | 'statistical' | 'ensemble';\n  model?: tf.LayersModel;\n  parameters: Record<string, any>;\n  trainedAt: Date;\n  accuracy: number;\n  features: string[];\n  isActive: boolean;\n}\n\nexport interface AnomalyAlert {\n  id: string;\n  timestamp: Date;\n  metric: string;\n  value: number;\n  expectedRange: { min: number; max: number };\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  confidence: number;\n  description: string;\n  context: {\n    relatedMetrics: Record<string, number>;\n    historicalComparison: {\n      lastHour: number;\n      lastDay: number;\n      lastWeek: number;\n    };\n    patterns: string[];\n  };\n  recommendations: string[];\n  acknowledged: boolean;\n  resolved: boolean;\n  resolvedAt?: Date;\n}\n\nexport interface DetectionConfig {\n  sensitivity: 'low' | 'medium' | 'high';\n  windowSize: number; // minutes\n  minSamples: number;\n  alertThreshold: number;\n  cooldownPeriod: number; // minutes\n  enabledAlgorithms: string[];\n  metricWeights: Record<string, number>;\n}\n\nexport interface StatisticalThresholds {\n  metric: string;\n  mean: number;\n  stdDev: number;\n  upperBound: number;\n  lowerBound: number;\n  confidence: number;\n  sampleSize: number;\n  lastUpdated: Date;\n}\n\nexport class AnomalyDetector extends EventEmitter {\n  private models: Map<string, AnomalyModel>;\n  private alerts: Map<string, AnomalyAlert>;\n  private cache: LRUCache<string, any>;\n  private config: DetectionConfig;\n  private statisticalThresholds: Map<string, StatisticalThresholds>;\n  private isRunning: boolean = false;\n  private detectionInterval: NodeJS.Timeout | null = null;\n  private analyticsEngine: AnalyticsEngine;\n  private performanceMonitor: PerformanceMonitor;\n  private eventStore: EventStore;\n  private alertHistory: AnomalyAlert[] = [];\n\n  constructor(config?: Partial<DetectionConfig>) {\n    super();\n    \n    this.models = new Map();\n    this.alerts = new Map();\n    this.statisticalThresholds = new Map();\n    this.alertHistory = [];\n    \n    this.cache = new LRUCache({\n      max: 1000,\n      ttl: 1000 * 60 * 5 // 5 minutes\n    });\n\n    this.config = {\n      sensitivity: 'medium',\n      windowSize: 10,\n      minSamples: 30,\n      alertThreshold: 0.7,\n      cooldownPeriod: 15,\n      enabledAlgorithms: ['autoencoder', 'statistical'],\n      metricWeights: {\n        'cpu_usage': 1.0,\n        'memory_usage': 1.0,\n        'app_response_time': 1.2,\n        'app_error_rate': 1.5,\n        'app_queue_size': 0.8\n      },\n      ...config\n    };\n\n    this.analyticsEngine = AnalyticsEngine.getInstance();\n    this.performanceMonitor = new PerformanceMonitor();\n    this.eventStore = EventStore.getInstance();\n\n    // Initialize default models\n    this.initializeModels();\n  }\n\n  /**\n   * Start real-time anomaly detection\n   */\n  public startDetection(intervalMs: number = 30000): void {\n    if (this.isRunning) {\n      console.log('Anomaly detection already running');\n      return;\n    }\n\n    this.isRunning = true;\n    \n    console.log(`Starting anomaly detection with ${intervalMs}ms interval`);\n    \n    this.detectionInterval = setInterval(async () => {\n      try {\n        await this.performDetection();\n      } catch (error) {\n        console.error('Error during anomaly detection:', error);\n        this.emit('error', error);\n      }\n    }, intervalMs);\n\n    // Start performance monitoring if not already running\n    this.performanceMonitor.startMonitoring(5000);\n\n    this.emit('detection_started');\n  }\n\n  /**\n   * Stop anomaly detection\n   */\n  public stopDetection(): void {\n    if (!this.isRunning) {\n      return;\n    }\n\n    this.isRunning = false;\n\n    if (this.detectionInterval) {\n      clearInterval(this.detectionInterval);\n      this.detectionInterval = null;\n    }\n\n    console.log('Anomaly detection stopped');\n    this.emit('detection_stopped');\n  }\n\n  /**\n   * Train autoencoder model for anomaly detection\n   */\n  public async trainAutoencoderModel(\n    metrics: string[],\n    trainingDays: number = 7\n  ): Promise<AnomalyModel> {\n    console.log(`Training autoencoder model for metrics: ${metrics.join(', ')}`);\n\n    // Collect training data\n    const trainingData = await this.collectTrainingData(metrics, trainingDays);\n    \n    if (trainingData.length < this.config.minSamples) {\n      throw new Error(`Insufficient training data: ${trainingData.length} samples`);\n    }\n\n    // Normalize data\n    const { normalizedData, normalizationParams } = this.normalizeData(trainingData);\n\n    // Create autoencoder model\n    const inputDim = metrics.length;\n    const model = this.createAutoencoderModel(inputDim);\n\n    // Prepare training tensors\n    const xTrain = tf.tensor2d(normalizedData);\n    const splitIndex = Math.floor(normalizedData.length * 0.8);\n    const xTrainSplit = xTrain.slice([0, 0], [splitIndex, -1]);\n    const xVal = xTrain.slice([splitIndex, 0], [-1, -1]);\n\n    // Train model\n    const history = await model.fit(xTrainSplit, xTrainSplit, {\n      epochs: 50,\n      batchSize: 32,\n      validationData: [xVal, xVal],\n      shuffle: true,\n      verbose: 0,\n      callbacks: {\n        onEpochEnd: (epoch, logs) => {\n          if (epoch % 10 === 0) {\n            console.log(`Epoch ${epoch}: loss = ${logs?.loss?.toFixed(4)}`);\n          }\n        }\n      }\n    });\n\n    // Calculate reconstruction threshold\n    const predictions = model.predict(xVal) as tf.Tensor;\n    const reconstructionErrors = await this.calculateReconstructionErrors(xVal, predictions);\n    const threshold = this.calculateThreshold(reconstructionErrors);\n\n    // Evaluate model\n    const finalLoss = history.history.loss[history.history.loss.length - 1] as number;\n    const accuracy = Math.max(0, 1 - finalLoss);\n\n    // Create model object\n    const anomalyModel: AnomalyModel = {\n      id: `autoencoder_${metrics.join('_')}_${Date.now()}`,\n      name: `Autoencoder Anomaly Detection - ${metrics.join(', ')}`,\n      algorithm: 'autoencoder',\n      model,\n      parameters: {\n        threshold,\n        normalizationParams,\n        reconstructionErrorStats: {\n          mean: reconstructionErrors.reduce((sum, e) => sum + e, 0) / reconstructionErrors.length,\n          std: this.calculateStandardDeviation(reconstructionErrors)\n        }\n      },\n      trainedAt: new Date(),\n      accuracy,\n      features: metrics,\n      isActive: true\n    };\n\n    // Store model\n    this.models.set(anomalyModel.id, anomalyModel);\n\n    // Clean up tensors\n    xTrain.dispose();\n    xTrainSplit.dispose();\n    xVal.dispose();\n    predictions.dispose();\n\n    console.log(`Autoencoder model trained with accuracy: ${accuracy.toFixed(4)}, threshold: ${threshold.toFixed(4)}`);\n    \n    return anomalyModel;\n  }\n\n  /**\n   * Update statistical thresholds for a metric\n   */\n  public async updateStatisticalThresholds(\n    metric: string,\n    windowDays: number = 7\n  ): Promise<StatisticalThresholds> {\n    console.log(`Updating statistical thresholds for ${metric}`);\n\n    // Get historical data\n    const historicalData = await this.getHistoricalData(metric, windowDays);\n    \n    if (historicalData.length < this.config.minSamples) {\n      throw new Error(`Insufficient data for ${metric}: ${historicalData.length} samples`);\n    }\n\n    // Calculate statistics\n    const values = historicalData.map(d => d.value);\n    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n    const stdDev = Math.sqrt(variance);\n\n    // Set confidence based on sensitivity\n    const confidenceMap = { low: 2.0, medium: 2.5, high: 3.0 };\n    const confidence = confidenceMap[this.config.sensitivity];\n\n    const thresholds: StatisticalThresholds = {\n      metric,\n      mean,\n      stdDev,\n      upperBound: mean + (confidence * stdDev),\n      lowerBound: mean - (confidence * stdDev),\n      confidence,\n      sampleSize: values.length,\n      lastUpdated: new Date()\n    };\n\n    this.statisticalThresholds.set(metric, thresholds);\n\n    console.log(`Statistical thresholds updated for ${metric}: [${thresholds.lowerBound.toFixed(2)}, ${thresholds.upperBound.toFixed(2)}]`);\n    \n    return thresholds;\n  }\n\n  /**\n   * Detect anomalies in current data\n   */\n  public async detectAnomalies(metrics?: string[]): Promise<AnomalyAlert[]> {\n    const targetMetrics = metrics || Object.keys(this.config.metricWeights);\n    const alerts: AnomalyAlert[] = [];\n\n    // Get current metric values\n    const currentData = await this.getCurrentMetricValues(targetMetrics);\n    \n    if (Object.keys(currentData).length === 0) {\n      return alerts;\n    }\n\n    // Run enabled detection algorithms\n    for (const algorithm of this.config.enabledAlgorithms) {\n      try {\n        const algorithmAlerts = await this.runDetectionAlgorithm(\n          algorithm,\n          currentData,\n          targetMetrics\n        );\n        alerts.push(...algorithmAlerts);\n      } catch (error) {\n        console.error(`Error running ${algorithm} detection:`, error);\n      }\n    }\n\n    // Deduplicate and prioritize alerts\n    const uniqueAlerts = this.deduplicateAlerts(alerts);\n\n    // Store new alerts\n    for (const alert of uniqueAlerts) {\n      this.alerts.set(alert.id, alert);\n      this.alertHistory.push(alert);\n      \n      // Emit alert event\n      this.emit('anomaly_detected', alert);\n      \n      // Auto-acknowledge low severity alerts\n      if (alert.severity === 'low') {\n        setTimeout(() => this.acknowledgeAlert(alert.id), 5 * 60 * 1000); // 5 minutes\n      }\n    }\n\n    return uniqueAlerts;\n  }\n\n  /**\n   * Acknowledge an alert\n   */\n  public acknowledgeAlert(alertId: string, userId?: string): boolean {\n    const alert = this.alerts.get(alertId);\n    if (!alert) {\n      return false;\n    }\n\n    alert.acknowledged = true;\n    this.emit('alert_acknowledged', { alert, userId });\n    \n    return true;\n  }\n\n  /**\n   * Resolve an alert\n   */\n  public resolveAlert(alertId: string, userId?: string): boolean {\n    const alert = this.alerts.get(alertId);\n    if (!alert) {\n      return false;\n    }\n\n    alert.resolved = true;\n    alert.resolvedAt = new Date();\n    this.emit('alert_resolved', { alert, userId });\n    \n    return true;\n  }\n\n  /**\n   * Get active alerts\n   */\n  public getActiveAlerts(): AnomalyAlert[] {\n    return Array.from(this.alerts.values())\n      .filter(alert => !alert.resolved)\n      .sort((a, b) => {\n        // Sort by severity then timestamp\n        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };\n        const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];\n        if (severityDiff !== 0) return severityDiff;\n        return b.timestamp.getTime() - a.timestamp.getTime();\n      });\n  }\n\n  /**\n   * Get detection statistics\n   */\n  public getDetectionStats(): {\n    totalAlerts: number;\n    activeAlerts: number;\n    alertsByseverity: Record<string, number>;\n    detectionAccuracy: number;\n    falsePositiveRate: number;\n    modelCount: number;\n    lastDetection: Date | null;\n  } {\n    const alerts = Array.from(this.alerts.values());\n    const activeAlerts = alerts.filter(a => !a.resolved);\n    \n    const alertsByseverity = alerts.reduce((acc, alert) => {\n      acc[alert.severity] = (acc[alert.severity] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    // Calculate accuracy (simplified - would need labeled data for real accuracy)\n    const acknowledgedAlerts = alerts.filter(a => a.acknowledged);\n    const accuracy = alerts.length > 0 ? acknowledgedAlerts.length / alerts.length : 0;\n\n    // Estimate false positive rate\n    const resolvedQuickly = alerts.filter(a => \n      a.resolved && a.resolvedAt && \n      (a.resolvedAt.getTime() - a.timestamp.getTime()) < 300000 // 5 minutes\n    );\n    const falsePositiveRate = alerts.length > 0 ? resolvedQuickly.length / alerts.length : 0;\n\n    const lastDetection = alerts.length > 0 \n      ? new Date(Math.max(...alerts.map(a => a.timestamp.getTime())))\n      : null;\n\n    return {\n      totalAlerts: alerts.length,\n      activeAlerts: activeAlerts.length,\n      alertsByseverity,\n      detectionAccuracy: accuracy,\n      falsePositiveRate,\n      modelCount: this.models.size,\n      lastDetection\n    };\n  }\n\n  /**\n   * Update detection configuration\n   */\n  public updateConfig(newConfig: Partial<DetectionConfig>): void {\n    this.config = { ...this.config, ...newConfig };\n    console.log('Anomaly detection configuration updated');\n    this.emit('config_updated', this.config);\n  }\n\n  /**\n   * Export detection data\n   */\n  public exportData(): {\n    config: DetectionConfig;\n    models: any[];\n    alerts: AnomalyAlert[];\n    thresholds: StatisticalThresholds[];\n    stats: any;\n  } {\n    return {\n      config: this.config,\n      models: Array.from(this.models.values()).map(m => ({\n        ...m,\n        model: undefined // Don't export TensorFlow models\n      })),\n      alerts: this.alertHistory,\n      thresholds: Array.from(this.statisticalThresholds.values()),\n      stats: this.getDetectionStats()\n    };\n  }\n\n  // Private methods\n\n  private async initializeModels(): Promise<void> {\n    try {\n      // Initialize statistical thresholds for key metrics\n      const keyMetrics = Object.keys(this.config.metricWeights);\n      \n      for (const metric of keyMetrics) {\n        try {\n          await this.updateStatisticalThresholds(metric);\n        } catch (error) {\n          console.warn(`Failed to initialize thresholds for ${metric}:`, error.message);\n        }\n      }\n\n      // Train initial autoencoder model if enabled\n      if (this.config.enabledAlgorithms.includes('autoencoder')) {\n        try {\n          await this.trainAutoencoderModel(keyMetrics);\n        } catch (error) {\n          console.warn('Failed to train initial autoencoder model:', error.message);\n        }\n      }\n\n    } catch (error) {\n      console.error('Error initializing anomaly detection models:', error);\n    }\n  }\n\n  private createAutoencoderModel(inputDim: number): tf.LayersModel {\n    const model = tf.sequential({\n      layers: [\n        // Encoder\n        tf.layers.dense({\n          inputShape: [inputDim],\n          units: Math.max(8, Math.floor(inputDim * 0.8)),\n          activation: 'relu',\n          kernelRegularizer: tf.regularizers.l2({ l2: 0.01 })\n        }),\n        tf.layers.dropout({ rate: 0.1 }),\n        tf.layers.dense({\n          units: Math.max(4, Math.floor(inputDim * 0.5)),\n          activation: 'relu'\n        }),\n        tf.layers.dense({\n          units: Math.max(2, Math.floor(inputDim * 0.3)),\n          activation: 'relu'\n        }),\n        // Decoder\n        tf.layers.dense({\n          units: Math.max(4, Math.floor(inputDim * 0.5)),\n          activation: 'relu'\n        }),\n        tf.layers.dense({\n          units: Math.max(8, Math.floor(inputDim * 0.8)),\n          activation: 'relu'\n        }),\n        tf.layers.dense({\n          units: inputDim,\n          activation: 'linear'\n        })\n      ]\n    });\n\n    model.compile({\n      optimizer: tf.train.adam(0.001),\n      loss: 'meanSquaredError'\n    });\n\n    return model;\n  }\n\n  private async performDetection(): Promise<void> {\n    const alerts = await this.detectAnomalies();\n    \n    // Update cache with detection results\n    this.cache.set('last_detection', {\n      timestamp: new Date(),\n      alertCount: alerts.length,\n      alerts: alerts.map(a => ({ id: a.id, severity: a.severity, metric: a.metric }))\n    });\n\n    // Clean up old alerts (keep only last 1000)\n    if (this.alertHistory.length > 1000) {\n      this.alertHistory = this.alertHistory.slice(-1000);\n    }\n\n    // Clean up resolved alerts from active alerts map\n    for (const [id, alert] of this.alerts.entries()) {\n      if (alert.resolved && \n          (Date.now() - alert.timestamp.getTime()) > 24 * 60 * 60 * 1000) { // 24 hours\n        this.alerts.delete(id);\n      }\n    }\n  }\n\n  private async runDetectionAlgorithm(\n    algorithm: string,\n    currentData: Record<string, number>,\n    metrics: string[]\n  ): Promise<AnomalyAlert[]> {\n    switch (algorithm) {\n      case 'statistical':\n        return this.runStatisticalDetection(currentData, metrics);\n      case 'autoencoder':\n        return this.runAutoencoderDetection(currentData, metrics);\n      case 'ensemble':\n        return this.runEnsembleDetection(currentData, metrics);\n      default:\n        console.warn(`Unknown detection algorithm: ${algorithm}`);\n        return [];\n    }\n  }\n\n  private async runStatisticalDetection(\n    currentData: Record<string, number>,\n    metrics: string[]\n  ): Promise<AnomalyAlert[]> {\n    const alerts: AnomalyAlert[] = [];\n\n    for (const metric of metrics) {\n      const value = currentData[metric];\n      if (value === undefined) continue;\n\n      const thresholds = this.statisticalThresholds.get(metric);\n      if (!thresholds) continue;\n\n      // Check if value is outside thresholds\n      if (value > thresholds.upperBound || value < thresholds.lowerBound) {\n        const deviation = Math.max(\n          Math.abs(value - thresholds.upperBound),\n          Math.abs(value - thresholds.lowerBound)\n        );\n        \n        const severity = this.calculateSeverity(deviation, thresholds.stdDev);\n        const confidence = Math.min(deviation / thresholds.stdDev, 1.0);\n\n        // Check cooldown period\n        if (this.isInCooldown(metric)) continue;\n\n        const alert: AnomalyAlert = {\n          id: `stat_${metric}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,\n          timestamp: new Date(),\n          metric,\n          value,\n          expectedRange: {\n            min: thresholds.lowerBound,\n            max: thresholds.upperBound\n          },\n          severity,\n          confidence,\n          description: `${metric} value ${value.toFixed(2)} is outside expected range [${thresholds.lowerBound.toFixed(2)}, ${thresholds.upperBound.toFixed(2)}]`,\n          context: {\n            relatedMetrics: { ...currentData },\n            historicalComparison: await this.getHistoricalComparison(metric),\n            patterns: ['statistical_outlier']\n          },\n          recommendations: this.generateRecommendations(metric, value, 'statistical'),\n          acknowledged: false,\n          resolved: false\n        };\n\n        alerts.push(alert);\n      }\n    }\n\n    return alerts;\n  }\n\n  private async runAutoencoderDetection(\n    currentData: Record<string, number>,\n    metrics: string[]\n  ): Promise<AnomalyAlert[]> {\n    const alerts: AnomalyAlert[] = [];\n\n    // Find suitable autoencoder model\n    const model = this.findAutoencoderModel(metrics);\n    if (!model || !model.model) return alerts;\n\n    try {\n      // Prepare input data\n      const inputVector = model.features.map(feature => currentData[feature] || 0);\n      const { normalizedVector } = this.normalizeVector(inputVector, model.parameters.normalizationParams);\n\n      // Get reconstruction\n      const inputTensor = tf.tensor2d([normalizedVector]);\n      const reconstruction = model.model.predict(inputTensor) as tf.Tensor;\n      const reconstructedVector = await reconstruction.data();\n\n      // Calculate reconstruction error\n      const reconstructionError = this.calculateReconstructionError(\n        normalizedVector,\n        Array.from(reconstructedVector)\n      );\n\n      // Check against threshold\n      const threshold = model.parameters.threshold;\n      \n      if (reconstructionError > threshold) {\n        // Determine which metrics contributed most to the anomaly\n        const contributingMetrics = this.identifyContributingMetrics(\n          normalizedVector,\n          Array.from(reconstructedVector),\n          model.features\n        );\n\n        for (const { metric, contribution } of contributingMetrics) {\n          if (contribution > 0.3 && !this.isInCooldown(metric)) { // 30% contribution threshold\n            const value = currentData[metric];\n            const severity = this.calculateSeverity(reconstructionError, threshold);\n            const confidence = Math.min(reconstructionError / threshold, 1.0);\n\n            const alert: AnomalyAlert = {\n              id: `ae_${metric}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,\n              timestamp: new Date(),\n              metric,\n              value,\n              expectedRange: { min: 0, max: 0 }, // Autoencoder doesn't provide explicit ranges\n              severity,\n              confidence,\n              description: `Autoencoder detected anomaly in ${metric} (reconstruction error: ${reconstructionError.toFixed(4)})`,\n              context: {\n                relatedMetrics: { ...currentData },\n                historicalComparison: await this.getHistoricalComparison(metric),\n                patterns: ['autoencoder_anomaly', `contribution_${(contribution * 100).toFixed(1)}%`]\n              },\n              recommendations: this.generateRecommendations(metric, value, 'autoencoder'),\n              acknowledged: false,\n              resolved: false\n            };\n\n            alerts.push(alert);\n          }\n        }\n      }\n\n      // Cleanup tensors\n      inputTensor.dispose();\n      reconstruction.dispose();\n\n    } catch (error) {\n      console.error('Error in autoencoder detection:', error);\n    }\n\n    return alerts;\n  }\n\n  private async runEnsembleDetection(\n    currentData: Record<string, number>,\n    metrics: string[]\n  ): Promise<AnomalyAlert[]> {\n    // Run both statistical and autoencoder detection\n    const [statAlerts, aeAlerts] = await Promise.all([\n      this.runStatisticalDetection(currentData, metrics),\n      this.runAutoencoderDetection(currentData, metrics)\n    ]);\n\n    // Combine and weigh results\n    const combinedAlerts: AnomalyAlert[] = [];\n    const metricAlerts = new Map<string, AnomalyAlert[]>();\n\n    // Group alerts by metric\n    [...statAlerts, ...aeAlerts].forEach(alert => {\n      if (!metricAlerts.has(alert.metric)) {\n        metricAlerts.set(alert.metric, []);\n      }\n      metricAlerts.get(alert.metric)!.push(alert);\n    });\n\n    // Create ensemble alerts\n    for (const [metric, alerts] of metricAlerts.entries()) {\n      if (alerts.length > 1) {\n        // Multiple algorithms detected anomaly - high confidence\n        const avgConfidence = alerts.reduce((sum, a) => sum + a.confidence, 0) / alerts.length;\n        const maxSeverity = alerts.reduce((max, a) => {\n          const severityOrder = { low: 1, medium: 2, high: 3, critical: 4 };\n          return severityOrder[a.severity] > severityOrder[max.severity] ? a : max;\n        });\n\n        const ensembleAlert: AnomalyAlert = {\n          ...maxSeverity,\n          id: `ensemble_${metric}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`,\n          confidence: Math.min(avgConfidence * 1.2, 1.0), // Boost confidence for ensemble\n          description: `Multiple algorithms detected anomaly in ${metric}`,\n          context: {\n            ...maxSeverity.context,\n            patterns: [...new Set(alerts.flatMap(a => a.context.patterns)), 'ensemble_detection']\n          }\n        };\n\n        combinedAlerts.push(ensembleAlert);\n      } else {\n        // Single algorithm detection\n        combinedAlerts.push(alerts[0]);\n      }\n    }\n\n    return combinedAlerts;\n  }\n\n  // Additional helper methods...\n\n  private async collectTrainingData(metrics: string[], days: number): Promise<number[][]> {\n    // Implementation to collect training data for specified metrics and time period\n    return [];\n  }\n\n  private normalizeData(data: number[][]): { normalizedData: number[][]; normalizationParams: any } {\n    // Implementation for data normalization\n    return { normalizedData: data, normalizationParams: {} };\n  }\n\n  private normalizeVector(vector: number[], params: any): { normalizedVector: number[] } {\n    // Implementation for vector normalization\n    return { normalizedVector: vector };\n  }\n\n  private async calculateReconstructionErrors(original: tf.Tensor, reconstructed: tf.Tensor): Promise<number[]> {\n    // Implementation for calculating reconstruction errors\n    return [];\n  }\n\n  private calculateThreshold(errors: number[]): number {\n    // Use 95th percentile as threshold\n    const sorted = errors.sort((a, b) => a - b);\n    return sorted[Math.floor(sorted.length * 0.95)];\n  }\n\n  private calculateStandardDeviation(values: number[]): number {\n    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;\n    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n    return Math.sqrt(variance);\n  }\n\n  private async getHistoricalData(metric: string, days: number): Promise<any[]> {\n    // Implementation to get historical data for a metric\n    return [];\n  }\n\n  private async getCurrentMetricValues(metrics: string[]): Promise<Record<string, number>> {\n    // Implementation to get current metric values\n    return {};\n  }\n\n  private calculateSeverity(deviation: number, reference: number): AnomalyAlert['severity'] {\n    const ratio = deviation / reference;\n    if (ratio > 3) return 'critical';\n    if (ratio > 2) return 'high';\n    if (ratio > 1.5) return 'medium';\n    return 'low';\n  }\n\n  private isInCooldown(metric: string): boolean {\n    const recentAlerts = Array.from(this.alerts.values())\n      .filter(alert => \n        alert.metric === metric && \n        !alert.resolved &&\n        (Date.now() - alert.timestamp.getTime()) < (this.config.cooldownPeriod * 60 * 1000)\n      );\n    return recentAlerts.length > 0;\n  }\n\n  private async getHistoricalComparison(metric: string): Promise<{ lastHour: number; lastDay: number; lastWeek: number }> {\n    // Implementation to get historical comparison data\n    return { lastHour: 0, lastDay: 0, lastWeek: 0 };\n  }\n\n  private generateRecommendations(metric: string, value: number, algorithm: string): string[] {\n    const recommendations: string[] = [];\n    \n    recommendations.push(`Investigate ${metric} anomaly detected by ${algorithm}`);\n    recommendations.push('Check system logs for related events');\n    recommendations.push('Monitor related metrics for cascading effects');\n    \n    if (metric.includes('cpu') || metric.includes('memory')) {\n      recommendations.push('Consider scaling resources if pattern persists');\n    }\n    \n    if (metric.includes('response_time')) {\n      recommendations.push('Check for database query performance issues');\n      recommendations.push('Review application bottlenecks');\n    }\n    \n    return recommendations;\n  }\n\n  private deduplicateAlerts(alerts: AnomalyAlert[]): AnomalyAlert[] {\n    // Remove duplicate alerts for the same metric within a short time window\n    const seen = new Set<string>();\n    const unique: AnomalyAlert[] = [];\n    \n    for (const alert of alerts.sort((a, b) => b.confidence - a.confidence)) {\n      const key = `${alert.metric}_${Math.floor(alert.timestamp.getTime() / (5 * 60 * 1000))}`; // 5-minute windows\n      if (!seen.has(key)) {\n        seen.add(key);\n        unique.push(alert);\n      }\n    }\n    \n    return unique;\n  }\n\n  private findAutoencoderModel(metrics: string[]): AnomalyModel | null {\n    const candidates = Array.from(this.models.values())\n      .filter(model => \n        model.algorithm === 'autoencoder' && \n        model.isActive &&\n        metrics.every(m => model.features.includes(m))\n      )\n      .sort((a, b) => b.accuracy - a.accuracy);\n\n    return candidates[0] || null;\n  }\n\n  private calculateReconstructionError(original: number[], reconstructed: number[]): number {\n    let sumSquaredDiff = 0;\n    for (let i = 0; i < original.length; i++) {\n      sumSquaredDiff += Math.pow(original[i] - reconstructed[i], 2);\n    }\n    return Math.sqrt(sumSquaredDiff / original.length);\n  }\n\n  private identifyContributingMetrics(\n    original: number[],\n    reconstructed: number[],\n    features: string[]\n  ): Array<{ metric: string; contribution: number }> {\n    const contributions: Array<{ metric: string; contribution: number }> = [];\n    \n    let totalError = 0;\n    const errors = original.map((val, idx) => {\n      const error = Math.abs(val - reconstructed[idx]);\n      totalError += error;\n      return error;\n    });\n\n    features.forEach((feature, idx) => {\n      const contribution = totalError > 0 ? errors[idx] / totalError : 0;\n      contributions.push({ metric: feature, contribution });\n    });\n\n    return contributions.sort((a, b) => b.contribution - a.contribution);\n  }\n}\n\n// Export singleton instance\nexport const anomalyDetector = new AnomalyDetector();"],"names":["AnomalyDetector","anomalyDetector","EventEmitter","startDetection","intervalMs","isRunning","console","log","detectionInterval","setInterval","performDetection","error","emit","performanceMonitor","startMonitoring","stopDetection","clearInterval","trainAutoencoderModel","metrics","trainingDays","join","trainingData","collectTrainingData","length","config","minSamples","Error","normalizedData","normalizationParams","normalizeData","inputDim","model","createAutoencoderModel","xTrain","tf","tensor2d","splitIndex","Math","floor","xTrainSplit","slice","xVal","history","fit","epochs","batchSize","validationData","shuffle","verbose","callbacks","onEpochEnd","epoch","logs","loss","toFixed","predictions","predict","reconstructionErrors","calculateReconstructionErrors","threshold","calculateThreshold","finalLoss","accuracy","max","anomalyModel","id","Date","now","name","algorithm","parameters","reconstructionErrorStats","mean","reduce","sum","e","std","calculateStandardDeviation","trainedAt","features","isActive","models","set","dispose","updateStatisticalThresholds","metric","windowDays","historicalData","getHistoricalData","values","map","d","value","v","variance","pow","stdDev","sqrt","confidenceMap","low","medium","high","confidence","sensitivity","thresholds","upperBound","lowerBound","sampleSize","lastUpdated","statisticalThresholds","detectAnomalies","targetMetrics","Object","keys","metricWeights","alerts","currentData","getCurrentMetricValues","enabledAlgorithms","algorithmAlerts","runDetectionAlgorithm","push","uniqueAlerts","deduplicateAlerts","alert","alertHistory","severity","setTimeout","acknowledgeAlert","alertId","userId","get","acknowledged","resolveAlert","resolved","resolvedAt","getActiveAlerts","Array","from","filter","sort","a","b","severityOrder","critical","severityDiff","timestamp","getTime","getDetectionStats","activeAlerts","alertsByseverity","acc","acknowledgedAlerts","resolvedQuickly","falsePositiveRate","lastDetection","totalAlerts","detectionAccuracy","modelCount","size","updateConfig","newConfig","exportData","m","undefined","stats","initializeModels","keyMetrics","warn","message","includes","sequential","layers","dense","inputShape","units","activation","kernelRegularizer","regularizers","l2","dropout","rate","compile","optimizer","train","adam","cache","alertCount","entries","delete","runStatisticalDetection","runAutoencoderDetection","runEnsembleDetection","deviation","abs","calculateSeverity","min","isInCooldown","random","toString","substr","expectedRange","description","context","relatedMetrics","historicalComparison","getHistoricalComparison","patterns","recommendations","generateRecommendations","findAutoencoderModel","inputVector","feature","normalizedVector","normalizeVector","inputTensor","reconstruction","reconstructedVector","data","reconstructionError","calculateReconstructionError","contributingMetrics","identifyContributingMetrics","contribution","statAlerts","aeAlerts","Promise","all","combinedAlerts","metricAlerts","Map","forEach","has","avgConfidence","maxSeverity","ensembleAlert","Set","flatMap","days","vector","params","original","reconstructed","errors","sorted","reference","ratio","recentAlerts","cooldownPeriod","lastHour","lastDay","lastWeek","seen","unique","key","add","candidates","every","sumSquaredDiff","i","contributions","totalError","val","idx","analyticsEngine","eventStore","LRUCache","ttl","windowSize","alertThreshold","AnalyticsEngine","getInstance","PerformanceMonitor","EventStore"],"mappings":"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"}