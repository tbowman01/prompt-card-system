{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/performance/LoadTestScheduler.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport { loadTestingFramework } from './LoadTestingFramework';\nimport { performanceRegressionDetector } from './PerformanceRegressionDetector';\nimport { performanceBenchmark } from './PerformanceBenchmark';\nimport { db } from '../../database/connection';\nimport { CronJob } from 'cron';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface ScheduledTest {\n  id: string;\n  name: string;\n  scenarioId: string;\n  schedule: string; // Cron expression\n  enabled: boolean;\n  options: {\n    saveBaseline?: boolean;\n    compareBaseline?: boolean;\n    notifyOnRegression?: boolean;\n    runBenchmarks?: boolean;\n  };\n  lastRun?: Date;\n  nextRun?: Date;\n  consecutiveFailures: number;\n  maxConsecutiveFailures: number;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface TestExecutionResult {\n  scheduledTestId: string;\n  executionId: string;\n  startTime: Date;\n  endTime: Date;\n  success: boolean;\n  error?: string;\n  results?: any;\n  regressionAlerts?: any[];\n  benchmarkResults?: any;\n}\n\nexport interface SchedulerConfiguration {\n  enabled: boolean;\n  maxConcurrentTests: number;\n  defaultTimeout: number; // milliseconds\n  retryFailedTests: boolean;\n  maxRetries: number;\n  retryDelay: number; // milliseconds\n  cleanupOldResults: boolean;\n  resultsRetentionDays: number;\n  notifications: {\n    enabled: boolean;\n    channels: string[]; // email, slack, webhook\n    onSuccess: boolean;\n    onFailure: boolean;\n    onRegression: boolean;\n  };\n}\n\nexport class LoadTestScheduler extends EventEmitter {\n  private scheduledTests: Map<string, ScheduledTest> = new Map();\n  private cronJobs: Map<string, CronJob> = new Map();\n  private activeExecutions: Map<string, TestExecutionResult> = new Map();\n  private configuration: SchedulerConfiguration;\n  private isInitialized: boolean = false;\n\n  constructor() {\n    super();\n    this.configuration = this.getDefaultConfiguration();\n  }\n\n  /**\n   * Initialize the scheduler\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      await this.createTables();\n      await this.loadScheduledTests();\n      await this.loadConfiguration();\n      \n      if (this.configuration.enabled) {\n        this.startAllScheduledTests();\n      }\n\n      // Start cleanup job (daily at 2 AM)\n      if (this.configuration.cleanupOldResults) {\n        this.scheduleCleanupJob();\n      }\n\n      this.isInitialized = true;\n      this.emit('initialized');\n      console.log('Load test scheduler initialized');\n    } catch (error) {\n      console.error('Failed to initialize load test scheduler:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Create a new scheduled test\n   */\n  async createScheduledTest(test: Omit<ScheduledTest, 'id' | 'createdAt' | 'updatedAt' | 'consecutiveFailures'>): Promise<string> {\n    const scheduledTest: ScheduledTest = {\n      ...test,\n      id: uuidv4(),\n      consecutiveFailures: 0,\n      maxConsecutiveFailures: test.maxConsecutiveFailures || 3,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    // Validate cron expression\n    try {\n      new CronJob(test.schedule, () => {}, null, false);\n    } catch (error) {\n      throw new Error(`Invalid cron expression: ${test.schedule}`);\n    }\n\n    // Save to database\n    await this.saveScheduledTest(scheduledTest);\n    \n    // Add to memory\n    this.scheduledTests.set(scheduledTest.id, scheduledTest);\n\n    // Start cron job if enabled\n    if (scheduledTest.enabled && this.configuration.enabled) {\n      this.startCronJob(scheduledTest);\n    }\n\n    this.emit('scheduledTestCreated', scheduledTest);\n    return scheduledTest.id;\n  }\n\n  /**\n   * Update a scheduled test\n   */\n  async updateScheduledTest(id: string, updates: Partial<ScheduledTest>): Promise<void> {\n    const scheduledTest = this.scheduledTests.get(id);\n    if (!scheduledTest) {\n      throw new Error(`Scheduled test not found: ${id}`);\n    }\n\n    const updatedTest = {\n      ...scheduledTest,\n      ...updates,\n      updatedAt: new Date()\n    };\n\n    // Validate cron expression if changed\n    if (updates.schedule && updates.schedule !== scheduledTest.schedule) {\n      try {\n        new CronJob(updates.schedule, () => {}, null, false);\n      } catch (error) {\n        throw new Error(`Invalid cron expression: ${updates.schedule}`);\n      }\n    }\n\n    // Update database\n    await this.saveScheduledTest(updatedTest);\n    \n    // Update memory\n    this.scheduledTests.set(id, updatedTest);\n\n    // Restart cron job if schedule or enabled status changed\n    if (updates.schedule || updates.enabled !== undefined) {\n      this.stopCronJob(id);\n      if (updatedTest.enabled && this.configuration.enabled) {\n        this.startCronJob(updatedTest);\n      }\n    }\n\n    this.emit('scheduledTestUpdated', updatedTest);\n  }\n\n  /**\n   * Delete a scheduled test\n   */\n  async deleteScheduledTest(id: string): Promise<void> {\n    const scheduledTest = this.scheduledTests.get(id);\n    if (!scheduledTest) {\n      throw new Error(`Scheduled test not found: ${id}`);\n    }\n\n    // Stop cron job\n    this.stopCronJob(id);\n\n    // Remove from database\n    const stmt = db.prepare('DELETE FROM scheduled_tests WHERE id = ?');\n    stmt.run(id);\n\n    // Remove from memory\n    this.scheduledTests.delete(id);\n\n    this.emit('scheduledTestDeleted', id);\n  }\n\n  /**\n   * Get all scheduled tests\n   */\n  getScheduledTests(): ScheduledTest[] {\n    return Array.from(this.scheduledTests.values());\n  }\n\n  /**\n   * Get a specific scheduled test\n   */\n  getScheduledTest(id: string): ScheduledTest | undefined {\n    return this.scheduledTests.get(id);\n  }\n\n  /**\n   * Get test execution history\n   */\n  async getExecutionHistory(scheduledTestId?: string, limit: number = 50, offset: number = 0): Promise<TestExecutionResult[]> {\n    let query = `\n      SELECT * FROM test_executions \n      ${scheduledTestId ? 'WHERE scheduled_test_id = ?' : ''}\n      ORDER BY start_time DESC \n      LIMIT ? OFFSET ?\n    `;\n    \n    const params = scheduledTestId ? [scheduledTestId, limit, offset] : [limit, offset];\n    const stmt = db.prepare(query);\n    const rows = stmt.all(...params) as any[];\n    \n    return rows.map(row => ({\n      scheduledTestId: row.scheduled_test_id,\n      executionId: row.execution_id,\n      startTime: new Date(row.start_time),\n      endTime: new Date(row.end_time),\n      success: Boolean(row.success),\n      error: row.error,\n      results: row.results ? JSON.parse(row.results) : undefined,\n      regressionAlerts: row.regression_alerts ? JSON.parse(row.regression_alerts) : undefined,\n      benchmarkResults: row.benchmark_results ? JSON.parse(row.benchmark_results) : undefined\n    }));\n  }\n\n  /**\n   * Manually execute a scheduled test\n   */\n  async executeTest(scheduledTestId: string): Promise<TestExecutionResult> {\n    const scheduledTest = this.scheduledTests.get(scheduledTestId);\n    if (!scheduledTest) {\n      throw new Error(`Scheduled test not found: ${scheduledTestId}`);\n    }\n\n    if (this.activeExecutions.has(scheduledTestId)) {\n      throw new Error('Test is already running');\n    }\n\n    const executionId = uuidv4();\n    const execution: TestExecutionResult = {\n      scheduledTestId,\n      executionId,\n      startTime: new Date(),\n      endTime: new Date(),\n      success: false\n    };\n\n    this.activeExecutions.set(scheduledTestId, execution);\n    this.emit('testExecutionStarted', execution);\n\n    try {\n      // Execute load test\n      const loadTestResults = await loadTestingFramework.runLoadTest(\n        scheduledTest.scenarioId,\n        {\n          saveBaseline: scheduledTest.options.saveBaseline,\n          compareBaseline: scheduledTest.options.compareBaseline\n        }\n      );\n\n      execution.results = loadTestResults;\n\n      // Check for regressions if enabled\n      if (scheduledTest.options.compareBaseline) {\n        const regressionAlerts = await performanceRegressionDetector.analyzeResults(\n          scheduledTest.scenarioId,\n          loadTestResults\n        );\n        execution.regressionAlerts = regressionAlerts;\n      }\n\n      // Run benchmarks if enabled\n      if (scheduledTest.options.runBenchmarks) {\n        const benchmarkResults = await performanceBenchmark.runBenchmarkSuite(\n          `Scheduled Benchmark - ${scheduledTest.name}`\n        );\n        execution.benchmarkResults = benchmarkResults;\n      }\n\n      execution.success = true;\n      execution.endTime = new Date();\n\n      // Reset consecutive failures on success\n      if (scheduledTest.consecutiveFailures > 0) {\n        await this.updateScheduledTest(scheduledTestId, { \n          consecutiveFailures: 0,\n          lastRun: new Date()\n        });\n      } else {\n        await this.updateScheduledTest(scheduledTestId, { \n          lastRun: new Date()\n        });\n      }\n\n      // Send notifications if configured\n      if (this.configuration.notifications.enabled && this.configuration.notifications.onSuccess) {\n        await this.sendNotification('success', scheduledTest, execution);\n      }\n\n      if (execution.regressionAlerts && execution.regressionAlerts.length > 0 && \n          this.configuration.notifications.onRegression) {\n        await this.sendNotification('regression', scheduledTest, execution);\n      }\n\n    } catch (error) {\n      execution.success = false;\n      execution.error = error.message;\n      execution.endTime = new Date();\n\n      // Increment consecutive failures\n      const newFailureCount = scheduledTest.consecutiveFailures + 1;\n      await this.updateScheduledTest(scheduledTestId, { \n        consecutiveFailures: newFailureCount,\n        lastRun: new Date()\n      });\n\n      // Disable test if max consecutive failures reached\n      if (newFailureCount >= scheduledTest.maxConsecutiveFailures) {\n        await this.updateScheduledTest(scheduledTestId, { enabled: false });\n        console.log(`Disabled scheduled test ${scheduledTest.name} due to consecutive failures`);\n      }\n\n      // Send failure notification\n      if (this.configuration.notifications.enabled && this.configuration.notifications.onFailure) {\n        await this.sendNotification('failure', scheduledTest, execution);\n      }\n\n      console.error(`Scheduled test execution failed: ${scheduledTest.name}`, error);\n    } finally {\n      this.activeExecutions.delete(scheduledTestId);\n      await this.saveExecution(execution);\n      this.emit('testExecutionCompleted', execution);\n    }\n\n    return execution;\n  }\n\n  /**\n   * Update scheduler configuration\n   */\n  async updateConfiguration(config: Partial<SchedulerConfiguration>): Promise<void> {\n    this.configuration = { ...this.configuration, ...config };\n    await this.saveConfiguration();\n\n    // Restart scheduler if enabled status changed\n    if (config.enabled !== undefined) {\n      if (config.enabled) {\n        this.startAllScheduledTests();\n      } else {\n        this.stopAllScheduledTests();\n      }\n    }\n\n    this.emit('configurationUpdated', this.configuration);\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfiguration(): SchedulerConfiguration {\n    return { ...this.configuration };\n  }\n\n  /**\n   * Get scheduler status\n   */\n  getStatus(): {\n    enabled: boolean;\n    scheduledTestsCount: number;\n    activeExecutionsCount: number;\n    activeExecutions: Array<{\n      scheduledTestId: string;\n      executionId: string;\n      startTime: Date;\n      testName: string;\n    }>;\n    nextExecutions: Array<{\n      scheduledTestId: string;\n      testName: string;\n      nextRun: Date;\n    }>;\n  } {\n    const activeExecutions = Array.from(this.activeExecutions.values()).map(execution => ({\n      scheduledTestId: execution.scheduledTestId,\n      executionId: execution.executionId,\n      startTime: execution.startTime,\n      testName: this.scheduledTests.get(execution.scheduledTestId)?.name || 'Unknown'\n    }));\n\n    const nextExecutions = Array.from(this.scheduledTests.values())\n      .filter(test => test.enabled && test.nextRun)\n      .sort((a, b) => a.nextRun!.getTime() - b.nextRun!.getTime())\n      .slice(0, 10)\n      .map(test => ({\n        scheduledTestId: test.id,\n        testName: test.name,\n        nextRun: test.nextRun!\n      }));\n\n    return {\n      enabled: this.configuration.enabled,\n      scheduledTestsCount: this.scheduledTests.size,\n      activeExecutionsCount: this.activeExecutions.size,\n      activeExecutions,\n      nextExecutions\n    };\n  }\n\n  /**\n   * Clean up old test results\n   */\n  async cleanupOldResults(): Promise<{ deletedExecutions: number; deletedAlerts: number }> {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - this.configuration.resultsRetentionDays);\n    \n    // Delete old executions\n    const deleteExecutionsStmt = db.prepare(\n      'DELETE FROM test_executions WHERE start_time < ?'\n    );\n    const executionResult = deleteExecutionsStmt.run(cutoffDate.toISOString());\n    \n    // Delete old regression alerts\n    const deleteAlertsStmt = db.prepare(\n      'DELETE FROM regression_alerts WHERE timestamp < ? AND acknowledged = 1'\n    );\n    const alertResult = deleteAlertsStmt.run(cutoffDate.toISOString());\n    \n    const result = {\n      deletedExecutions: executionResult.changes,\n      deletedAlerts: alertResult.changes\n    };\n    \n    this.emit('cleanupCompleted', result);\n    console.log('Cleanup completed:', result);\n    \n    return result;\n  }\n\n  /**\n   * Shutdown the scheduler\n   */\n  async shutdown(): Promise<void> {\n    this.stopAllScheduledTests();\n    this.removeAllListeners();\n    console.log('Load test scheduler shutdown completed');\n  }\n\n  /**\n   * Private methods\n   */\n  private async createTables(): Promise<void> {\n    // Create scheduled tests table\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS scheduled_tests (\n        id TEXT PRIMARY KEY,\n        name TEXT NOT NULL,\n        scenario_id TEXT NOT NULL,\n        schedule TEXT NOT NULL,\n        enabled BOOLEAN NOT NULL,\n        options_json TEXT NOT NULL,\n        last_run TEXT,\n        consecutive_failures INTEGER DEFAULT 0,\n        max_consecutive_failures INTEGER DEFAULT 3,\n        created_at TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      )\n    `);\n\n    // Create test executions table\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS test_executions (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        scheduled_test_id TEXT NOT NULL,\n        execution_id TEXT NOT NULL,\n        start_time TEXT NOT NULL,\n        end_time TEXT NOT NULL,\n        success BOOLEAN NOT NULL,\n        error TEXT,\n        results TEXT,\n        regression_alerts TEXT,\n        benchmark_results TEXT,\n        created_at TEXT DEFAULT (datetime('now')),\n        FOREIGN KEY (scheduled_test_id) REFERENCES scheduled_tests (id)\n      )\n    `);\n\n    // Create scheduler configuration table\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS scheduler_configuration (\n        id INTEGER PRIMARY KEY CHECK (id = 1),\n        config_json TEXT NOT NULL,\n        updated_at TEXT NOT NULL\n      )\n    `);\n\n    // Create indexes\n    db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_test_executions_scheduled_test_id \n      ON test_executions(scheduled_test_id);\n      \n      CREATE INDEX IF NOT EXISTS idx_test_executions_start_time \n      ON test_executions(start_time);\n    `);\n  }\n\n  private async loadScheduledTests(): Promise<void> {\n    const stmt = db.prepare('SELECT * FROM scheduled_tests');\n    const rows = stmt.all() as any[];\n    \n    for (const row of rows) {\n      const scheduledTest: ScheduledTest = {\n        id: row.id,\n        name: row.name,\n        scenarioId: row.scenario_id,\n        schedule: row.schedule,\n        enabled: Boolean(row.enabled),\n        options: JSON.parse(row.options_json),\n        lastRun: row.last_run ? new Date(row.last_run) : undefined,\n        consecutiveFailures: row.consecutive_failures,\n        maxConsecutiveFailures: row.max_consecutive_failures,\n        createdAt: new Date(row.created_at),\n        updatedAt: new Date(row.updated_at)\n      };\n      \n      this.scheduledTests.set(scheduledTest.id, scheduledTest);\n    }\n    \n    console.log(`Loaded ${rows.length} scheduled tests`);\n  }\n\n  private async saveScheduledTest(test: ScheduledTest): Promise<void> {\n    const stmt = db.prepare(`\n      INSERT OR REPLACE INTO scheduled_tests \n      (id, name, scenario_id, schedule, enabled, options_json, last_run, \n       consecutive_failures, max_consecutive_failures, created_at, updated_at)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n    \n    stmt.run(\n      test.id,\n      test.name,\n      test.scenarioId,\n      test.schedule,\n      test.enabled,\n      JSON.stringify(test.options),\n      test.lastRun?.toISOString(),\n      test.consecutiveFailures,\n      test.maxConsecutiveFailures,\n      test.createdAt.toISOString(),\n      test.updatedAt.toISOString()\n    );\n  }\n\n  private async saveExecution(execution: TestExecutionResult): Promise<void> {\n    const stmt = db.prepare(`\n      INSERT INTO test_executions \n      (scheduled_test_id, execution_id, start_time, end_time, success, error, \n       results, regression_alerts, benchmark_results)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n    \n    stmt.run(\n      execution.scheduledTestId,\n      execution.executionId,\n      execution.startTime.toISOString(),\n      execution.endTime.toISOString(),\n      execution.success,\n      execution.error,\n      execution.results ? JSON.stringify(execution.results) : null,\n      execution.regressionAlerts ? JSON.stringify(execution.regressionAlerts) : null,\n      execution.benchmarkResults ? JSON.stringify(execution.benchmarkResults) : null\n    );\n  }\n\n  private async loadConfiguration(): Promise<void> {\n    try {\n      const stmt = db.prepare('SELECT config_json FROM scheduler_configuration WHERE id = 1');\n      const row = stmt.get() as any;\n      \n      if (row) {\n        this.configuration = { ...this.configuration, ...JSON.parse(row.config_json) };\n      }\n    } catch (error) {\n      console.log('Using default scheduler configuration');\n    }\n  }\n\n  private async saveConfiguration(): Promise<void> {\n    const stmt = db.prepare(`\n      INSERT OR REPLACE INTO scheduler_configuration (id, config_json, updated_at)\n      VALUES (1, ?, ?)\n    `);\n    \n    stmt.run(JSON.stringify(this.configuration), new Date().toISOString());\n  }\n\n  private getDefaultConfiguration(): SchedulerConfiguration {\n    return {\n      enabled: true,\n      maxConcurrentTests: 3,\n      defaultTimeout: 600000, // 10 minutes\n      retryFailedTests: true,\n      maxRetries: 2,\n      retryDelay: 60000, // 1 minute\n      cleanupOldResults: true,\n      resultsRetentionDays: 30,\n      notifications: {\n        enabled: false,\n        channels: ['console'],\n        onSuccess: false,\n        onFailure: true,\n        onRegression: true\n      }\n    };\n  }\n\n  private startAllScheduledTests(): void {\n    for (const scheduledTest of this.scheduledTests.values()) {\n      if (scheduledTest.enabled) {\n        this.startCronJob(scheduledTest);\n      }\n    }\n    console.log('Started all enabled scheduled tests');\n  }\n\n  private stopAllScheduledTests(): void {\n    for (const jobId of this.cronJobs.keys()) {\n      this.stopCronJob(jobId);\n    }\n    console.log('Stopped all scheduled tests');\n  }\n\n  private startCronJob(scheduledTest: ScheduledTest): void {\n    if (this.cronJobs.has(scheduledTest.id)) {\n      this.stopCronJob(scheduledTest.id);\n    }\n\n    try {\n      const job = new CronJob(\n        scheduledTest.schedule,\n        () => {\n          this.executeTest(scheduledTest.id).catch(error => {\n            console.error(`Scheduled test execution failed: ${scheduledTest.name}`, error);\n          });\n        },\n        null,\n        true, // Start immediately\n        'UTC'\n      );\n\n      this.cronJobs.set(scheduledTest.id, job);\n      \n      // Update next run time\n      const nextRun = job.nextDate()?.toJSDate();\n      if (nextRun) {\n        scheduledTest.nextRun = nextRun;\n      }\n\n      console.log(`Started cron job for: ${scheduledTest.name} (${scheduledTest.schedule})`);\n    } catch (error) {\n      console.error(`Failed to start cron job for: ${scheduledTest.name}`, error);\n    }\n  }\n\n  private stopCronJob(scheduledTestId: string): void {\n    const job = this.cronJobs.get(scheduledTestId);\n    if (job) {\n      job.stop();\n      this.cronJobs.delete(scheduledTestId);\n    }\n  }\n\n  private scheduleCleanupJob(): void {\n    // Run cleanup daily at 2 AM UTC\n    new CronJob(\n      '0 2 * * *',\n      () => {\n        this.cleanupOldResults().catch(error => {\n          console.error('Cleanup job failed:', error);\n        });\n      },\n      null,\n      true,\n      'UTC'\n    );\n  }\n\n  private async sendNotification(type: 'success' | 'failure' | 'regression', scheduledTest: ScheduledTest, execution: TestExecutionResult): Promise<void> {\n    // Simple console logging for now\n    // In production, implement actual notification channels (email, Slack, etc.)\n    \n    const message = this.formatNotificationMessage(type, scheduledTest, execution);\n    \n    switch (type) {\n      case 'success':\n        console.log(`✅ ${message}`);\n        break;\n      case 'failure':\n        console.error(`❌ ${message}`);\n        break;\n      case 'regression':\n        console.warn(`⚠️ ${message}`);\n        break;\n    }\n    \n    this.emit('notificationSent', { type, scheduledTest, execution, message });\n  }\n\n  private formatNotificationMessage(type: 'success' | 'failure' | 'regression', scheduledTest: ScheduledTest, execution: TestExecutionResult): string {\n    const duration = execution.endTime.getTime() - execution.startTime.getTime();\n    const durationStr = `${Math.round(duration / 1000)}s`;\n    \n    switch (type) {\n      case 'success':\n        return `Load test '${scheduledTest.name}' completed successfully in ${durationStr}`;\n      case 'failure':\n        return `Load test '${scheduledTest.name}' failed after ${durationStr}: ${execution.error}`;\n      case 'regression':\n        const alertCount = execution.regressionAlerts?.length || 0;\n        return `Load test '${scheduledTest.name}' detected ${alertCount} performance regression(s)`;\n      default:\n        return `Load test '${scheduledTest.name}' completed`;\n    }\n  }\n}\n\n// Export singleton instance\nexport const loadTestScheduler = new LoadTestScheduler();"],"names":["LoadTestScheduler","loadTestScheduler","EventEmitter","initialize","isInitialized","createTables","loadScheduledTests","loadConfiguration","configuration","enabled","startAllScheduledTests","cleanupOldResults","scheduleCleanupJob","emit","console","log","error","createScheduledTest","test","scheduledTest","id","uuidv4","consecutiveFailures","maxConsecutiveFailures","createdAt","Date","updatedAt","CronJob","schedule","Error","saveScheduledTest","scheduledTests","set","startCronJob","updateScheduledTest","updates","get","updatedTest","undefined","stopCronJob","deleteScheduledTest","stmt","db","prepare","run","delete","getScheduledTests","Array","from","values","getScheduledTest","getExecutionHistory","scheduledTestId","limit","offset","query","params","rows","all","map","row","scheduled_test_id","executionId","execution_id","startTime","start_time","endTime","end_time","success","Boolean","results","JSON","parse","regressionAlerts","regression_alerts","benchmarkResults","benchmark_results","executeTest","activeExecutions","has","execution","loadTestResults","loadTestingFramework","runLoadTest","scenarioId","saveBaseline","options","compareBaseline","performanceRegressionDetector","analyzeResults","runBenchmarks","performanceBenchmark","runBenchmarkSuite","name","lastRun","notifications","onSuccess","sendNotification","length","onRegression","message","newFailureCount","onFailure","saveExecution","updateConfiguration","config","saveConfiguration","stopAllScheduledTests","getConfiguration","getStatus","testName","nextExecutions","filter","nextRun","sort","a","b","getTime","slice","scheduledTestsCount","size","activeExecutionsCount","cutoffDate","setDate","getDate","resultsRetentionDays","deleteExecutionsStmt","executionResult","toISOString","deleteAlertsStmt","alertResult","result","deletedExecutions","changes","deletedAlerts","shutdown","removeAllListeners","exec","scenario_id","options_json","last_run","consecutive_failures","max_consecutive_failures","created_at","updated_at","stringify","config_json","getDefaultConfiguration","maxConcurrentTests","defaultTimeout","retryFailedTests","maxRetries","retryDelay","channels","jobId","cronJobs","keys","job","catch","nextDate","toJSDate","stop","type","formatNotificationMessage","warn","duration","durationStr","Math","round","alertCount","Map"],"mappings":"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"}