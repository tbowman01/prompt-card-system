{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/security/LogAggregator.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport fs from 'fs/promises';\nimport path from 'path';\nimport crypto from 'crypto';\nimport { securityMonitor, SecurityEvent } from './SecurityMonitor';\n\nexport interface LogEntry {\n  id: string;\n  timestamp: Date;\n  level: 'debug' | 'info' | 'warn' | 'error' | 'critical';\n  source: string;\n  message: string;\n  metadata?: any;\n  tags: string[];\n  correlationId?: string;\n}\n\nexport interface LogAnalysis {\n  id: string;\n  timestamp: Date;\n  timeRange: { start: Date; end: Date };\n  summary: {\n    totalLogs: number;\n    errorCount: number;\n    warningCount: number;\n    criticalCount: number;\n    uniqueSources: number;\n  };\n  patterns: {\n    type: 'security' | 'performance' | 'error' | 'anomaly';\n    pattern: string;\n    occurrences: number;\n    severity: 'low' | 'medium' | 'high' | 'critical';\n    firstSeen: Date;\n    lastSeen: Date;\n    samples: LogEntry[];\n  }[];\n  recommendations: string[];\n  securityEvents: SecurityEvent[];\n}\n\nexport interface LogFilter {\n  level?: LogEntry['level'][];\n  source?: string[];\n  tags?: string[];\n  timeRange?: { start: Date; end: Date };\n  searchTerm?: string;\n  limit?: number;\n}\n\nexport class LogAggregator extends EventEmitter {\n  private logs: LogEntry[] = [];\n  private analyses: LogAnalysis[] = [];\n  private analysisInterval?: NodeJS.Timeout;\n  private logCleanupInterval?: NodeJS.Timeout;\n  private logFile?: string;\n\n  constructor(private options: {\n    maxLogs?: number;\n    logRetentionDays?: number;\n    analysisIntervalMinutes?: number;\n    enableFileLogging?: boolean;\n    logFilePath?: string;\n    enableRealTimeAnalysis?: boolean;\n  } = {}) {\n    super();\n    \n    const {\n      maxLogs = 50000,\n      logRetentionDays = 30,\n      analysisIntervalMinutes = 15,\n      enableFileLogging = true,\n      logFilePath = './logs/security.log',\n      enableRealTimeAnalysis = true\n    } = options;\n\n    this.options = {\n      maxLogs,\n      logRetentionDays,\n      analysisIntervalMinutes,\n      enableFileLogging,\n      logFilePath,\n      enableRealTimeAnalysis\n    };\n\n    if (enableFileLogging) {\n      this.logFile = logFilePath;\n      this.ensureLogDirectory();\n    }\n\n    this.setupLogCleanup();\n    \n    if (enableRealTimeAnalysis) {\n      this.startPeriodicAnalysis();\n    }\n\n    // Listen to security events\n    securityMonitor.on('securityEvent', (event: SecurityEvent) => {\n      this.logSecurityEvent(event);\n    });\n\n    // Set up Express middleware integration\n    this.setupExpressIntegration();\n  }\n\n  // Logging methods\n  log(entry: Omit<LogEntry, 'id' | 'timestamp'>): void {\n    const logEntry: LogEntry = {\n      id: crypto.randomUUID(),\n      timestamp: new Date(),\n      ...entry\n    };\n\n    this.logs.push(logEntry);\n    this.emit('logEntry', logEntry);\n\n    // Write to file if enabled\n    if (this.options.enableFileLogging && this.logFile) {\n      this.writeToFile(logEntry);\n    }\n\n    // Real-time analysis for critical events\n    if (entry.level === 'critical' || entry.level === 'error') {\n      this.analyzeLogEntry(logEntry);\n    }\n\n    // Maintain log limit\n    if (this.logs.length > this.options.maxLogs!) {\n      this.logs = this.logs.slice(-this.options.maxLogs!);\n    }\n  }\n\n  debug(source: string, message: string, metadata?: any, tags: string[] = []): void {\n    this.log({ level: 'debug', source, message, metadata, tags });\n  }\n\n  info(source: string, message: string, metadata?: any, tags: string[] = []): void {\n    this.log({ level: 'info', source, message, metadata, tags });\n  }\n\n  warn(source: string, message: string, metadata?: any, tags: string[] = []): void {\n    this.log({ level: 'warn', source, message, metadata, tags });\n  }\n\n  error(source: string, message: string, metadata?: any, tags: string[] = []): void {\n    this.log({ level: 'error', source, message, metadata, tags });\n  }\n\n  critical(source: string, message: string, metadata?: any, tags: string[] = []): void {\n    this.log({ level: 'critical', source, message, metadata, tags });\n  }\n\n  // Security-specific logging\n  private logSecurityEvent(event: SecurityEvent): void {\n    this.log({\n      level: event.severity === 'critical' ? 'critical' : \n             event.severity === 'high' ? 'error' :\n             event.severity === 'medium' ? 'warn' : 'info',\n      source: 'security-monitor',\n      message: `Security Event: ${event.message}`,\n      metadata: {\n        eventId: event.id,\n        eventType: event.type,\n        eventSource: event.source,\n        eventDetails: event.details,\n        resolved: event.resolved\n      },\n      tags: ['security', event.type, event.severity],\n      correlationId: event.id\n    });\n  }\n\n  // Log retrieval and filtering\n  getLogs(filter?: LogFilter): LogEntry[] {\n    let filteredLogs = [...this.logs];\n\n    if (filter) {\n      if (filter.level) {\n        filteredLogs = filteredLogs.filter(log => filter.level!.includes(log.level));\n      }\n      if (filter.source) {\n        filteredLogs = filteredLogs.filter(log => \n          filter.source!.some(source => log.source.includes(source))\n        );\n      }\n      if (filter.tags) {\n        filteredLogs = filteredLogs.filter(log => \n          filter.tags!.some(tag => log.tags.includes(tag))\n        );\n      }\n      if (filter.timeRange) {\n        filteredLogs = filteredLogs.filter(log => \n          log.timestamp >= filter.timeRange!.start && \n          log.timestamp <= filter.timeRange!.end\n        );\n      }\n      if (filter.searchTerm) {\n        const term = filter.searchTerm.toLowerCase();\n        filteredLogs = filteredLogs.filter(log => \n          log.message.toLowerCase().includes(term) ||\n          log.source.toLowerCase().includes(term) ||\n          log.tags.some(tag => tag.toLowerCase().includes(term))\n        );\n      }\n      if (filter.limit) {\n        filteredLogs = filteredLogs.slice(-filter.limit);\n      }\n    }\n\n    return filteredLogs.sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime());\n  }\n\n  // Log analysis\n  async analyzeLogEntry(entry: LogEntry): Promise<void> {\n    // Real-time analysis for immediate threats\n    const securityPatterns = [\n      {\n        pattern: /failed.*login|authentication.*failed|invalid.*credentials/i,\n        type: 'security' as const,\n        severity: 'high' as const,\n        description: 'Authentication failure detected'\n      },\n      {\n        pattern: /sql.*injection|xss|cross.*site|csrf/i,\n        type: 'security' as const,\n        severity: 'critical' as const,\n        description: 'Potential security attack detected'\n      },\n      {\n        pattern: /rate.*limit|too.*many.*requests|ddos/i,\n        type: 'security' as const,\n        severity: 'medium' as const,\n        description: 'Potential abuse or DoS attack'\n      },\n      {\n        pattern: /memory.*leak|out.*of.*memory|heap.*overflow/i,\n        type: 'performance' as const,\n        severity: 'high' as const,\n        description: 'Memory-related issue detected'\n      },\n      {\n        pattern: /unauthorized|forbidden|access.*denied/i,\n        type: 'security' as const,\n        severity: 'medium' as const,\n        description: 'Unauthorized access attempt'\n      }\n    ];\n\n    for (const patternDef of securityPatterns) {\n      if (patternDef.pattern.test(entry.message)) {\n        if (patternDef.type === 'security') {\n          securityMonitor.logSecurityEvent({\n            severity: patternDef.severity,\n            type: 'intrusion',\n            source: `log-analyzer:${entry.source}`,\n            message: `${patternDef.description}: ${entry.message}`,\n            details: {\n              logEntry: entry,\n              pattern: patternDef.pattern.source\n            },\n            resolved: false\n          });\n        }\n\n        this.emit('patternDetected', {\n          pattern: patternDef,\n          logEntry: entry,\n          timestamp: new Date()\n        });\n      }\n    }\n  }\n\n  async performLogAnalysis(timeRange?: { start: Date; end: Date }): Promise<LogAnalysis> {\n    const now = new Date();\n    const range = timeRange || {\n      start: new Date(now.getTime() - 24 * 60 * 60 * 1000), // Last 24 hours\n      end: now\n    };\n\n    const relevantLogs = this.getLogs({\n      timeRange: range\n    });\n\n    const analysis: LogAnalysis = {\n      id: crypto.randomUUID(),\n      timestamp: now,\n      timeRange: range,\n      summary: {\n        totalLogs: relevantLogs.length,\n        errorCount: relevantLogs.filter(l => l.level === 'error').length,\n        warningCount: relevantLogs.filter(l => l.level === 'warn').length,\n        criticalCount: relevantLogs.filter(l => l.level === 'critical').length,\n        uniqueSources: new Set(relevantLogs.map(l => l.source)).size\n      },\n      patterns: [],\n      recommendations: [],\n      securityEvents: securityMonitor.getSecurityEvents({\n        since: range.start\n      })\n    };\n\n    // Pattern detection\n    const patterns = this.detectPatterns(relevantLogs);\n    analysis.patterns = patterns;\n\n    // Generate recommendations\n    analysis.recommendations = this.generateRecommendations(analysis);\n\n    this.analyses.push(analysis);\n    this.emit('analysisComplete', analysis);\n\n    return analysis;\n  }\n\n  private detectPatterns(logs: LogEntry[]): LogAnalysis['patterns'] {\n    const patterns: LogAnalysis['patterns'] = [];\n    const patternMap = new Map<string, {\n      count: number;\n      severity: 'low' | 'medium' | 'high' | 'critical';\n      type: 'security' | 'performance' | 'error' | 'anomaly';\n      firstSeen: Date;\n      lastSeen: Date;\n      samples: LogEntry[];\n    }>();\n\n    // Define pattern detection rules\n    const rules = [\n      {\n        name: 'repeated_errors',\n        regex: /(error|exception|fail)/i,\n        type: 'error' as const,\n        minOccurrences: 5\n      },\n      {\n        name: 'security_violations',\n        regex: /(unauthorized|forbidden|access.*denied|authentication.*failed)/i,\n        type: 'security' as const,\n        minOccurrences: 3\n      },\n      {\n        name: 'performance_issues',\n        regex: /(slow|timeout|high.*latency|memory.*usage)/i,\n        type: 'performance' as const,\n        minOccurrences: 3\n      },\n      {\n        name: 'anomalous_activity',\n        regex: /(unusual|suspicious|anomaly|unexpected)/i,\n        type: 'anomaly' as const,\n        minOccurrences: 2\n      }\n    ];\n\n    // Analyze logs for patterns\n    rules.forEach(rule => {\n      const matchingLogs = logs.filter(log => rule.regex.test(log.message));\n      \n      if (matchingLogs.length >= rule.minOccurrences) {\n        const severity = this.calculatePatternSeverity(matchingLogs.length, rule.type);\n        \n        patterns.push({\n          type: rule.type,\n          pattern: rule.name,\n          occurrences: matchingLogs.length,\n          severity,\n          firstSeen: matchingLogs[matchingLogs.length - 1].timestamp,\n          lastSeen: matchingLogs[0].timestamp,\n          samples: matchingLogs.slice(0, 5) // First 5 samples\n        });\n      }\n    });\n\n    return patterns;\n  }\n\n  private calculatePatternSeverity(occurrences: number, type: string): 'low' | 'medium' | 'high' | 'critical' {\n    if (type === 'security') {\n      if (occurrences >= 20) return 'critical';\n      if (occurrences >= 10) return 'high';\n      if (occurrences >= 5) return 'medium';\n      return 'low';\n    }\n    \n    if (type === 'error') {\n      if (occurrences >= 50) return 'critical';\n      if (occurrences >= 25) return 'high';\n      if (occurrences >= 10) return 'medium';\n      return 'low';\n    }\n    \n    // Default severity calculation\n    if (occurrences >= 30) return 'high';\n    if (occurrences >= 15) return 'medium';\n    return 'low';\n  }\n\n  private generateRecommendations(analysis: LogAnalysis): string[] {\n    const recommendations: string[] = [];\n\n    // Security recommendations\n    const securityPatterns = analysis.patterns.filter(p => p.type === 'security');\n    if (securityPatterns.length > 0) {\n      recommendations.push('Review and investigate security-related log patterns');\n      recommendations.push('Consider implementing additional security measures');\n      \n      const criticalSecurity = securityPatterns.filter(p => p.severity === 'critical');\n      if (criticalSecurity.length > 0) {\n        recommendations.push('URGENT: Critical security patterns detected - immediate investigation required');\n      }\n    }\n\n    // Error recommendations\n    const errorPatterns = analysis.patterns.filter(p => p.type === 'error');\n    if (errorPatterns.length > 0) {\n      recommendations.push('Investigate recurring error patterns to improve system stability');\n    }\n\n    // Performance recommendations\n    const perfPatterns = analysis.patterns.filter(p => p.type === 'performance');\n    if (perfPatterns.length > 0) {\n      recommendations.push('Review performance-related issues and optimize system resources');\n    }\n\n    // General recommendations\n    if (analysis.summary.criticalCount > 0) {\n      recommendations.push('Address all critical-level log entries immediately');\n    }\n    \n    if (analysis.summary.errorCount > analysis.summary.totalLogs * 0.1) {\n      recommendations.push('High error rate detected - consider system health review');\n    }\n\n    return recommendations;\n  }\n\n  // Express middleware integration\n  private setupExpressIntegration(): void {\n    // This would be used in the main server setup\n  }\n\n  getExpressMiddleware() {\n    return (req: any, res: any, next: any) => {\n      const startTime = Date.now();\n      const correlationId = crypto.randomUUID();\n      \n      req.correlationId = correlationId;\n      \n      // Log request\n      this.info('express', `${req.method} ${req.path}`, {\n        method: req.method,\n        path: req.path,\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        correlationId\n      }, ['request', 'http']);\n\n      // Intercept response\n      const originalSend = res.send;\n      res.send = function(data: any) {\n        const responseTime = Date.now() - startTime;\n        const level = res.statusCode >= 500 ? 'error' : \n                     res.statusCode >= 400 ? 'warn' : 'info';\n        \n        // Use the log aggregator instance\n        (req.app.get('logAggregator') as LogAggregator).log({\n          level,\n          source: 'express',\n          message: `${req.method} ${req.path} - ${res.statusCode}`,\n          metadata: {\n            method: req.method,\n            path: req.path,\n            statusCode: res.statusCode,\n            responseTime,\n            ip: req.ip,\n            correlationId\n          },\n          tags: ['response', 'http'],\n          correlationId\n        });\n        \n        return originalSend.call(this, data);\n      };\n\n      next();\n    };\n  }\n\n  // File operations\n  private async ensureLogDirectory(): Promise<void> {\n    if (this.logFile) {\n      const logDir = path.dirname(this.logFile);\n      try {\n        await fs.mkdir(logDir, { recursive: true });\n      } catch (error) {\n        console.error('Failed to create log directory:', error);\n      }\n    }\n  }\n\n  private async writeToFile(entry: LogEntry): Promise<void> {\n    if (!this.logFile) return;\n    \n    try {\n      const logLine = JSON.stringify({\n        timestamp: entry.timestamp.toISOString(),\n        level: entry.level,\n        source: entry.source,\n        message: entry.message,\n        metadata: entry.metadata,\n        tags: entry.tags,\n        correlationId: entry.correlationId\n      }) + '\\n';\n      \n      await fs.appendFile(this.logFile, logLine);\n    } catch (error) {\n      console.error('Failed to write to log file:', error);\n    }\n  }\n\n  // Cleanup and maintenance\n  private setupLogCleanup(): void {\n    this.logCleanupInterval = setInterval(() => {\n      const cutoffDate = new Date();\n      cutoffDate.setDate(cutoffDate.getDate() - this.options.logRetentionDays!);\n      \n      this.logs = this.logs.filter(log => log.timestamp >= cutoffDate);\n      this.analyses = this.analyses.filter(analysis => analysis.timestamp >= cutoffDate);\n    }, 24 * 60 * 60 * 1000); // Daily cleanup\n  }\n\n  private startPeriodicAnalysis(): void {\n    this.analysisInterval = setInterval(async () => {\n      try {\n        await this.performLogAnalysis();\n      } catch (error) {\n        this.error('log-aggregator', `Periodic analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`, { error });\n      }\n    }, this.options.analysisIntervalMinutes! * 60 * 1000);\n  }\n\n  // Analytics and reporting\n  getAnalyses(limit = 10): LogAnalysis[] {\n    return this.analyses\n      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())\n      .slice(0, limit);\n  }\n\n  getLogStatistics(): {\n    totalLogs: number;\n    logsByLevel: Record<LogEntry['level'], number>;\n    logsBySources: Record<string, number>;\n    recentActivity: { hour: string; count: number }[];\n  } {\n    const stats = {\n      totalLogs: this.logs.length,\n      logsByLevel: {\n        debug: 0,\n        info: 0,\n        warn: 0,\n        error: 0,\n        critical: 0\n      } as Record<LogEntry['level'], number>,\n      logsBySources: {} as Record<string, number>,\n      recentActivity: [] as { hour: string; count: number }[]\n    };\n\n    // Count by level\n    this.logs.forEach(log => {\n      stats.logsByLevel[log.level]++;\n      \n      if (!stats.logsBySources[log.source]) {\n        stats.logsBySources[log.source] = 0;\n      }\n      stats.logsBySources[log.source]++;\n    });\n\n    // Recent activity (last 24 hours by hour)\n    const now = new Date();\n    for (let i = 23; i >= 0; i--) {\n      const hour = new Date(now.getTime() - i * 60 * 60 * 1000);\n      const hourStart = new Date(hour.getFullYear(), hour.getMonth(), hour.getDate(), hour.getHours());\n      const hourEnd = new Date(hourStart.getTime() + 60 * 60 * 1000);\n      \n      const count = this.logs.filter(log => \n        log.timestamp >= hourStart && log.timestamp < hourEnd\n      ).length;\n      \n      stats.recentActivity.push({\n        hour: hourStart.toISOString().substring(11, 16), // HH:MM format\n        count\n      });\n    }\n\n    return stats;\n  }\n\n  // Cleanup resources\n  destroy(): void {\n    if (this.analysisInterval) {\n      clearInterval(this.analysisInterval);\n    }\n    if (this.logCleanupInterval) {\n      clearInterval(this.logCleanupInterval);\n    }\n    this.removeAllListeners();\n  }\n}\n\nexport const logAggregator = new LogAggregator({\n  maxLogs: 50000,\n  logRetentionDays: 30,\n  analysisIntervalMinutes: 15,\n  enableFileLogging: true,\n  logFilePath: './logs/security.log',\n  enableRealTimeAnalysis: true\n});"],"names":["LogAggregator","logAggregator","EventEmitter","log","entry","logEntry","id","crypto","randomUUID","timestamp","Date","logs","push","emit","options","enableFileLogging","logFile","writeToFile","level","analyzeLogEntry","length","maxLogs","slice","debug","source","message","metadata","tags","info","warn","error","critical","logSecurityEvent","event","severity","eventId","eventType","type","eventSource","eventDetails","details","resolved","correlationId","getLogs","filter","filteredLogs","includes","some","tag","timeRange","start","end","searchTerm","term","toLowerCase","limit","sort","a","b","getTime","securityPatterns","pattern","description","patternDef","test","securityMonitor","performLogAnalysis","now","range","relevantLogs","analysis","summary","totalLogs","errorCount","l","warningCount","criticalCount","uniqueSources","Set","map","size","patterns","recommendations","securityEvents","getSecurityEvents","since","detectPatterns","generateRecommendations","analyses","patternMap","Map","rules","name","regex","minOccurrences","forEach","rule","matchingLogs","calculatePatternSeverity","occurrences","firstSeen","lastSeen","samples","p","criticalSecurity","errorPatterns","perfPatterns","setupExpressIntegration","getExpressMiddleware","req","res","next","startTime","method","path","ip","userAgent","get","originalSend","send","data","responseTime","statusCode","app","call","ensureLogDirectory","logDir","dirname","fs","mkdir","recursive","console","logLine","JSON","stringify","toISOString","appendFile","setupLogCleanup","logCleanupInterval","setInterval","cutoffDate","setDate","getDate","logRetentionDays","startPeriodicAnalysis","analysisInterval","Error","analysisIntervalMinutes","getAnalyses","getLogStatistics","stats","logsByLevel","logsBySources","recentActivity","i","hour","hourStart","getFullYear","getMonth","getHours","hourEnd","count","substring","destroy","clearInterval","removeAllListeners","logFilePath","enableRealTimeAnalysis","on"],"mappings":"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"}