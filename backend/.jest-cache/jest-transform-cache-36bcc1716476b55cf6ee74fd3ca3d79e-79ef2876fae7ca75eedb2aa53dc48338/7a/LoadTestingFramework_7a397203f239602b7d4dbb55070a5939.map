{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/performance/LoadTestingFramework.ts"],"sourcesContent":["import { EventEmitter } from 'events';\nimport { performance } from 'perf_hooks';\nimport { Worker, isMainThread, parentPort, workerData } from 'worker_threads';\nimport { setTimeout as setTimeoutPromise } from 'timers/promises';\nimport { promisify } from 'util';\nimport axios from 'axios';\nimport { v4 as uuidv4 } from 'uuid';\nimport { performanceMonitor } from './PerformanceMonitor';\nimport { db } from '../../database/connection';\nimport fs from 'fs/promises';\nimport path from 'path';\n\nexport interface LoadTestScenario {\n  id: string;\n  name: string;\n  description: string;\n  config: {\n    baseUrl: string;\n    endpoints: EndpointConfig[];\n    users: UserConfig;\n    duration: DurationConfig;\n    thresholds: ThresholdConfig;\n    environment: EnvironmentConfig;\n  };\n  hooks?: {\n    beforeScenario?: () => Promise<void>;\n    afterScenario?: () => Promise<void>;\n    beforeRequest?: (context: RequestContext) => Promise<void>;\n    afterRequest?: (context: RequestContext, result: RequestResult) => Promise<void>;\n  };\n}\n\nexport interface EndpointConfig {\n  path: string;\n  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';\n  weight: number; // Relative frequency (0-100)\n  headers?: Record<string, string>;\n  body?: any;\n  timeout?: number;\n  params?: Record<string, any>;\n  validation?: {\n    statusCode?: number[];\n    responseTime?: number;\n    bodyContains?: string[];\n    headerExists?: string[];\n  };\n}\n\nexport interface UserConfig {\n  concurrent: number;\n  rampUp: {\n    duration: number; // seconds\n    strategy: 'linear' | 'exponential' | 'step';\n  };\n  rampDown: {\n    duration: number;\n    strategy: 'linear' | 'exponential' | 'immediate';\n  };\n  thinkTime: {\n    min: number;\n    max: number;\n    distribution: 'uniform' | 'normal' | 'exponential';\n  };\n}\n\nexport interface DurationConfig {\n  total: number; // seconds\n  warmup?: number; // seconds\n  cooldown?: number; // seconds\n}\n\nexport interface ThresholdConfig {\n  responseTime: {\n    p95: number;\n    p99: number;\n    max: number;\n  };\n  errorRate: {\n    max: number; // percentage\n  };\n  throughput: {\n    min: number; // requests per second\n  };\n}\n\nexport interface EnvironmentConfig {\n  variables?: Record<string, string>;\n  dataFiles?: string[];\n  concurrent?: boolean;\n  keepAlive?: boolean;\n  compression?: boolean;\n}\n\nexport interface RequestContext {\n  userId: string;\n  scenario: LoadTestScenario;\n  endpoint: EndpointConfig;\n  iteration: number;\n  startTime: number;\n  environment: Record<string, any>;\n}\n\nexport interface RequestResult {\n  success: boolean;\n  statusCode: number;\n  responseTime: number;\n  responseSize: number;\n  errorMessage?: string;\n  timestamp: number;\n  userId: string;\n  endpoint: string;\n  headers: Record<string, string>;\n}\n\nexport interface LoadTestResults {\n  scenario: LoadTestScenario;\n  summary: {\n    startTime: Date;\n    endTime: Date;\n    duration: number;\n    totalRequests: number;\n    successfulRequests: number;\n    failedRequests: number;\n    requestsPerSecond: number;\n    bytesReceived: number;\n    bytesSent: number;\n  };\n  metrics: {\n    responseTime: {\n      min: number;\n      max: number;\n      avg: number;\n      p50: number;\n      p95: number;\n      p99: number;\n    };\n    throughput: {\n      avg: number;\n      peak: number;\n      min: number;\n    };\n    errorRate: number;\n    concurrency: {\n      avg: number;\n      peak: number;\n    };\n  };\n  timeline: TimelinePoint[];\n  errors: ErrorSummary[];\n  thresholdResults: ThresholdResult[];\n  recommendations: string[];\n}\n\nexport interface TimelinePoint {\n  timestamp: number;\n  activeUsers: number;\n  requestsPerSecond: number;\n  avgResponseTime: number;\n  errorRate: number;\n  p95ResponseTime: number;\n}\n\nexport interface ErrorSummary {\n  type: string;\n  message: string;\n  count: number;\n  percentage: number;\n  endpoints: string[];\n  firstOccurrence: number;\n  lastOccurrence: number;\n}\n\nexport interface ThresholdResult {\n  name: string;\n  value: number;\n  threshold: number;\n  passed: boolean;\n  severity: 'info' | 'warning' | 'error';\n}\n\nclass WorkerPool {\n  private workers: Worker[] = [];\n  private available: Worker[] = [];\n  private busy: Set<Worker> = new Set();\n  private maxWorkers: number;\n\n  constructor(maxWorkers: number = 4) {\n    this.maxWorkers = maxWorkers;\n  }\n\n  async getWorker(): Promise<Worker> {\n    if (this.available.length > 0) {\n      const worker = this.available.pop()!;\n      this.busy.add(worker);\n      return worker;\n    }\n\n    if (this.workers.length < this.maxWorkers) {\n      const worker = new Worker(__filename, {\n        workerData: { isWorker: true }\n      });\n      this.workers.push(worker);\n      this.busy.add(worker);\n      return worker;\n    }\n\n    // Wait for available worker\n    return new Promise((resolve) => {\n      const checkAvailable = () => {\n        if (this.available.length > 0) {\n          const worker = this.available.pop()!;\n          this.busy.add(worker);\n          resolve(worker);\n        } else {\n          setTimeout(() => checkAvailable(), 10);\n        }\n      };\n      checkAvailable();\n    });\n  }\n\n  releaseWorker(worker: Worker): void {\n    this.busy.delete(worker);\n    this.available.push(worker);\n  }\n\n  async terminate(): Promise<void> {\n    await Promise.all(this.workers.map(worker => worker.terminate()));\n    this.workers = [];\n    this.available = [];\n    this.busy.clear();\n  }\n}\n\nexport class LoadTestingFramework extends EventEmitter {\n  private isRunning: boolean = false;\n  private currentTest: LoadTestResults | null = null;\n  private workerPool: WorkerPool;\n  private scenarios: Map<string, LoadTestScenario> = new Map();\n  private baselines: Map<string, LoadTestResults> = new Map();\n  private regressionThresholds: Map<string, number> = new Map();\n\n  constructor() {\n    super();\n    this.workerPool = new WorkerPool();\n    this.setupDefaultScenarios();\n    this.setupRegressionThresholds();\n  }\n\n  /**\n   * Register a load test scenario\n   */\n  registerScenario(scenario: LoadTestScenario): void {\n    this.scenarios.set(scenario.id, scenario);\n    this.emit('scenarioRegistered', scenario);\n  }\n\n  /**\n   * Get all registered scenarios\n   */\n  getScenarios(): LoadTestScenario[] {\n    return Array.from(this.scenarios.values());\n  }\n\n  /**\n   * Run a load test scenario\n   */\n  async runLoadTest(scenarioId: string, options?: {\n    dryRun?: boolean;\n    saveBaseline?: boolean;\n    compareBaseline?: boolean;\n  }): Promise<LoadTestResults> {\n    if (this.isRunning) {\n      throw new Error('Load test is already running');\n    }\n\n    const scenario = this.scenarios.get(scenarioId);\n    if (!scenario) {\n      throw new Error(`Scenario not found: ${scenarioId}`);\n    }\n\n    this.isRunning = true;\n    this.emit('testStarted', scenario);\n\n    try {\n      if (options?.dryRun) {\n        return await this.runDryRun(scenario);\n      }\n\n      const results = await this.executeLoadTest(scenario);\n      \n      if (options?.saveBaseline) {\n        await this.saveBaseline(scenarioId, results);\n      }\n\n      if (options?.compareBaseline) {\n        await this.compareWithBaseline(scenarioId, results);\n      }\n\n      await this.saveResults(results);\n      this.emit('testCompleted', results);\n      \n      return results;\n    } finally {\n      this.isRunning = false;\n      this.currentTest = null;\n    }\n  }\n\n  /**\n   * Run performance regression test\n   */\n  async runRegressionTest(scenarioIds: string[]): Promise<{\n    passed: boolean;\n    results: LoadTestResults[];\n    regressions: RegressionResult[];\n  }> {\n    const results: LoadTestResults[] = [];\n    const regressions: RegressionResult[] = [];\n\n    for (const scenarioId of scenarioIds) {\n      const result = await this.runLoadTest(scenarioId, { compareBaseline: true });\n      results.push(result);\n\n      const regression = await this.detectRegression(scenarioId, result);\n      if (regression) {\n        regressions.push(regression);\n      }\n    }\n\n    const passed = regressions.length === 0;\n    this.emit('regressionTestCompleted', { passed, results, regressions });\n\n    return { passed, results, regressions };\n  }\n\n  /**\n   * Get test status\n   */\n  getStatus(): {\n    isRunning: boolean;\n    currentTest?: {\n      scenario: string;\n      progress: number;\n      elapsedTime: number;\n      estimatedTimeRemaining: number;\n    };\n  } {\n    if (!this.isRunning || !this.currentTest) {\n      return { isRunning: false };\n    }\n\n    const elapsed = Date.now() - this.currentTest.summary.startTime.getTime();\n    const totalDuration = this.currentTest.scenario.config.duration.total * 1000;\n    const progress = Math.min((elapsed / totalDuration) * 100, 100);\n    const estimatedTimeRemaining = Math.max(totalDuration - elapsed, 0);\n\n    return {\n      isRunning: true,\n      currentTest: {\n        scenario: this.currentTest.scenario.name,\n        progress,\n        elapsedTime: elapsed,\n        estimatedTimeRemaining\n      }\n    };\n  }\n\n  /**\n   * Stop current test\n   */\n  async stopTest(): Promise<void> {\n    if (!this.isRunning) {\n      return;\n    }\n\n    this.emit('testStopping');\n    this.isRunning = false;\n    await this.workerPool.terminate();\n    this.emit('testStopped');\n  }\n\n  /**\n   * Execute the actual load test\n   */\n  private async executeLoadTest(scenario: LoadTestScenario): Promise<LoadTestResults> {\n    const startTime = new Date();\n    const config = scenario.config;\n    const results: LoadTestResults = {\n      scenario,\n      summary: {\n        startTime,\n        endTime: new Date(),\n        duration: 0,\n        totalRequests: 0,\n        successfulRequests: 0,\n        failedRequests: 0,\n        requestsPerSecond: 0,\n        bytesReceived: 0,\n        bytesSent: 0\n      },\n      metrics: {\n        responseTime: { min: 0, max: 0, avg: 0, p50: 0, p95: 0, p99: 0 },\n        throughput: { avg: 0, peak: 0, min: 0 },\n        errorRate: 0,\n        concurrency: { avg: 0, peak: 0 }\n      },\n      timeline: [],\n      errors: [],\n      thresholdResults: [],\n      recommendations: []\n    };\n\n    this.currentTest = results;\n\n    // Execute hooks\n    if (scenario.hooks?.beforeScenario) {\n      await scenario.hooks.beforeScenario();\n    }\n\n    const requestResults: RequestResult[] = [];\n    const userPromises: Promise<void>[] = [];\n    const timelineData: TimelinePoint[] = [];\n\n    // Start timeline monitoring\n    const timelineInterval = setInterval(() => {\n      const now = Date.now();\n      const recentResults = requestResults.filter(r => now - r.timestamp < 1000);\n      \n      const timelinePoint: TimelinePoint = {\n        timestamp: now,\n        activeUsers: userPromises.filter(p => !this.isPromiseSettled(p)).length,\n        requestsPerSecond: recentResults.length,\n        avgResponseTime: recentResults.reduce((sum, r) => sum + r.responseTime, 0) / recentResults.length || 0,\n        errorRate: (recentResults.filter(r => !r.success).length / recentResults.length) * 100 || 0,\n        p95ResponseTime: this.calculatePercentile(recentResults.map(r => r.responseTime), 95)\n      };\n      \n      timelineData.push(timelinePoint);\n      results.timeline = timelineData;\n      \n      this.emit('timelineUpdate', timelinePoint);\n    }, 1000);\n\n    try {\n      // Ramp up users\n      await this.rampUpUsers(scenario, async (userId: string) => {\n        const userPromise = this.simulateUser(userId, scenario, requestResults);\n        userPromises.push(userPromise);\n        return userPromise;\n      });\n\n      // Wait for test duration\n      await setTimeoutPromise(config.duration.total * 1000);\n\n      // Stop all users\n      this.isRunning = false;\n      await Promise.allSettled(userPromises);\n\n    } finally {\n      clearInterval(timelineInterval);\n    }\n\n    // Execute hooks\n    if (scenario.hooks?.afterScenario) {\n      await scenario.hooks.afterScenario();\n    }\n\n    // Calculate final results\n    const endTime = new Date();\n    results.summary.endTime = endTime;\n    results.summary.duration = (endTime.getTime() - startTime.getTime()) / 1000;\n    results.summary.totalRequests = requestResults.length;\n    results.summary.successfulRequests = requestResults.filter(r => r.success).length;\n    results.summary.failedRequests = requestResults.filter(r => !r.success).length;\n    results.summary.requestsPerSecond = results.summary.totalRequests / results.summary.duration;\n    results.summary.bytesReceived = requestResults.reduce((sum, r) => sum + r.responseSize, 0);\n\n    // Calculate metrics\n    const responseTimes = requestResults.map(r => r.responseTime);\n    if (responseTimes.length > 0) {\n      results.metrics.responseTime = {\n        min: Math.min(...responseTimes),\n        max: Math.max(...responseTimes),\n        avg: responseTimes.reduce((sum, t) => sum + t, 0) / responseTimes.length,\n        p50: this.calculatePercentile(responseTimes, 50),\n        p95: this.calculatePercentile(responseTimes, 95),\n        p99: this.calculatePercentile(responseTimes, 99)\n      };\n    }\n\n    results.metrics.throughput = {\n      avg: results.summary.requestsPerSecond,\n      peak: Math.max(...timelineData.map(t => t.requestsPerSecond)),\n      min: Math.min(...timelineData.map(t => t.requestsPerSecond))\n    };\n\n    results.metrics.errorRate = (results.summary.failedRequests / results.summary.totalRequests) * 100;\n    \n    results.metrics.concurrency = {\n      avg: timelineData.reduce((sum, t) => sum + t.activeUsers, 0) / timelineData.length,\n      peak: Math.max(...timelineData.map(t => t.activeUsers))\n    };\n\n    // Analyze errors\n    results.errors = this.analyzeErrors(requestResults);\n\n    // Check thresholds\n    results.thresholdResults = this.checkThresholds(scenario, results);\n\n    // Generate recommendations\n    results.recommendations = this.generateRecommendations(results);\n\n    return results;\n  }\n\n  /**\n   * Ramp up users according to strategy\n   */\n  private async rampUpUsers(\n    scenario: LoadTestScenario,\n    createUser: (userId: string) => Promise<void>\n  ): Promise<void> {\n    const config = scenario.config.users;\n    const rampUpDuration = config.rampUp.duration * 1000;\n    const totalUsers = config.concurrent;\n    \n    for (let i = 0; i < totalUsers; i++) {\n      const userId = uuidv4();\n      await createUser(userId);\n      \n      // Calculate delay based on strategy\n      let delay = 0;\n      switch (config.rampUp.strategy) {\n        case 'linear':\n          delay = rampUpDuration / totalUsers;\n          break;\n        case 'exponential':\n          delay = (rampUpDuration / totalUsers) * Math.pow(1.1, i);\n          break;\n        case 'step':\n          delay = i % 5 === 0 ? rampUpDuration / (totalUsers / 5) : 0;\n          break;\n      }\n      \n      if (delay > 0 && i < totalUsers - 1) {\n        await setTimeoutPromise(delay);\n      }\n    }\n  }\n\n  /**\n   * Simulate a virtual user\n   */\n  private async simulateUser(\n    userId: string,\n    scenario: LoadTestScenario,\n    results: RequestResult[]\n  ): Promise<void> {\n    const config = scenario.config;\n    const environment = { ...config.environment.variables };\n\n    while (this.isRunning) {\n      // Select endpoint based on weight\n      const endpoint = this.selectEndpoint(config.endpoints);\n      \n      const context: RequestContext = {\n        userId,\n        scenario,\n        endpoint,\n        iteration: results.filter(r => r.userId === userId).length + 1,\n        startTime: Date.now(),\n        environment\n      };\n\n      // Execute hooks\n      if (scenario.hooks?.beforeRequest) {\n        await scenario.hooks.beforeRequest(context);\n      }\n\n      // Make request\n      const result = await this.makeRequest(context);\n      results.push(result);\n\n      // Execute hooks\n      if (scenario.hooks?.afterRequest) {\n        await scenario.hooks.afterRequest(context, result);\n      }\n\n      // Think time\n      const thinkTime = this.calculateThinkTime(config.users.thinkTime);\n      if (thinkTime > 0) {\n        await setTimeoutPromise(thinkTime);\n      }\n    }\n  }\n\n  /**\n   * Make HTTP request\n   */\n  private async makeRequest(context: RequestContext): Promise<RequestResult> {\n    const startTime = performance.now();\n    const endpoint = context.endpoint;\n    const url = `${context.scenario.config.baseUrl}${endpoint.path}`;\n    \n    try {\n      const response = await axios({\n        method: endpoint.method,\n        url,\n        headers: endpoint.headers,\n        data: endpoint.body,\n        params: endpoint.params,\n        timeout: endpoint.timeout || 30000,\n        validateStatus: () => true // Don't throw on status codes\n      });\n\n      const responseTime = performance.now() - startTime;\n      const responseSize = JSON.stringify(response.data).length;\n\n      // Validate response\n      let success = true;\n      if (endpoint.validation) {\n        if (endpoint.validation.statusCode && \n            !endpoint.validation.statusCode.includes(response.status)) {\n          success = false;\n        }\n        if (endpoint.validation.responseTime && \n            responseTime > endpoint.validation.responseTime) {\n          success = false;\n        }\n        if (endpoint.validation.bodyContains) {\n          const body = JSON.stringify(response.data);\n          success = endpoint.validation.bodyContains.every(text => body.includes(text));\n        }\n        if (endpoint.validation.headerExists) {\n          success = endpoint.validation.headerExists.every(header => \n            response.headers[header] !== undefined);\n        }\n      } else {\n        success = response.status >= 200 && response.status < 400;\n      }\n\n      return {\n        success,\n        statusCode: response.status,\n        responseTime,\n        responseSize,\n        timestamp: Date.now(),\n        userId: context.userId,\n        endpoint: endpoint.path,\n        headers: Object.fromEntries(\n          Object.entries(response.headers).map(([key, value]) => [key, String(value)])\n        )\n      };\n\n    } catch (error) {\n      const responseTime = performance.now() - startTime;\n      \n      return {\n        success: false,\n        statusCode: 0,\n        responseTime,\n        responseSize: 0,\n        errorMessage: error.message,\n        timestamp: Date.now(),\n        userId: context.userId,\n        endpoint: endpoint.path,\n        headers: {}\n      };\n    }\n  }\n\n  /**\n   * Setup default load test scenarios\n   */\n  private setupDefaultScenarios(): void {\n    // API Performance Test\n    this.registerScenario({\n      id: 'api-performance',\n      name: 'API Performance Test',\n      description: 'General API performance testing',\n      config: {\n        baseUrl: process.env.BASE_URL || 'http://localhost:3001',\n        endpoints: [\n          {\n            path: '/api/health',\n            method: 'GET',\n            weight: 30,\n            validation: { statusCode: [200] }\n          },\n          {\n            path: '/api/performance/overview',\n            method: 'GET',\n            weight: 25,\n            validation: { statusCode: [200] }\n          },\n          {\n            path: '/api/analytics/metrics',\n            method: 'GET',\n            weight: 20,\n            validation: { statusCode: [200] }\n          },\n          {\n            path: '/api/prompt-cards',\n            method: 'GET',\n            weight: 15,\n            validation: { statusCode: [200] }\n          },\n          {\n            path: '/api/test-cases',\n            method: 'GET',\n            weight: 10,\n            validation: { statusCode: [200] }\n          }\n        ],\n        users: {\n          concurrent: 10,\n          rampUp: { duration: 30, strategy: 'linear' },\n          rampDown: { duration: 10, strategy: 'linear' },\n          thinkTime: { min: 1000, max: 3000, distribution: 'uniform' }\n        },\n        duration: { total: 300, warmup: 30, cooldown: 30 },\n        thresholds: {\n          responseTime: { p95: 1000, p99: 2000, max: 5000 },\n          errorRate: { max: 5 },\n          throughput: { min: 5 }\n        },\n        environment: {\n          concurrent: true,\n          keepAlive: true,\n          compression: true\n        }\n      }\n    });\n\n    // Database Stress Test\n    this.registerScenario({\n      id: 'database-stress',\n      name: 'Database Stress Test',\n      description: 'Database-intensive operations testing',\n      config: {\n        baseUrl: process.env.BASE_URL || 'http://localhost:3001',\n        endpoints: [\n          {\n            path: '/api/analytics/calculate',\n            method: 'POST',\n            weight: 40,\n            body: { period: 'day', limit: 100 },\n            validation: { statusCode: [200], responseTime: 5000 }\n          },\n          {\n            path: '/api/reports/generate',\n            method: 'POST',\n            weight: 30,\n            body: { type: 'performance', format: 'json' },\n            validation: { statusCode: [200] }\n          },\n          {\n            path: '/api/optimization/analyze',\n            method: 'POST',\n            weight: 30,\n            body: { prompt: 'Test prompt for analysis' },\n            validation: { statusCode: [200] }\n          }\n        ],\n        users: {\n          concurrent: 5,\n          rampUp: { duration: 60, strategy: 'exponential' },\n          rampDown: { duration: 30, strategy: 'linear' },\n          thinkTime: { min: 2000, max: 5000, distribution: 'normal' }\n        },\n        duration: { total: 600, warmup: 60, cooldown: 60 },\n        thresholds: {\n          responseTime: { p95: 3000, p99: 8000, max: 15000 },\n          errorRate: { max: 2 },\n          throughput: { min: 2 }\n        },\n        environment: {\n          concurrent: false,\n          keepAlive: true\n        }\n      }\n    });\n\n    // High Concurrency Test\n    this.registerScenario({\n      id: 'high-concurrency',\n      name: 'High Concurrency Test',\n      description: 'Testing system behavior under high concurrent load',\n      config: {\n        baseUrl: process.env.BASE_URL || 'http://localhost:3001',\n        endpoints: [\n          {\n            path: '/api/health',\n            method: 'GET',\n            weight: 50,\n            validation: { statusCode: [200] }\n          },\n          {\n            path: '/api/performance/health',\n            method: 'GET',\n            weight: 30,\n            validation: { statusCode: [200] }\n          },\n          {\n            path: '/api/analytics/realtime',\n            method: 'GET',\n            weight: 20,\n            validation: { statusCode: [200] }\n          }\n        ],\n        users: {\n          concurrent: 50,\n          rampUp: { duration: 120, strategy: 'step' },\n          rampDown: { duration: 60, strategy: 'immediate' },\n          thinkTime: { min: 500, max: 1500, distribution: 'exponential' }\n        },\n        duration: { total: 300, warmup: 60 },\n        thresholds: {\n          responseTime: { p95: 2000, p99: 5000, max: 10000 },\n          errorRate: { max: 10 },\n          throughput: { min: 20 }\n        },\n        environment: {\n          concurrent: true,\n          keepAlive: true,\n          compression: true\n        }\n      }\n    });\n  }\n\n  /**\n   * Setup regression detection thresholds\n   */\n  private setupRegressionThresholds(): void {\n    this.regressionThresholds.set('responseTime.p95', 1.2); // 20% increase\n    this.regressionThresholds.set('responseTime.avg', 1.15); // 15% increase\n    this.regressionThresholds.set('throughput.avg', 0.85); // 15% decrease\n    this.regressionThresholds.set('errorRate', 1.5); // 50% increase\n  }\n\n  /**\n   * Helper methods\n   */\n  private selectEndpoint(endpoints: EndpointConfig[]): EndpointConfig {\n    const totalWeight = endpoints.reduce((sum, e) => sum + e.weight, 0);\n    const random = Math.random() * totalWeight;\n    \n    let currentWeight = 0;\n    for (const endpoint of endpoints) {\n      currentWeight += endpoint.weight;\n      if (random <= currentWeight) {\n        return endpoint;\n      }\n    }\n    \n    return endpoints[endpoints.length - 1];\n  }\n\n  private calculateThinkTime(config: UserConfig['thinkTime']): number {\n    const { min, max, distribution } = config;\n    \n    switch (distribution) {\n      case 'uniform':\n        return min + Math.random() * (max - min);\n      case 'normal':\n        const u1 = Math.random();\n        const u2 = Math.random();\n        const z0 = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);\n        const mean = (min + max) / 2;\n        const stddev = (max - min) / 6;\n        return Math.max(min, Math.min(max, mean + z0 * stddev));\n      case 'exponential':\n        const lambda = 1 / ((min + max) / 2);\n        return min + (-Math.log(Math.random()) / lambda);\n      default:\n        return min + Math.random() * (max - min);\n    }\n  }\n\n  private calculatePercentile(values: number[], percentile: number): number {\n    if (values.length === 0) return 0;\n    \n    const sorted = values.slice().sort((a, b) => a - b);\n    const index = Math.ceil((percentile / 100) * sorted.length) - 1;\n    return sorted[Math.max(0, index)];\n  }\n\n  private isPromiseSettled(promise: Promise<any>): boolean {\n    // This is a simplified check - in real implementation you'd track promise states\n    return false;\n  }\n\n  private analyzeErrors(results: RequestResult[]): ErrorSummary[] {\n    const errorMap = new Map<string, RequestResult[]>();\n    \n    results.filter(r => !r.success).forEach(result => {\n      const key = `${result.statusCode}_${result.errorMessage || 'Unknown'}`;\n      if (!errorMap.has(key)) {\n        errorMap.set(key, []);\n      }\n      errorMap.get(key)!.push(result);\n    });\n\n    return Array.from(errorMap.entries()).map(([key, errors]) => {\n      const [statusCode, message] = key.split('_', 2);\n      return {\n        type: statusCode === '0' ? 'Network Error' : `HTTP ${statusCode}`,\n        message: message || 'Unknown error',\n        count: errors.length,\n        percentage: (errors.length / results.length) * 100,\n        endpoints: [...new Set(errors.map(e => e.endpoint))],\n        firstOccurrence: Math.min(...errors.map(e => e.timestamp)),\n        lastOccurrence: Math.max(...errors.map(e => e.timestamp))\n      };\n    });\n  }\n\n  private checkThresholds(scenario: LoadTestScenario, results: LoadTestResults): ThresholdResult[] {\n    const thresholds = scenario.config.thresholds;\n    const thresholdResults: ThresholdResult[] = [];\n\n    // Response time thresholds\n    thresholdResults.push({\n      name: 'P95 Response Time',\n      value: results.metrics.responseTime.p95,\n      threshold: thresholds.responseTime.p95,\n      passed: results.metrics.responseTime.p95 <= thresholds.responseTime.p95,\n      severity: results.metrics.responseTime.p95 > thresholds.responseTime.p95 * 1.5 ? 'error' : 'warning'\n    });\n\n    thresholdResults.push({\n      name: 'P99 Response Time',\n      value: results.metrics.responseTime.p99,\n      threshold: thresholds.responseTime.p99,\n      passed: results.metrics.responseTime.p99 <= thresholds.responseTime.p99,\n      severity: results.metrics.responseTime.p99 > thresholds.responseTime.p99 * 1.5 ? 'error' : 'warning'\n    });\n\n    // Error rate threshold\n    thresholdResults.push({\n      name: 'Error Rate',\n      value: results.metrics.errorRate,\n      threshold: thresholds.errorRate.max,\n      passed: results.metrics.errorRate <= thresholds.errorRate.max,\n      severity: results.metrics.errorRate > thresholds.errorRate.max * 2 ? 'error' : 'warning'\n    });\n\n    // Throughput threshold\n    thresholdResults.push({\n      name: 'Throughput',\n      value: results.metrics.throughput.avg,\n      threshold: thresholds.throughput.min,\n      passed: results.metrics.throughput.avg >= thresholds.throughput.min,\n      severity: results.metrics.throughput.avg < thresholds.throughput.min * 0.5 ? 'error' : 'warning'\n    });\n\n    return thresholdResults;\n  }\n\n  private generateRecommendations(results: LoadTestResults): string[] {\n    const recommendations: string[] = [];\n    const metrics = results.metrics;\n\n    if (metrics.errorRate > 5) {\n      recommendations.push('High error rate detected. Review error logs and implement better error handling.');\n    }\n\n    if (metrics.responseTime.p95 > 2000) {\n      recommendations.push('Slow response times detected. Consider implementing caching or optimizing database queries.');\n    }\n\n    if (metrics.throughput.avg < 10) {\n      recommendations.push('Low throughput detected. Consider scaling horizontally or optimizing application performance.');\n    }\n\n    if (results.errors.some(e => e.type.includes('Network'))) {\n      recommendations.push('Network errors detected. Check network connectivity and implement retry mechanisms.');\n    }\n\n    const failedThresholds = results.thresholdResults.filter(t => !t.passed);\n    if (failedThresholds.length > 0) {\n      recommendations.push(`Performance thresholds failed: ${failedThresholds.map(t => t.name).join(', ')}`);\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('All performance metrics are within acceptable ranges.');\n    }\n\n    return recommendations;\n  }\n\n  private async runDryRun(scenario: LoadTestScenario): Promise<LoadTestResults> {\n    // Simulate a quick test run for validation\n    console.log(`Running dry run for scenario: ${scenario.name}`);\n    \n    // Return mock results\n    return {\n      scenario,\n      summary: {\n        startTime: new Date(),\n        endTime: new Date(),\n        duration: 10,\n        totalRequests: 10,\n        successfulRequests: 10,\n        failedRequests: 0,\n        requestsPerSecond: 1,\n        bytesReceived: 1000,\n        bytesSent: 500\n      },\n      metrics: {\n        responseTime: { min: 50, max: 200, avg: 100, p50: 95, p95: 180, p99: 195 },\n        throughput: { avg: 1, peak: 1, min: 1 },\n        errorRate: 0,\n        concurrency: { avg: 1, peak: 1 }\n      },\n      timeline: [],\n      errors: [],\n      thresholdResults: [],\n      recommendations: ['Dry run completed successfully']\n    };\n  }\n\n  private async saveBaseline(scenarioId: string, results: LoadTestResults): Promise<void> {\n    this.baselines.set(scenarioId, results);\n    \n    // Also save to database\n    const stmt = db.prepare(`\n      INSERT OR REPLACE INTO load_test_baselines \n      (scenario_id, results, created_at)\n      VALUES (?, ?, ?)\n    `);\n    \n    stmt.run(scenarioId, JSON.stringify(results), new Date().toISOString());\n  }\n\n  private async compareWithBaseline(scenarioId: string, results: LoadTestResults): Promise<void> {\n    const baseline = this.baselines.get(scenarioId);\n    if (!baseline) {\n      console.log(`No baseline found for scenario: ${scenarioId}`);\n      return;\n    }\n\n    const comparison = {\n      responseTime: {\n        p95: (results.metrics.responseTime.p95 / baseline.metrics.responseTime.p95) - 1,\n        avg: (results.metrics.responseTime.avg / baseline.metrics.responseTime.avg) - 1\n      },\n      throughput: {\n        avg: (results.metrics.throughput.avg / baseline.metrics.throughput.avg) - 1\n      },\n      errorRate: results.metrics.errorRate - baseline.metrics.errorRate\n    };\n\n    console.log(`Baseline comparison for ${scenarioId}:`, comparison);\n    this.emit('baselineComparison', { scenarioId, comparison, results, baseline });\n  }\n\n  private async detectRegression(scenarioId: string, results: LoadTestResults): Promise<RegressionResult | null> {\n    const baseline = this.baselines.get(scenarioId);\n    if (!baseline) {\n      return null;\n    }\n\n    const regressions: RegressionIssue[] = [];\n\n    // Check response time regression\n    const p95Threshold = this.regressionThresholds.get('responseTime.p95') || 1.2;\n    if (results.metrics.responseTime.p95 > baseline.metrics.responseTime.p95 * p95Threshold) {\n      regressions.push({\n        metric: 'responseTime.p95',\n        baseline: baseline.metrics.responseTime.p95,\n        current: results.metrics.responseTime.p95,\n        threshold: p95Threshold,\n        degradation: (results.metrics.responseTime.p95 / baseline.metrics.responseTime.p95) - 1\n      });\n    }\n\n    // Check throughput regression\n    const throughputThreshold = this.regressionThresholds.get('throughput.avg') || 0.85;\n    if (results.metrics.throughput.avg < baseline.metrics.throughput.avg * throughputThreshold) {\n      regressions.push({\n        metric: 'throughput.avg',\n        baseline: baseline.metrics.throughput.avg,\n        current: results.metrics.throughput.avg,\n        threshold: throughputThreshold,\n        degradation: (baseline.metrics.throughput.avg / results.metrics.throughput.avg) - 1\n      });\n    }\n\n    // Check error rate regression\n    const errorRateThreshold = this.regressionThresholds.get('errorRate') || 1.5;\n    if (results.metrics.errorRate > baseline.metrics.errorRate * errorRateThreshold) {\n      regressions.push({\n        metric: 'errorRate',\n        baseline: baseline.metrics.errorRate,\n        current: results.metrics.errorRate,\n        threshold: errorRateThreshold,\n        degradation: (results.metrics.errorRate / baseline.metrics.errorRate) - 1\n      });\n    }\n\n    if (regressions.length > 0) {\n      return {\n        scenarioId,\n        timestamp: new Date(),\n        regressions,\n        severity: regressions.some(r => r.degradation > 0.5) ? 'critical' : \n                 regressions.some(r => r.degradation > 0.2) ? 'high' : 'medium'\n      };\n    }\n\n    return null;\n  }\n\n  private async saveResults(results: LoadTestResults): Promise<void> {\n    try {\n      const stmt = db.prepare(`\n        INSERT INTO load_test_results \n        (scenario_id, scenario_name, start_time, end_time, duration, total_requests, \n         successful_requests, failed_requests, requests_per_second, avg_response_time, \n         p95_response_time, p99_response_time, error_rate, results_json, created_at)\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n      `);\n      \n      stmt.run(\n        results.scenario.id,\n        results.scenario.name,\n        results.summary.startTime.toISOString(),\n        results.summary.endTime.toISOString(),\n        results.summary.duration,\n        results.summary.totalRequests,\n        results.summary.successfulRequests,\n        results.summary.failedRequests,\n        results.summary.requestsPerSecond,\n        results.metrics.responseTime.avg,\n        results.metrics.responseTime.p95,\n        results.metrics.responseTime.p99,\n        results.metrics.errorRate,\n        JSON.stringify(results),\n        new Date().toISOString()\n      );\n    } catch (error) {\n      console.error('Failed to save load test results:', error);\n    }\n  }\n\n  /**\n   * Clean up resources\n   */\n  async cleanup(): Promise<void> {\n    await this.workerPool.terminate();\n    this.removeAllListeners();\n  }\n}\n\n// Interfaces for regression detection\ninterface RegressionResult {\n  scenarioId: string;\n  timestamp: Date;\n  regressions: RegressionIssue[];\n  severity: 'low' | 'medium' | 'high' | 'critical';\n}\n\ninterface RegressionIssue {\n  metric: string;\n  baseline: number;\n  current: number;\n  threshold: number;\n  degradation: number; // Percentage degradation\n}\n\n// Worker thread handler\nif (!isMainThread && workerData?.isWorker) {\n  // Worker thread logic for load testing\n  parentPort?.on('message', async (message) => {\n    const { type, data } = message;\n    \n    switch (type) {\n      case 'makeRequest':\n        // Handle request in worker thread\n        break;\n      case 'simulateUser':\n        // Handle user simulation in worker thread\n        break;\n    }\n  });\n}\n\n// Export singleton instance\nexport const loadTestingFramework = new LoadTestingFramework();"],"names":["LoadTestingFramework","loadTestingFramework","WorkerPool","getWorker","available","length","worker","pop","busy","add","workers","maxWorkers","Worker","__filename","workerData","isWorker","push","Promise","resolve","checkAvailable","setTimeout","releaseWorker","delete","terminate","all","map","clear","Set","EventEmitter","registerScenario","scenario","scenarios","set","id","emit","getScenarios","Array","from","values","runLoadTest","scenarioId","options","isRunning","Error","get","dryRun","runDryRun","results","executeLoadTest","saveBaseline","compareBaseline","compareWithBaseline","saveResults","currentTest","runRegressionTest","scenarioIds","regressions","result","regression","detectRegression","passed","getStatus","elapsed","Date","now","summary","startTime","getTime","totalDuration","config","duration","total","progress","Math","min","estimatedTimeRemaining","max","name","elapsedTime","stopTest","workerPool","endTime","totalRequests","successfulRequests","failedRequests","requestsPerSecond","bytesReceived","bytesSent","metrics","responseTime","avg","p50","p95","p99","throughput","peak","errorRate","concurrency","timeline","errors","thresholdResults","recommendations","hooks","beforeScenario","requestResults","userPromises","timelineData","timelineInterval","setInterval","recentResults","filter","r","timestamp","timelinePoint","activeUsers","p","isPromiseSettled","avgResponseTime","reduce","sum","success","p95ResponseTime","calculatePercentile","rampUpUsers","userId","userPromise","simulateUser","setTimeoutPromise","allSettled","clearInterval","afterScenario","responseSize","responseTimes","t","analyzeErrors","checkThresholds","generateRecommendations","createUser","users","rampUpDuration","rampUp","totalUsers","concurrent","i","uuidv4","delay","strategy","pow","environment","variables","endpoint","selectEndpoint","endpoints","context","iteration","beforeRequest","makeRequest","afterRequest","thinkTime","calculateThinkTime","performance","url","baseUrl","path","response","axios","method","headers","data","body","params","timeout","validateStatus","JSON","stringify","validation","statusCode","includes","status","bodyContains","every","text","headerExists","header","undefined","Object","fromEntries","entries","key","value","String","error","errorMessage","message","setupDefaultScenarios","description","process","env","BASE_URL","weight","rampDown","distribution","warmup","cooldown","thresholds","keepAlive","compression","period","limit","type","format","prompt","setupRegressionThresholds","regressionThresholds","totalWeight","e","random","currentWeight","u1","u2","z0","sqrt","log","cos","PI","mean","stddev","lambda","percentile","sorted","slice","sort","a","b","index","ceil","promise","errorMap","Map","forEach","has","split","count","percentage","firstOccurrence","lastOccurrence","threshold","severity","some","failedThresholds","join","console","baselines","stmt","db","prepare","run","toISOString","baseline","comparison","p95Threshold","metric","current","degradation","throughputThreshold","errorRateThreshold","cleanup","removeAllListeners","isMainThread","parentPort","on"],"mappings":"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"}