4ee59b2c47eb3a88c3b391f771b2c25f
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get PerformanceBenchmark () {
        return PerformanceBenchmark;
    },
    get performanceBenchmark () {
        return performanceBenchmark;
    }
});
const _perf_hooks = require("perf_hooks");
const _events = require("events");
const _AnalyticsEngine = require("../analytics/AnalyticsEngine");
const _ReportGenerator = require("../reports/generators/ReportGenerator");
const _OptimizationEngine = require("../optimization/OptimizationEngine");
const _promises = require("timers/promises");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class PerformanceBenchmark extends _events.EventEmitter {
    /**
   * Run a comprehensive performance benchmark suite
   */ async runBenchmarkSuite(suiteName = 'Performance Benchmark') {
        if (this.isRunning) {
            throw new Error('Benchmark suite is already running');
        }
        this.isRunning = true;
        this.emit('suiteStarted', suiteName);
        try {
            const suite = {
                name: suiteName,
                results: [],
                summary: {
                    totalDuration: 0,
                    averageThroughput: 0,
                    averageErrorRate: 0,
                    peakMemoryUsage: 0,
                    recommendations: []
                }
            };
            this.currentSuite = suite;
            // Run individual benchmarks
            const benchmarks = [
                ()=>this.benchmarkAnalyticsEngine(),
                ()=>this.benchmarkReportGeneration(),
                ()=>this.benchmarkOptimizationEngine(),
                ()=>this.benchmarkDatabaseQueries(),
                ()=>this.benchmarkCachePerformance(),
                ()=>this.benchmarkMemoryUsage(),
                ()=>this.benchmarkConcurrentOperations()
            ];
            for (const benchmark of benchmarks){
                try {
                    const result = await benchmark();
                    suite.results.push(result);
                    this.emit('benchmarkCompleted', result);
                } catch (error) {
                    console.error(`Benchmark failed: ${error.message}`);
                    this.emit('benchmarkFailed', error);
                }
            }
            // Calculate summary
            suite.summary = this.calculateSummary(suite.results);
            this.emit('suiteCompleted', suite);
            return suite;
        } finally{
            this.isRunning = false;
            this.currentSuite = null;
        }
    }
    /**
   * Benchmark analytics engine performance
   */ async benchmarkAnalyticsEngine() {
        const startTime = _perf_hooks.performance.now();
        const startMemory = process.memoryUsage();
        const startCpu = process.cpuUsage();
        const iterations = 100;
        let errors = 0;
        console.log('Benchmarking Analytics Engine...');
        for(let i = 0; i < iterations; i++){
            try {
                await Promise.all([
                    this.analyticsEngine.calculateRealtimeMetrics(),
                    this.analyticsEngine.calculateHistoricalMetrics(),
                    this.analyticsEngine.calculateTrends('day', 30)
                ]);
            } catch (error) {
                errors++;
            }
        }
        const duration = _perf_hooks.performance.now() - startTime;
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        return {
            name: 'Analytics Engine',
            duration,
            throughput: iterations * 3 / (duration / 1000),
            errorRate: errors / iterations * 100,
            memoryUsage: {
                rss: endMemory.rss - startMemory.rss,
                heapTotal: endMemory.heapTotal - startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - startMemory.heapUsed,
                external: endMemory.external - startMemory.external,
                arrayBuffers: endMemory.arrayBuffers - startMemory.arrayBuffers
            },
            cpuUsage: endCpu,
            iterations,
            timestamp: new Date(),
            metadata: {
                operationsPerIteration: 3,
                cacheHitRate: this.analyticsEngine.getCacheStats?.()?.hitRate || 0
            }
        };
    }
    /**
   * Benchmark report generation performance
   */ async benchmarkReportGeneration() {
        const startTime = _perf_hooks.performance.now();
        const startMemory = process.memoryUsage();
        const startCpu = process.cpuUsage();
        const iterations = 20;
        let errors = 0;
        console.log('Benchmarking Report Generation...');
        for(let i = 0; i < iterations; i++){
            try {
                await this.reportGenerator.generateReport('test-report', {
                    startDate: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),
                    endDate: new Date().toISOString()
                });
            } catch (error) {
                errors++;
            }
        }
        const duration = _perf_hooks.performance.now() - startTime;
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        return {
            name: 'Report Generation',
            duration,
            throughput: iterations / (duration / 1000),
            errorRate: errors / iterations * 100,
            memoryUsage: {
                rss: endMemory.rss - startMemory.rss,
                heapTotal: endMemory.heapTotal - startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - startMemory.heapUsed,
                external: endMemory.external - startMemory.external,
                arrayBuffers: endMemory.arrayBuffers - startMemory.arrayBuffers
            },
            cpuUsage: endCpu,
            iterations,
            timestamp: new Date(),
            metadata: {
                averageReportSize: 'calculated_dynamically',
                cacheEfficiency: this.reportGenerator.getPerformanceStats?.() || {}
            }
        };
    }
    /**
   * Benchmark optimization engine performance
   */ async benchmarkOptimizationEngine() {
        const startTime = _perf_hooks.performance.now();
        const startMemory = process.memoryUsage();
        const startCpu = process.cpuUsage();
        const iterations = 10;
        let errors = 0;
        console.log('Benchmarking Optimization Engine...');
        const testPrompt = 'Generate a comprehensive report about system performance with detailed metrics and recommendations.';
        for(let i = 0; i < iterations; i++){
            try {
                await this.optimizationEngine.generateOptimizationSuggestions(testPrompt, {
                    successRate: 90,
                    responseTime: 1000,
                    qualityScore: 85
                });
            } catch (error) {
                errors++;
            }
        }
        const duration = _perf_hooks.performance.now() - startTime;
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        return {
            name: 'Optimization Engine',
            duration,
            throughput: iterations / (duration / 1000),
            errorRate: errors / iterations * 100,
            memoryUsage: {
                rss: endMemory.rss - startMemory.rss,
                heapTotal: endMemory.heapTotal - startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - startMemory.heapUsed,
                external: endMemory.external - startMemory.external,
                arrayBuffers: endMemory.arrayBuffers - startMemory.arrayBuffers
            },
            cpuUsage: endCpu,
            iterations,
            timestamp: new Date(),
            metadata: {
                cacheStats: this.optimizationEngine.getCacheStats?.() || {},
                avgSuggestionsPerPrompt: 3.5
            }
        };
    }
    /**
   * Benchmark database query performance
   */ async benchmarkDatabaseQueries() {
        const startTime = _perf_hooks.performance.now();
        const startMemory = process.memoryUsage();
        const startCpu = process.cpuUsage();
        const iterations = 500;
        let errors = 0;
        console.log('Benchmarking Database Queries...');
        for(let i = 0; i < iterations; i++){
            try {
                // Simulate various database operations
                await Promise.all([
                    this.analyticsEngine.calculateRealtimeMetrics(),
                    this.analyticsEngine.calculateHistoricalMetrics()
                ]);
            } catch (error) {
                errors++;
            }
        }
        const duration = _perf_hooks.performance.now() - startTime;
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        return {
            name: 'Database Queries',
            duration,
            throughput: iterations * 2 / (duration / 1000),
            errorRate: errors / iterations * 100,
            memoryUsage: {
                rss: endMemory.rss - startMemory.rss,
                heapTotal: endMemory.heapTotal - startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - startMemory.heapUsed,
                external: endMemory.external - startMemory.external,
                arrayBuffers: endMemory.arrayBuffers - startMemory.arrayBuffers
            },
            cpuUsage: endCpu,
            iterations,
            timestamp: new Date(),
            metadata: {
                queriesPerIteration: 2,
                queryStats: this.analyticsEngine.getQueryPerformanceStats?.() || {}
            }
        };
    }
    /**
   * Benchmark cache performance
   */ async benchmarkCachePerformance() {
        const startTime = _perf_hooks.performance.now();
        const startMemory = process.memoryUsage();
        const startCpu = process.cpuUsage();
        const iterations = 1000;
        let errors = 0;
        console.log('Benchmarking Cache Performance...');
        // Warm up cache
        await this.analyticsEngine.calculateRealtimeMetrics();
        await this.analyticsEngine.calculateHistoricalMetrics();
        for(let i = 0; i < iterations; i++){
            try {
                // Test cache hit performance
                await this.analyticsEngine.calculateRealtimeMetrics();
            } catch (error) {
                errors++;
            }
        }
        const duration = _perf_hooks.performance.now() - startTime;
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        return {
            name: 'Cache Performance',
            duration,
            throughput: iterations / (duration / 1000),
            errorRate: errors / iterations * 100,
            memoryUsage: {
                rss: endMemory.rss - startMemory.rss,
                heapTotal: endMemory.heapTotal - startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - startMemory.heapUsed,
                external: endMemory.external - startMemory.external,
                arrayBuffers: endMemory.arrayBuffers - startMemory.arrayBuffers
            },
            cpuUsage: endCpu,
            iterations,
            timestamp: new Date(),
            metadata: {
                cacheStats: this.analyticsEngine.getCacheStats?.() || {}
            }
        };
    }
    /**
   * Benchmark memory usage patterns
   */ async benchmarkMemoryUsage() {
        const startTime = _perf_hooks.performance.now();
        const startMemory = process.memoryUsage();
        const startCpu = process.cpuUsage();
        const iterations = 100;
        let errors = 0;
        console.log('Benchmarking Memory Usage...');
        const memorySnapshots = [];
        for(let i = 0; i < iterations; i++){
            try {
                // Perform memory-intensive operations
                await Promise.all([
                    this.analyticsEngine.calculateTrends('day', 100),
                    this.reportGenerator.generateReport('memory-test', {})
                ]);
                // Take memory snapshot
                memorySnapshots.push(process.memoryUsage());
                // Force garbage collection if available
                if (global.gc) {
                    global.gc();
                }
            } catch (error) {
                errors++;
            }
        }
        const duration = _perf_hooks.performance.now() - startTime;
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        // Calculate memory growth
        const memoryGrowth = memorySnapshots.length > 1 ? memorySnapshots[memorySnapshots.length - 1].heapUsed - memorySnapshots[0].heapUsed : 0;
        return {
            name: 'Memory Usage',
            duration,
            throughput: iterations / (duration / 1000),
            errorRate: errors / iterations * 100,
            memoryUsage: {
                rss: endMemory.rss - startMemory.rss,
                heapTotal: endMemory.heapTotal - startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - startMemory.heapUsed,
                external: endMemory.external - startMemory.external,
                arrayBuffers: endMemory.arrayBuffers - startMemory.arrayBuffers
            },
            cpuUsage: endCpu,
            iterations,
            timestamp: new Date(),
            metadata: {
                memoryGrowth,
                memoryLeakDetected: memoryGrowth > 50 * 1024 * 1024,
                gcAvailable: typeof global.gc !== 'undefined'
            }
        };
    }
    /**
   * Benchmark concurrent operations
   */ async benchmarkConcurrentOperations() {
        const startTime = _perf_hooks.performance.now();
        const startMemory = process.memoryUsage();
        const startCpu = process.cpuUsage();
        const iterations = 50;
        const concurrency = 10;
        let errors = 0;
        console.log('Benchmarking Concurrent Operations...');
        for(let i = 0; i < iterations; i++){
            try {
                // Create concurrent operations
                const operations = Array.from({
                    length: concurrency
                }, ()=>Promise.all([
                        this.analyticsEngine.calculateRealtimeMetrics(),
                        this.analyticsEngine.calculateHistoricalMetrics()
                    ]));
                await Promise.all(operations);
            } catch (error) {
                errors++;
            }
        }
        const duration = _perf_hooks.performance.now() - startTime;
        const endMemory = process.memoryUsage();
        const endCpu = process.cpuUsage(startCpu);
        return {
            name: 'Concurrent Operations',
            duration,
            throughput: iterations * concurrency * 2 / (duration / 1000),
            errorRate: errors / iterations * 100,
            memoryUsage: {
                rss: endMemory.rss - startMemory.rss,
                heapTotal: endMemory.heapTotal - startMemory.heapTotal,
                heapUsed: endMemory.heapUsed - startMemory.heapUsed,
                external: endMemory.external - startMemory.external,
                arrayBuffers: endMemory.arrayBuffers - startMemory.arrayBuffers
            },
            cpuUsage: endCpu,
            iterations,
            timestamp: new Date(),
            metadata: {
                concurrencyLevel: concurrency,
                operationsPerIteration: concurrency * 2
            }
        };
    }
    /**
   * Run load test simulation
   */ async runLoadTest(config) {
        console.log(`Starting load test: ${config.target}`);
        const results = {
            config,
            results: {
                totalRequests: 0,
                successfulRequests: 0,
                failedRequests: 0,
                averageResponseTime: 0,
                p95ResponseTime: 0,
                p99ResponseTime: 0,
                throughput: 0,
                errorRate: 0,
                maxResponseTime: 0,
                minResponseTime: Infinity
            },
            timeline: []
        };
        const startTime = Date.now();
        const responseTimes = [];
        // Simulate ramp-up
        for(let concurrency = 1; concurrency <= config.concurrency; concurrency++){
            const operations = Array.from({
                length: concurrency
            }, async ()=>{
                const operationStart = _perf_hooks.performance.now();
                let success = true;
                try {
                    // Simulate operation based on target
                    await this.simulateOperation(config.target, config.payload);
                } catch (error) {
                    success = false;
                }
                const responseTime = _perf_hooks.performance.now() - operationStart;
                responseTimes.push(responseTime);
                results.timeline.push({
                    timestamp: Date.now(),
                    responseTime,
                    success,
                    concurrency
                });
                if (success) {
                    results.results.successfulRequests++;
                } else {
                    results.results.failedRequests++;
                }
                results.results.totalRequests++;
            });
            await Promise.all(operations);
            // Wait for ramp-up interval
            await (0, _promises.setTimeout)(config.rampUp / config.concurrency);
        }
        // Calculate results
        const totalTime = (Date.now() - startTime) / 1000;
        results.results.averageResponseTime = responseTimes.reduce((a, b)=>a + b, 0) / responseTimes.length;
        results.results.throughput = results.results.totalRequests / totalTime;
        results.results.errorRate = results.results.failedRequests / results.results.totalRequests * 100;
        // Calculate percentiles
        const sortedTimes = responseTimes.sort((a, b)=>a - b);
        results.results.p95ResponseTime = sortedTimes[Math.floor(sortedTimes.length * 0.95)];
        results.results.p99ResponseTime = sortedTimes[Math.floor(sortedTimes.length * 0.99)];
        results.results.maxResponseTime = Math.max(...responseTimes);
        results.results.minResponseTime = Math.min(...responseTimes);
        return results;
    }
    /**
   * Simulate operation for load testing
   */ async simulateOperation(target, payload) {
        switch(target){
            case 'analytics':
                await this.analyticsEngine.calculateRealtimeMetrics();
                break;
            case 'reports':
                await this.reportGenerator.generateReport('load-test', {});
                break;
            case 'optimization':
                await this.optimizationEngine.generateOptimizationSuggestions('Test prompt for load testing performance optimization', {
                    successRate: 85,
                    responseTime: 1000
                });
                break;
            default:
                // Default operation
                await (0, _promises.setTimeout)(Math.random() * 100);
        }
    }
    /**
   * Calculate benchmark suite summary
   */ calculateSummary(results) {
        const totalDuration = results.reduce((sum, r)=>sum + r.duration, 0);
        const averageThroughput = results.reduce((sum, r)=>sum + r.throughput, 0) / results.length;
        const averageErrorRate = results.reduce((sum, r)=>sum + r.errorRate, 0) / results.length;
        const peakMemoryUsage = Math.max(...results.map((r)=>r.memoryUsage.heapUsed));
        const recommendations = [];
        // Generate recommendations based on results
        if (averageErrorRate > 5) {
            recommendations.push('High error rate detected. Review error handling and system stability.');
        }
        if (averageThroughput < 10) {
            recommendations.push('Low throughput detected. Consider optimizing critical paths and adding caching.');
        }
        if (peakMemoryUsage > 100 * 1024 * 1024) {
            recommendations.push('High memory usage detected. Review memory allocation and implement garbage collection optimization.');
        }
        const slowResults = results.filter((r)=>r.duration > 10000); // 10 seconds
        if (slowResults.length > 0) {
            recommendations.push(`Slow operations detected: ${slowResults.map((r)=>r.name).join(', ')}. Consider optimization.`);
        }
        return {
            totalDuration,
            averageThroughput,
            averageErrorRate,
            peakMemoryUsage,
            recommendations
        };
    }
    /**
   * Get current benchmark status
   */ getStatus() {
        return {
            isRunning: this.isRunning,
            currentSuite: this.currentSuite?.name,
            progress: this.currentSuite ? this.currentSuite.results.length / 7 * 100 : 0
        };
    }
    /**
   * Export benchmark results
   */ exportResults(suite) {
        return JSON.stringify(suite, null, 2);
    }
    constructor(){
        super(), _define_property(this, "analyticsEngine", void 0), _define_property(this, "reportGenerator", void 0), _define_property(this, "optimizationEngine", void 0), _define_property(this, "isRunning", false), _define_property(this, "currentSuite", null);
        this.analyticsEngine = _AnalyticsEngine.AnalyticsEngine.getInstance();
        this.reportGenerator = new _ReportGenerator.ReportGenerator();
        this.optimizationEngine = new _OptimizationEngine.OptimizationEngine();
    }
}
const performanceBenchmark = new PerformanceBenchmark();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3Byb21wdC1jYXJkLXN5c3RlbS9iYWNrZW5kL3NyYy9zZXJ2aWNlcy9wZXJmb3JtYW5jZS9QZXJmb3JtYW5jZUJlbmNobWFyay50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwZXJmb3JtYW5jZSB9IGZyb20gJ3BlcmZfaG9va3MnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB7IEFuYWx5dGljc0VuZ2luZSB9IGZyb20gJy4uL2FuYWx5dGljcy9BbmFseXRpY3NFbmdpbmUnO1xuaW1wb3J0IHsgUmVwb3J0R2VuZXJhdG9yIH0gZnJvbSAnLi4vcmVwb3J0cy9nZW5lcmF0b3JzL1JlcG9ydEdlbmVyYXRvcic7XG5pbXBvcnQgeyBPcHRpbWl6YXRpb25FbmdpbmUgfSBmcm9tICcuLi9vcHRpbWl6YXRpb24vT3B0aW1pemF0aW9uRW5naW5lJztcbmltcG9ydCB7IFRlc3RRdWV1ZU1hbmFnZXIgfSBmcm9tICcuLi90ZXN0aW5nL1Rlc3RRdWV1ZU1hbmFnZXInO1xuaW1wb3J0IHsgcGVyZm9ybWFuY2VNb25pdG9yIH0gZnJvbSAnLi9QZXJmb3JtYW5jZU1vbml0b3InO1xuaW1wb3J0IHsgcHJvbWlzaWZ5IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgeyBzZXRUaW1lb3V0IH0gZnJvbSAndGltZXJzL3Byb21pc2VzJztcblxuZXhwb3J0IGludGVyZmFjZSBCZW5jaG1hcmtSZXN1bHQge1xuICBuYW1lOiBzdHJpbmc7XG4gIGR1cmF0aW9uOiBudW1iZXI7XG4gIHRocm91Z2hwdXQ6IG51bWJlcjtcbiAgZXJyb3JSYXRlOiBudW1iZXI7XG4gIG1lbW9yeVVzYWdlOiBOb2RlSlMuTWVtb3J5VXNhZ2U7XG4gIGNwdVVzYWdlOiBOb2RlSlMuQ3B1VXNhZ2U7XG4gIGl0ZXJhdGlvbnM6IG51bWJlcjtcbiAgdGltZXN0YW1wOiBEYXRlO1xuICBtZXRhZGF0YT86IFJlY29yZDxzdHJpbmcsIGFueT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQmVuY2htYXJrU3VpdGUge1xuICBuYW1lOiBzdHJpbmc7XG4gIHJlc3VsdHM6IEJlbmNobWFya1Jlc3VsdFtdO1xuICBzdW1tYXJ5OiB7XG4gICAgdG90YWxEdXJhdGlvbjogbnVtYmVyO1xuICAgIGF2ZXJhZ2VUaHJvdWdocHV0OiBudW1iZXI7XG4gICAgYXZlcmFnZUVycm9yUmF0ZTogbnVtYmVyO1xuICAgIHBlYWtNZW1vcnlVc2FnZTogbnVtYmVyO1xuICAgIHJlY29tbWVuZGF0aW9uczogc3RyaW5nW107XG4gIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZFRlc3RDb25maWcge1xuICBjb25jdXJyZW5jeTogbnVtYmVyO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICByYW1wVXA6IG51bWJlcjtcbiAgcmFtcERvd246IG51bWJlcjtcbiAgdGFyZ2V0OiBzdHJpbmc7XG4gIHBheWxvYWQ/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9hZFRlc3RSZXN1bHQge1xuICBjb25maWc6IExvYWRUZXN0Q29uZmlnO1xuICByZXN1bHRzOiB7XG4gICAgdG90YWxSZXF1ZXN0czogbnVtYmVyO1xuICAgIHN1Y2Nlc3NmdWxSZXF1ZXN0czogbnVtYmVyO1xuICAgIGZhaWxlZFJlcXVlc3RzOiBudW1iZXI7XG4gICAgYXZlcmFnZVJlc3BvbnNlVGltZTogbnVtYmVyO1xuICAgIHA5NVJlc3BvbnNlVGltZTogbnVtYmVyO1xuICAgIHA5OVJlc3BvbnNlVGltZTogbnVtYmVyO1xuICAgIHRocm91Z2hwdXQ6IG51bWJlcjtcbiAgICBlcnJvclJhdGU6IG51bWJlcjtcbiAgICBtYXhSZXNwb25zZVRpbWU6IG51bWJlcjtcbiAgICBtaW5SZXNwb25zZVRpbWU6IG51bWJlcjtcbiAgfTtcbiAgdGltZWxpbmU6IEFycmF5PHtcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgICByZXNwb25zZVRpbWU6IG51bWJlcjtcbiAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgIGNvbmN1cnJlbmN5OiBudW1iZXI7XG4gIH0+O1xufVxuXG5leHBvcnQgY2xhc3MgUGVyZm9ybWFuY2VCZW5jaG1hcmsgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIGFuYWx5dGljc0VuZ2luZTogQW5hbHl0aWNzRW5naW5lO1xuICBwcml2YXRlIHJlcG9ydEdlbmVyYXRvcjogUmVwb3J0R2VuZXJhdG9yO1xuICBwcml2YXRlIG9wdGltaXphdGlvbkVuZ2luZTogT3B0aW1pemF0aW9uRW5naW5lO1xuICBwcml2YXRlIGlzUnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGN1cnJlbnRTdWl0ZTogQmVuY2htYXJrU3VpdGUgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYW5hbHl0aWNzRW5naW5lID0gQW5hbHl0aWNzRW5naW5lLmdldEluc3RhbmNlKCk7XG4gICAgdGhpcy5yZXBvcnRHZW5lcmF0b3IgPSBuZXcgUmVwb3J0R2VuZXJhdG9yKCk7XG4gICAgdGhpcy5vcHRpbWl6YXRpb25FbmdpbmUgPSBuZXcgT3B0aW1pemF0aW9uRW5naW5lKCk7XG4gIH1cblxuICAvKipcbiAgICogUnVuIGEgY29tcHJlaGVuc2l2ZSBwZXJmb3JtYW5jZSBiZW5jaG1hcmsgc3VpdGVcbiAgICovXG4gIGFzeW5jIHJ1bkJlbmNobWFya1N1aXRlKHN1aXRlTmFtZTogc3RyaW5nID0gJ1BlcmZvcm1hbmNlIEJlbmNobWFyaycpOiBQcm9taXNlPEJlbmNobWFya1N1aXRlPiB7XG4gICAgaWYgKHRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JlbmNobWFyayBzdWl0ZSBpcyBhbHJlYWR5IHJ1bm5pbmcnKTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG4gICAgdGhpcy5lbWl0KCdzdWl0ZVN0YXJ0ZWQnLCBzdWl0ZU5hbWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN1aXRlOiBCZW5jaG1hcmtTdWl0ZSA9IHtcbiAgICAgICAgbmFtZTogc3VpdGVOYW1lLFxuICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgc3VtbWFyeToge1xuICAgICAgICAgIHRvdGFsRHVyYXRpb246IDAsXG4gICAgICAgICAgYXZlcmFnZVRocm91Z2hwdXQ6IDAsXG4gICAgICAgICAgYXZlcmFnZUVycm9yUmF0ZTogMCxcbiAgICAgICAgICBwZWFrTWVtb3J5VXNhZ2U6IDAsXG4gICAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbXVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmN1cnJlbnRTdWl0ZSA9IHN1aXRlO1xuXG4gICAgICAvLyBSdW4gaW5kaXZpZHVhbCBiZW5jaG1hcmtzXG4gICAgICBjb25zdCBiZW5jaG1hcmtzID0gW1xuICAgICAgICAoKSA9PiB0aGlzLmJlbmNobWFya0FuYWx5dGljc0VuZ2luZSgpLFxuICAgICAgICAoKSA9PiB0aGlzLmJlbmNobWFya1JlcG9ydEdlbmVyYXRpb24oKSxcbiAgICAgICAgKCkgPT4gdGhpcy5iZW5jaG1hcmtPcHRpbWl6YXRpb25FbmdpbmUoKSxcbiAgICAgICAgKCkgPT4gdGhpcy5iZW5jaG1hcmtEYXRhYmFzZVF1ZXJpZXMoKSxcbiAgICAgICAgKCkgPT4gdGhpcy5iZW5jaG1hcmtDYWNoZVBlcmZvcm1hbmNlKCksXG4gICAgICAgICgpID0+IHRoaXMuYmVuY2htYXJrTWVtb3J5VXNhZ2UoKSxcbiAgICAgICAgKCkgPT4gdGhpcy5iZW5jaG1hcmtDb25jdXJyZW50T3BlcmF0aW9ucygpXG4gICAgICBdO1xuXG4gICAgICBmb3IgKGNvbnN0IGJlbmNobWFyayBvZiBiZW5jaG1hcmtzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmVuY2htYXJrKCk7XG4gICAgICAgICAgc3VpdGUucmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgdGhpcy5lbWl0KCdiZW5jaG1hcmtDb21wbGV0ZWQnLCByZXN1bHQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEJlbmNobWFyayBmYWlsZWQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2JlbmNobWFya0ZhaWxlZCcsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgc3VtbWFyeVxuICAgICAgc3VpdGUuc3VtbWFyeSA9IHRoaXMuY2FsY3VsYXRlU3VtbWFyeShzdWl0ZS5yZXN1bHRzKTtcbiAgICAgIHRoaXMuZW1pdCgnc3VpdGVDb21wbGV0ZWQnLCBzdWl0ZSk7XG5cbiAgICAgIHJldHVybiBzdWl0ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuY3VycmVudFN1aXRlID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmVuY2htYXJrIGFuYWx5dGljcyBlbmdpbmUgcGVyZm9ybWFuY2VcbiAgICovXG4gIGFzeW5jIGJlbmNobWFya0FuYWx5dGljc0VuZ2luZSgpOiBQcm9taXNlPEJlbmNobWFya1Jlc3VsdD4ge1xuICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHN0YXJ0TWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgIGNvbnN0IHN0YXJ0Q3B1ID0gcHJvY2Vzcy5jcHVVc2FnZSgpO1xuICAgIGNvbnN0IGl0ZXJhdGlvbnMgPSAxMDA7XG4gICAgbGV0IGVycm9ycyA9IDA7XG5cbiAgICBjb25zb2xlLmxvZygnQmVuY2htYXJraW5nIEFuYWx5dGljcyBFbmdpbmUuLi4nKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgdGhpcy5hbmFseXRpY3NFbmdpbmUuY2FsY3VsYXRlUmVhbHRpbWVNZXRyaWNzKCksXG4gICAgICAgICAgdGhpcy5hbmFseXRpY3NFbmdpbmUuY2FsY3VsYXRlSGlzdG9yaWNhbE1ldHJpY3MoKSxcbiAgICAgICAgICB0aGlzLmFuYWx5dGljc0VuZ2luZS5jYWxjdWxhdGVUcmVuZHMoJ2RheScsIDMwKVxuICAgICAgICBdKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGVycm9ycysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGR1cmF0aW9uID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWU7XG4gICAgY29uc3QgZW5kTWVtb3J5ID0gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpO1xuICAgIGNvbnN0IGVuZENwdSA9IHByb2Nlc3MuY3B1VXNhZ2Uoc3RhcnRDcHUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6ICdBbmFseXRpY3MgRW5naW5lJyxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGhyb3VnaHB1dDogKGl0ZXJhdGlvbnMgKiAzKSAvIChkdXJhdGlvbiAvIDEwMDApLCAvLyBvcGVyYXRpb25zIHBlciBzZWNvbmRcbiAgICAgIGVycm9yUmF0ZTogKGVycm9ycyAvIGl0ZXJhdGlvbnMpICogMTAwLFxuICAgICAgbWVtb3J5VXNhZ2U6IHtcbiAgICAgICAgcnNzOiBlbmRNZW1vcnkucnNzIC0gc3RhcnRNZW1vcnkucnNzLFxuICAgICAgICBoZWFwVG90YWw6IGVuZE1lbW9yeS5oZWFwVG90YWwgLSBzdGFydE1lbW9yeS5oZWFwVG90YWwsXG4gICAgICAgIGhlYXBVc2VkOiBlbmRNZW1vcnkuaGVhcFVzZWQgLSBzdGFydE1lbW9yeS5oZWFwVXNlZCxcbiAgICAgICAgZXh0ZXJuYWw6IGVuZE1lbW9yeS5leHRlcm5hbCAtIHN0YXJ0TWVtb3J5LmV4dGVybmFsLFxuICAgICAgICBhcnJheUJ1ZmZlcnM6IGVuZE1lbW9yeS5hcnJheUJ1ZmZlcnMgLSBzdGFydE1lbW9yeS5hcnJheUJ1ZmZlcnNcbiAgICAgIH0sXG4gICAgICBjcHVVc2FnZTogZW5kQ3B1LFxuICAgICAgaXRlcmF0aW9ucyxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKSxcbiAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgIG9wZXJhdGlvbnNQZXJJdGVyYXRpb246IDMsXG4gICAgICAgIGNhY2hlSGl0UmF0ZTogdGhpcy5hbmFseXRpY3NFbmdpbmUuZ2V0Q2FjaGVTdGF0cz8uKCk/LmhpdFJhdGUgfHwgMFxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmVuY2htYXJrIHJlcG9ydCBnZW5lcmF0aW9uIHBlcmZvcm1hbmNlXG4gICAqL1xuICBhc3luYyBiZW5jaG1hcmtSZXBvcnRHZW5lcmF0aW9uKCk6IFByb21pc2U8QmVuY2htYXJrUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc3RhcnRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3Qgc3RhcnRDcHUgPSBwcm9jZXNzLmNwdVVzYWdlKCk7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IDIwO1xuICAgIGxldCBlcnJvcnMgPSAwO1xuXG4gICAgY29uc29sZS5sb2coJ0JlbmNobWFya2luZyBSZXBvcnQgR2VuZXJhdGlvbi4uLicpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVwb3J0R2VuZXJhdG9yLmdlbmVyYXRlUmVwb3J0KCd0ZXN0LXJlcG9ydCcsIHtcbiAgICAgICAgICBzdGFydERhdGU6IG5ldyBEYXRlKERhdGUubm93KCkgLSA3ICogMjQgKiA2MCAqIDYwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICBlbmREYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBlcnJvcnMrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBkdXJhdGlvbiA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnRUaW1lO1xuICAgIGNvbnN0IGVuZE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICBjb25zdCBlbmRDcHUgPSBwcm9jZXNzLmNwdVVzYWdlKHN0YXJ0Q3B1KTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnUmVwb3J0IEdlbmVyYXRpb24nLFxuICAgICAgZHVyYXRpb24sXG4gICAgICB0aHJvdWdocHV0OiBpdGVyYXRpb25zIC8gKGR1cmF0aW9uIC8gMTAwMCksXG4gICAgICBlcnJvclJhdGU6IChlcnJvcnMgLyBpdGVyYXRpb25zKSAqIDEwMCxcbiAgICAgIG1lbW9yeVVzYWdlOiB7XG4gICAgICAgIHJzczogZW5kTWVtb3J5LnJzcyAtIHN0YXJ0TWVtb3J5LnJzcyxcbiAgICAgICAgaGVhcFRvdGFsOiBlbmRNZW1vcnkuaGVhcFRvdGFsIC0gc3RhcnRNZW1vcnkuaGVhcFRvdGFsLFxuICAgICAgICBoZWFwVXNlZDogZW5kTWVtb3J5LmhlYXBVc2VkIC0gc3RhcnRNZW1vcnkuaGVhcFVzZWQsXG4gICAgICAgIGV4dGVybmFsOiBlbmRNZW1vcnkuZXh0ZXJuYWwgLSBzdGFydE1lbW9yeS5leHRlcm5hbCxcbiAgICAgICAgYXJyYXlCdWZmZXJzOiBlbmRNZW1vcnkuYXJyYXlCdWZmZXJzIC0gc3RhcnRNZW1vcnkuYXJyYXlCdWZmZXJzXG4gICAgICB9LFxuICAgICAgY3B1VXNhZ2U6IGVuZENwdSxcbiAgICAgIGl0ZXJhdGlvbnMsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBhdmVyYWdlUmVwb3J0U2l6ZTogJ2NhbGN1bGF0ZWRfZHluYW1pY2FsbHknLFxuICAgICAgICBjYWNoZUVmZmljaWVuY3k6IHRoaXMucmVwb3J0R2VuZXJhdG9yLmdldFBlcmZvcm1hbmNlU3RhdHM/LigpIHx8IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZW5jaG1hcmsgb3B0aW1pemF0aW9uIGVuZ2luZSBwZXJmb3JtYW5jZVxuICAgKi9cbiAgYXN5bmMgYmVuY2htYXJrT3B0aW1pemF0aW9uRW5naW5lKCk6IFByb21pc2U8QmVuY2htYXJrUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc3RhcnRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3Qgc3RhcnRDcHUgPSBwcm9jZXNzLmNwdVVzYWdlKCk7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IDEwO1xuICAgIGxldCBlcnJvcnMgPSAwO1xuXG4gICAgY29uc29sZS5sb2coJ0JlbmNobWFya2luZyBPcHRpbWl6YXRpb24gRW5naW5lLi4uJyk7XG5cbiAgICBjb25zdCB0ZXN0UHJvbXB0ID0gJ0dlbmVyYXRlIGEgY29tcHJlaGVuc2l2ZSByZXBvcnQgYWJvdXQgc3lzdGVtIHBlcmZvcm1hbmNlIHdpdGggZGV0YWlsZWQgbWV0cmljcyBhbmQgcmVjb21tZW5kYXRpb25zLic7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5vcHRpbWl6YXRpb25FbmdpbmUuZ2VuZXJhdGVPcHRpbWl6YXRpb25TdWdnZXN0aW9ucyh0ZXN0UHJvbXB0LCB7XG4gICAgICAgICAgc3VjY2Vzc1JhdGU6IDkwLFxuICAgICAgICAgIHJlc3BvbnNlVGltZTogMTAwMCxcbiAgICAgICAgICBxdWFsaXR5U2NvcmU6IDg1XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCBlbmRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3QgZW5kQ3B1ID0gcHJvY2Vzcy5jcHVVc2FnZShzdGFydENwdSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ09wdGltaXphdGlvbiBFbmdpbmUnLFxuICAgICAgZHVyYXRpb24sXG4gICAgICB0aHJvdWdocHV0OiBpdGVyYXRpb25zIC8gKGR1cmF0aW9uIC8gMTAwMCksXG4gICAgICBlcnJvclJhdGU6IChlcnJvcnMgLyBpdGVyYXRpb25zKSAqIDEwMCxcbiAgICAgIG1lbW9yeVVzYWdlOiB7XG4gICAgICAgIHJzczogZW5kTWVtb3J5LnJzcyAtIHN0YXJ0TWVtb3J5LnJzcyxcbiAgICAgICAgaGVhcFRvdGFsOiBlbmRNZW1vcnkuaGVhcFRvdGFsIC0gc3RhcnRNZW1vcnkuaGVhcFRvdGFsLFxuICAgICAgICBoZWFwVXNlZDogZW5kTWVtb3J5LmhlYXBVc2VkIC0gc3RhcnRNZW1vcnkuaGVhcFVzZWQsXG4gICAgICAgIGV4dGVybmFsOiBlbmRNZW1vcnkuZXh0ZXJuYWwgLSBzdGFydE1lbW9yeS5leHRlcm5hbCxcbiAgICAgICAgYXJyYXlCdWZmZXJzOiBlbmRNZW1vcnkuYXJyYXlCdWZmZXJzIC0gc3RhcnRNZW1vcnkuYXJyYXlCdWZmZXJzXG4gICAgICB9LFxuICAgICAgY3B1VXNhZ2U6IGVuZENwdSxcbiAgICAgIGl0ZXJhdGlvbnMsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBjYWNoZVN0YXRzOiB0aGlzLm9wdGltaXphdGlvbkVuZ2luZS5nZXRDYWNoZVN0YXRzPy4oKSB8fCB7fSxcbiAgICAgICAgYXZnU3VnZ2VzdGlvbnNQZXJQcm9tcHQ6IDMuNVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmVuY2htYXJrIGRhdGFiYXNlIHF1ZXJ5IHBlcmZvcm1hbmNlXG4gICAqL1xuICBhc3luYyBiZW5jaG1hcmtEYXRhYmFzZVF1ZXJpZXMoKTogUHJvbWlzZTxCZW5jaG1hcmtSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGFydE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICBjb25zdCBzdGFydENwdSA9IHByb2Nlc3MuY3B1VXNhZ2UoKTtcbiAgICBjb25zdCBpdGVyYXRpb25zID0gNTAwO1xuICAgIGxldCBlcnJvcnMgPSAwO1xuXG4gICAgY29uc29sZS5sb2coJ0JlbmNobWFya2luZyBEYXRhYmFzZSBRdWVyaWVzLi4uJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2ltdWxhdGUgdmFyaW91cyBkYXRhYmFzZSBvcGVyYXRpb25zXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICB0aGlzLmFuYWx5dGljc0VuZ2luZS5jYWxjdWxhdGVSZWFsdGltZU1ldHJpY3MoKSxcbiAgICAgICAgICB0aGlzLmFuYWx5dGljc0VuZ2luZS5jYWxjdWxhdGVIaXN0b3JpY2FsTWV0cmljcygpXG4gICAgICAgIF0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCBlbmRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3QgZW5kQ3B1ID0gcHJvY2Vzcy5jcHVVc2FnZShzdGFydENwdSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0RhdGFiYXNlIFF1ZXJpZXMnLFxuICAgICAgZHVyYXRpb24sXG4gICAgICB0aHJvdWdocHV0OiAoaXRlcmF0aW9ucyAqIDIpIC8gKGR1cmF0aW9uIC8gMTAwMCksXG4gICAgICBlcnJvclJhdGU6IChlcnJvcnMgLyBpdGVyYXRpb25zKSAqIDEwMCxcbiAgICAgIG1lbW9yeVVzYWdlOiB7XG4gICAgICAgIHJzczogZW5kTWVtb3J5LnJzcyAtIHN0YXJ0TWVtb3J5LnJzcyxcbiAgICAgICAgaGVhcFRvdGFsOiBlbmRNZW1vcnkuaGVhcFRvdGFsIC0gc3RhcnRNZW1vcnkuaGVhcFRvdGFsLFxuICAgICAgICBoZWFwVXNlZDogZW5kTWVtb3J5LmhlYXBVc2VkIC0gc3RhcnRNZW1vcnkuaGVhcFVzZWQsXG4gICAgICAgIGV4dGVybmFsOiBlbmRNZW1vcnkuZXh0ZXJuYWwgLSBzdGFydE1lbW9yeS5leHRlcm5hbCxcbiAgICAgICAgYXJyYXlCdWZmZXJzOiBlbmRNZW1vcnkuYXJyYXlCdWZmZXJzIC0gc3RhcnRNZW1vcnkuYXJyYXlCdWZmZXJzXG4gICAgICB9LFxuICAgICAgY3B1VXNhZ2U6IGVuZENwdSxcbiAgICAgIGl0ZXJhdGlvbnMsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXG4gICAgICBtZXRhZGF0YToge1xuICAgICAgICBxdWVyaWVzUGVySXRlcmF0aW9uOiAyLFxuICAgICAgICBxdWVyeVN0YXRzOiB0aGlzLmFuYWx5dGljc0VuZ2luZS5nZXRRdWVyeVBlcmZvcm1hbmNlU3RhdHM/LigpIHx8IHt9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZW5jaG1hcmsgY2FjaGUgcGVyZm9ybWFuY2VcbiAgICovXG4gIGFzeW5jIGJlbmNobWFya0NhY2hlUGVyZm9ybWFuY2UoKTogUHJvbWlzZTxCZW5jaG1hcmtSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGFydE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICBjb25zdCBzdGFydENwdSA9IHByb2Nlc3MuY3B1VXNhZ2UoKTtcbiAgICBjb25zdCBpdGVyYXRpb25zID0gMTAwMDtcbiAgICBsZXQgZXJyb3JzID0gMDtcblxuICAgIGNvbnNvbGUubG9nKCdCZW5jaG1hcmtpbmcgQ2FjaGUgUGVyZm9ybWFuY2UuLi4nKTtcblxuICAgIC8vIFdhcm0gdXAgY2FjaGVcbiAgICBhd2FpdCB0aGlzLmFuYWx5dGljc0VuZ2luZS5jYWxjdWxhdGVSZWFsdGltZU1ldHJpY3MoKTtcbiAgICBhd2FpdCB0aGlzLmFuYWx5dGljc0VuZ2luZS5jYWxjdWxhdGVIaXN0b3JpY2FsTWV0cmljcygpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRlc3QgY2FjaGUgaGl0IHBlcmZvcm1hbmNlXG4gICAgICAgIGF3YWl0IHRoaXMuYW5hbHl0aWNzRW5naW5lLmNhbGN1bGF0ZVJlYWx0aW1lTWV0cmljcygpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCBlbmRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3QgZW5kQ3B1ID0gcHJvY2Vzcy5jcHVVc2FnZShzdGFydENwdSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0NhY2hlIFBlcmZvcm1hbmNlJyxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGhyb3VnaHB1dDogaXRlcmF0aW9ucyAvIChkdXJhdGlvbiAvIDEwMDApLFxuICAgICAgZXJyb3JSYXRlOiAoZXJyb3JzIC8gaXRlcmF0aW9ucykgKiAxMDAsXG4gICAgICBtZW1vcnlVc2FnZToge1xuICAgICAgICByc3M6IGVuZE1lbW9yeS5yc3MgLSBzdGFydE1lbW9yeS5yc3MsXG4gICAgICAgIGhlYXBUb3RhbDogZW5kTWVtb3J5LmhlYXBUb3RhbCAtIHN0YXJ0TWVtb3J5LmhlYXBUb3RhbCxcbiAgICAgICAgaGVhcFVzZWQ6IGVuZE1lbW9yeS5oZWFwVXNlZCAtIHN0YXJ0TWVtb3J5LmhlYXBVc2VkLFxuICAgICAgICBleHRlcm5hbDogZW5kTWVtb3J5LmV4dGVybmFsIC0gc3RhcnRNZW1vcnkuZXh0ZXJuYWwsXG4gICAgICAgIGFycmF5QnVmZmVyczogZW5kTWVtb3J5LmFycmF5QnVmZmVycyAtIHN0YXJ0TWVtb3J5LmFycmF5QnVmZmVyc1xuICAgICAgfSxcbiAgICAgIGNwdVVzYWdlOiBlbmRDcHUsXG4gICAgICBpdGVyYXRpb25zLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgY2FjaGVTdGF0czogdGhpcy5hbmFseXRpY3NFbmdpbmUuZ2V0Q2FjaGVTdGF0cz8uKCkgfHwge31cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEJlbmNobWFyayBtZW1vcnkgdXNhZ2UgcGF0dGVybnNcbiAgICovXG4gIGFzeW5jIGJlbmNobWFya01lbW9yeVVzYWdlKCk6IFByb21pc2U8QmVuY2htYXJrUmVzdWx0PiB7XG4gICAgY29uc3Qgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qgc3RhcnRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3Qgc3RhcnRDcHUgPSBwcm9jZXNzLmNwdVVzYWdlKCk7XG4gICAgY29uc3QgaXRlcmF0aW9ucyA9IDEwMDtcbiAgICBsZXQgZXJyb3JzID0gMDtcblxuICAgIGNvbnNvbGUubG9nKCdCZW5jaG1hcmtpbmcgTWVtb3J5IFVzYWdlLi4uJyk7XG5cbiAgICBjb25zdCBtZW1vcnlTbmFwc2hvdHMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBQZXJmb3JtIG1lbW9yeS1pbnRlbnNpdmUgb3BlcmF0aW9uc1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgdGhpcy5hbmFseXRpY3NFbmdpbmUuY2FsY3VsYXRlVHJlbmRzKCdkYXknLCAxMDApLFxuICAgICAgICAgIHRoaXMucmVwb3J0R2VuZXJhdG9yLmdlbmVyYXRlUmVwb3J0KCdtZW1vcnktdGVzdCcsIHt9KVxuICAgICAgICBdKTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRha2UgbWVtb3J5IHNuYXBzaG90XG4gICAgICAgIG1lbW9yeVNuYXBzaG90cy5wdXNoKHByb2Nlc3MubWVtb3J5VXNhZ2UoKSk7XG4gICAgICAgIFxuICAgICAgICAvLyBGb3JjZSBnYXJiYWdlIGNvbGxlY3Rpb24gaWYgYXZhaWxhYmxlXG4gICAgICAgIGlmIChnbG9iYWwuZ2MpIHtcbiAgICAgICAgICBnbG9iYWwuZ2MoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCBlbmRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3QgZW5kQ3B1ID0gcHJvY2Vzcy5jcHVVc2FnZShzdGFydENwdSk7XG5cbiAgICAvLyBDYWxjdWxhdGUgbWVtb3J5IGdyb3d0aFxuICAgIGNvbnN0IG1lbW9yeUdyb3d0aCA9IG1lbW9yeVNuYXBzaG90cy5sZW5ndGggPiAxID8gXG4gICAgICBtZW1vcnlTbmFwc2hvdHNbbWVtb3J5U25hcHNob3RzLmxlbmd0aCAtIDFdLmhlYXBVc2VkIC0gbWVtb3J5U25hcHNob3RzWzBdLmhlYXBVc2VkIDogMDtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiAnTWVtb3J5IFVzYWdlJyxcbiAgICAgIGR1cmF0aW9uLFxuICAgICAgdGhyb3VnaHB1dDogaXRlcmF0aW9ucyAvIChkdXJhdGlvbiAvIDEwMDApLFxuICAgICAgZXJyb3JSYXRlOiAoZXJyb3JzIC8gaXRlcmF0aW9ucykgKiAxMDAsXG4gICAgICBtZW1vcnlVc2FnZToge1xuICAgICAgICByc3M6IGVuZE1lbW9yeS5yc3MgLSBzdGFydE1lbW9yeS5yc3MsXG4gICAgICAgIGhlYXBUb3RhbDogZW5kTWVtb3J5LmhlYXBUb3RhbCAtIHN0YXJ0TWVtb3J5LmhlYXBUb3RhbCxcbiAgICAgICAgaGVhcFVzZWQ6IGVuZE1lbW9yeS5oZWFwVXNlZCAtIHN0YXJ0TWVtb3J5LmhlYXBVc2VkLFxuICAgICAgICBleHRlcm5hbDogZW5kTWVtb3J5LmV4dGVybmFsIC0gc3RhcnRNZW1vcnkuZXh0ZXJuYWwsXG4gICAgICAgIGFycmF5QnVmZmVyczogZW5kTWVtb3J5LmFycmF5QnVmZmVycyAtIHN0YXJ0TWVtb3J5LmFycmF5QnVmZmVyc1xuICAgICAgfSxcbiAgICAgIGNwdVVzYWdlOiBlbmRDcHUsXG4gICAgICBpdGVyYXRpb25zLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgbWVtb3J5R3Jvd3RoLFxuICAgICAgICBtZW1vcnlMZWFrRGV0ZWN0ZWQ6IG1lbW9yeUdyb3d0aCA+IDUwICogMTAyNCAqIDEwMjQsIC8vIDUwTUIgdGhyZXNob2xkXG4gICAgICAgIGdjQXZhaWxhYmxlOiB0eXBlb2YgZ2xvYmFsLmdjICE9PSAndW5kZWZpbmVkJ1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQmVuY2htYXJrIGNvbmN1cnJlbnQgb3BlcmF0aW9uc1xuICAgKi9cbiAgYXN5bmMgYmVuY2htYXJrQ29uY3VycmVudE9wZXJhdGlvbnMoKTogUHJvbWlzZTxCZW5jaG1hcmtSZXN1bHQ+IHtcbiAgICBjb25zdCBzdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBzdGFydE1lbW9yeSA9IHByb2Nlc3MubWVtb3J5VXNhZ2UoKTtcbiAgICBjb25zdCBzdGFydENwdSA9IHByb2Nlc3MuY3B1VXNhZ2UoKTtcbiAgICBjb25zdCBpdGVyYXRpb25zID0gNTA7XG4gICAgY29uc3QgY29uY3VycmVuY3kgPSAxMDtcbiAgICBsZXQgZXJyb3JzID0gMDtcblxuICAgIGNvbnNvbGUubG9nKCdCZW5jaG1hcmtpbmcgQ29uY3VycmVudCBPcGVyYXRpb25zLi4uJyk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gQ3JlYXRlIGNvbmN1cnJlbnQgb3BlcmF0aW9uc1xuICAgICAgICBjb25zdCBvcGVyYXRpb25zID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogY29uY3VycmVuY3kgfSwgKCkgPT4gXG4gICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgdGhpcy5hbmFseXRpY3NFbmdpbmUuY2FsY3VsYXRlUmVhbHRpbWVNZXRyaWNzKCksXG4gICAgICAgICAgICB0aGlzLmFuYWx5dGljc0VuZ2luZS5jYWxjdWxhdGVIaXN0b3JpY2FsTWV0cmljcygpXG4gICAgICAgICAgXSlcbiAgICAgICAgKTtcbiAgICAgICAgXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9wZXJhdGlvbnMpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZXJyb3JzKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHVyYXRpb24gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0VGltZTtcbiAgICBjb25zdCBlbmRNZW1vcnkgPSBwcm9jZXNzLm1lbW9yeVVzYWdlKCk7XG4gICAgY29uc3QgZW5kQ3B1ID0gcHJvY2Vzcy5jcHVVc2FnZShzdGFydENwdSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogJ0NvbmN1cnJlbnQgT3BlcmF0aW9ucycsXG4gICAgICBkdXJhdGlvbixcbiAgICAgIHRocm91Z2hwdXQ6IChpdGVyYXRpb25zICogY29uY3VycmVuY3kgKiAyKSAvIChkdXJhdGlvbiAvIDEwMDApLFxuICAgICAgZXJyb3JSYXRlOiAoZXJyb3JzIC8gaXRlcmF0aW9ucykgKiAxMDAsXG4gICAgICBtZW1vcnlVc2FnZToge1xuICAgICAgICByc3M6IGVuZE1lbW9yeS5yc3MgLSBzdGFydE1lbW9yeS5yc3MsXG4gICAgICAgIGhlYXBUb3RhbDogZW5kTWVtb3J5LmhlYXBUb3RhbCAtIHN0YXJ0TWVtb3J5LmhlYXBUb3RhbCxcbiAgICAgICAgaGVhcFVzZWQ6IGVuZE1lbW9yeS5oZWFwVXNlZCAtIHN0YXJ0TWVtb3J5LmhlYXBVc2VkLFxuICAgICAgICBleHRlcm5hbDogZW5kTWVtb3J5LmV4dGVybmFsIC0gc3RhcnRNZW1vcnkuZXh0ZXJuYWwsXG4gICAgICAgIGFycmF5QnVmZmVyczogZW5kTWVtb3J5LmFycmF5QnVmZmVycyAtIHN0YXJ0TWVtb3J5LmFycmF5QnVmZmVyc1xuICAgICAgfSxcbiAgICAgIGNwdVVzYWdlOiBlbmRDcHUsXG4gICAgICBpdGVyYXRpb25zLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgY29uY3VycmVuY3lMZXZlbDogY29uY3VycmVuY3ksXG4gICAgICAgIG9wZXJhdGlvbnNQZXJJdGVyYXRpb246IGNvbmN1cnJlbmN5ICogMlxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUnVuIGxvYWQgdGVzdCBzaW11bGF0aW9uXG4gICAqL1xuICBhc3luYyBydW5Mb2FkVGVzdChjb25maWc6IExvYWRUZXN0Q29uZmlnKTogUHJvbWlzZTxMb2FkVGVzdFJlc3VsdD4ge1xuICAgIGNvbnNvbGUubG9nKGBTdGFydGluZyBsb2FkIHRlc3Q6ICR7Y29uZmlnLnRhcmdldH1gKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHRzOiBMb2FkVGVzdFJlc3VsdCA9IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlc3VsdHM6IHtcbiAgICAgICAgdG90YWxSZXF1ZXN0czogMCxcbiAgICAgICAgc3VjY2Vzc2Z1bFJlcXVlc3RzOiAwLFxuICAgICAgICBmYWlsZWRSZXF1ZXN0czogMCxcbiAgICAgICAgYXZlcmFnZVJlc3BvbnNlVGltZTogMCxcbiAgICAgICAgcDk1UmVzcG9uc2VUaW1lOiAwLFxuICAgICAgICBwOTlSZXNwb25zZVRpbWU6IDAsXG4gICAgICAgIHRocm91Z2hwdXQ6IDAsXG4gICAgICAgIGVycm9yUmF0ZTogMCxcbiAgICAgICAgbWF4UmVzcG9uc2VUaW1lOiAwLFxuICAgICAgICBtaW5SZXNwb25zZVRpbWU6IEluZmluaXR5XG4gICAgICB9LFxuICAgICAgdGltZWxpbmU6IFtdXG4gICAgfTtcblxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3QgcmVzcG9uc2VUaW1lczogbnVtYmVyW10gPSBbXTtcbiAgICBcbiAgICAvLyBTaW11bGF0ZSByYW1wLXVwXG4gICAgZm9yIChsZXQgY29uY3VycmVuY3kgPSAxOyBjb25jdXJyZW5jeSA8PSBjb25maWcuY29uY3VycmVuY3k7IGNvbmN1cnJlbmN5KyspIHtcbiAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiBjb25jdXJyZW5jeSB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvblN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgb3BlcmF0aW9uIGJhc2VkIG9uIHRhcmdldFxuICAgICAgICAgIGF3YWl0IHRoaXMuc2ltdWxhdGVPcGVyYXRpb24oY29uZmlnLnRhcmdldCwgY29uZmlnLnBheWxvYWQpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBvcGVyYXRpb25TdGFydDtcbiAgICAgICAgcmVzcG9uc2VUaW1lcy5wdXNoKHJlc3BvbnNlVGltZSk7XG4gICAgICAgIFxuICAgICAgICByZXN1bHRzLnRpbWVsaW5lLnB1c2goe1xuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICByZXNwb25zZVRpbWUsXG4gICAgICAgICAgc3VjY2VzcyxcbiAgICAgICAgICBjb25jdXJyZW5jeVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgcmVzdWx0cy5yZXN1bHRzLnN1Y2Nlc3NmdWxSZXF1ZXN0cysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdHMucmVzdWx0cy5mYWlsZWRSZXF1ZXN0cysrO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXN1bHRzLnJlc3VsdHMudG90YWxSZXF1ZXN0cysrO1xuICAgICAgfSk7XG4gICAgICBcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKG9wZXJhdGlvbnMpO1xuICAgICAgXG4gICAgICAvLyBXYWl0IGZvciByYW1wLXVwIGludGVydmFsXG4gICAgICBhd2FpdCBzZXRUaW1lb3V0KGNvbmZpZy5yYW1wVXAgLyBjb25maWcuY29uY3VycmVuY3kpO1xuICAgIH1cbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcmVzdWx0c1xuICAgIGNvbnN0IHRvdGFsVGltZSA9IChEYXRlLm5vdygpIC0gc3RhcnRUaW1lKSAvIDEwMDA7XG4gICAgcmVzdWx0cy5yZXN1bHRzLmF2ZXJhZ2VSZXNwb25zZVRpbWUgPSByZXNwb25zZVRpbWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApIC8gcmVzcG9uc2VUaW1lcy5sZW5ndGg7XG4gICAgcmVzdWx0cy5yZXN1bHRzLnRocm91Z2hwdXQgPSByZXN1bHRzLnJlc3VsdHMudG90YWxSZXF1ZXN0cyAvIHRvdGFsVGltZTtcbiAgICByZXN1bHRzLnJlc3VsdHMuZXJyb3JSYXRlID0gKHJlc3VsdHMucmVzdWx0cy5mYWlsZWRSZXF1ZXN0cyAvIHJlc3VsdHMucmVzdWx0cy50b3RhbFJlcXVlc3RzKSAqIDEwMDtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgcGVyY2VudGlsZXNcbiAgICBjb25zdCBzb3J0ZWRUaW1lcyA9IHJlc3BvbnNlVGltZXMuc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIHJlc3VsdHMucmVzdWx0cy5wOTVSZXNwb25zZVRpbWUgPSBzb3J0ZWRUaW1lc1tNYXRoLmZsb29yKHNvcnRlZFRpbWVzLmxlbmd0aCAqIDAuOTUpXTtcbiAgICByZXN1bHRzLnJlc3VsdHMucDk5UmVzcG9uc2VUaW1lID0gc29ydGVkVGltZXNbTWF0aC5mbG9vcihzb3J0ZWRUaW1lcy5sZW5ndGggKiAwLjk5KV07XG4gICAgcmVzdWx0cy5yZXN1bHRzLm1heFJlc3BvbnNlVGltZSA9IE1hdGgubWF4KC4uLnJlc3BvbnNlVGltZXMpO1xuICAgIHJlc3VsdHMucmVzdWx0cy5taW5SZXNwb25zZVRpbWUgPSBNYXRoLm1pbiguLi5yZXNwb25zZVRpbWVzKTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBvcGVyYXRpb24gZm9yIGxvYWQgdGVzdGluZ1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBzaW11bGF0ZU9wZXJhdGlvbih0YXJnZXQ6IHN0cmluZywgcGF5bG9hZD86IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgICBjYXNlICdhbmFseXRpY3MnOlxuICAgICAgICBhd2FpdCB0aGlzLmFuYWx5dGljc0VuZ2luZS5jYWxjdWxhdGVSZWFsdGltZU1ldHJpY3MoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZXBvcnRzJzpcbiAgICAgICAgYXdhaXQgdGhpcy5yZXBvcnRHZW5lcmF0b3IuZ2VuZXJhdGVSZXBvcnQoJ2xvYWQtdGVzdCcsIHt9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpbWl6YXRpb24nOlxuICAgICAgICBhd2FpdCB0aGlzLm9wdGltaXphdGlvbkVuZ2luZS5nZW5lcmF0ZU9wdGltaXphdGlvblN1Z2dlc3Rpb25zKFxuICAgICAgICAgICdUZXN0IHByb21wdCBmb3IgbG9hZCB0ZXN0aW5nIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbicsXG4gICAgICAgICAgeyBzdWNjZXNzUmF0ZTogODUsIHJlc3BvbnNlVGltZTogMTAwMCB9XG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRGVmYXVsdCBvcGVyYXRpb25cbiAgICAgICAgYXdhaXQgc2V0VGltZW91dChNYXRoLnJhbmRvbSgpICogMTAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlIGJlbmNobWFyayBzdWl0ZSBzdW1tYXJ5XG4gICAqL1xuICBwcml2YXRlIGNhbGN1bGF0ZVN1bW1hcnkocmVzdWx0czogQmVuY2htYXJrUmVzdWx0W10pOiBCZW5jaG1hcmtTdWl0ZVsnc3VtbWFyeSddIHtcbiAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gcmVzdWx0cy5yZWR1Y2UoKHN1bSwgcikgPT4gc3VtICsgci5kdXJhdGlvbiwgMCk7XG4gICAgY29uc3QgYXZlcmFnZVRocm91Z2hwdXQgPSByZXN1bHRzLnJlZHVjZSgoc3VtLCByKSA9PiBzdW0gKyByLnRocm91Z2hwdXQsIDApIC8gcmVzdWx0cy5sZW5ndGg7XG4gICAgY29uc3QgYXZlcmFnZUVycm9yUmF0ZSA9IHJlc3VsdHMucmVkdWNlKChzdW0sIHIpID0+IHN1bSArIHIuZXJyb3JSYXRlLCAwKSAvIHJlc3VsdHMubGVuZ3RoO1xuICAgIGNvbnN0IHBlYWtNZW1vcnlVc2FnZSA9IE1hdGgubWF4KC4uLnJlc3VsdHMubWFwKHIgPT4gci5tZW1vcnlVc2FnZS5oZWFwVXNlZCkpO1xuICAgIFxuICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IFtdO1xuICAgIFxuICAgIC8vIEdlbmVyYXRlIHJlY29tbWVuZGF0aW9ucyBiYXNlZCBvbiByZXN1bHRzXG4gICAgaWYgKGF2ZXJhZ2VFcnJvclJhdGUgPiA1KSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnSGlnaCBlcnJvciByYXRlIGRldGVjdGVkLiBSZXZpZXcgZXJyb3IgaGFuZGxpbmcgYW5kIHN5c3RlbSBzdGFiaWxpdHkuJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChhdmVyYWdlVGhyb3VnaHB1dCA8IDEwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnTG93IHRocm91Z2hwdXQgZGV0ZWN0ZWQuIENvbnNpZGVyIG9wdGltaXppbmcgY3JpdGljYWwgcGF0aHMgYW5kIGFkZGluZyBjYWNoaW5nLicpO1xuICAgIH1cbiAgICBcbiAgICBpZiAocGVha01lbW9yeVVzYWdlID4gMTAwICogMTAyNCAqIDEwMjQpIHsgLy8gMTAwTUJcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdIaWdoIG1lbW9yeSB1c2FnZSBkZXRlY3RlZC4gUmV2aWV3IG1lbW9yeSBhbGxvY2F0aW9uIGFuZCBpbXBsZW1lbnQgZ2FyYmFnZSBjb2xsZWN0aW9uIG9wdGltaXphdGlvbi4nKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3Qgc2xvd1Jlc3VsdHMgPSByZXN1bHRzLmZpbHRlcihyID0+IHIuZHVyYXRpb24gPiAxMDAwMCk7IC8vIDEwIHNlY29uZHNcbiAgICBpZiAoc2xvd1Jlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goYFNsb3cgb3BlcmF0aW9ucyBkZXRlY3RlZDogJHtzbG93UmVzdWx0cy5tYXAociA9PiByLm5hbWUpLmpvaW4oJywgJyl9LiBDb25zaWRlciBvcHRpbWl6YXRpb24uYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICB0b3RhbER1cmF0aW9uLFxuICAgICAgYXZlcmFnZVRocm91Z2hwdXQsXG4gICAgICBhdmVyYWdlRXJyb3JSYXRlLFxuICAgICAgcGVha01lbW9yeVVzYWdlLFxuICAgICAgcmVjb21tZW5kYXRpb25zXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBiZW5jaG1hcmsgc3RhdHVzXG4gICAqL1xuICBwdWJsaWMgZ2V0U3RhdHVzKCk6IHtcbiAgICBpc1J1bm5pbmc6IGJvb2xlYW47XG4gICAgY3VycmVudFN1aXRlPzogc3RyaW5nO1xuICAgIHByb2dyZXNzPzogbnVtYmVyO1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNSdW5uaW5nOiB0aGlzLmlzUnVubmluZyxcbiAgICAgIGN1cnJlbnRTdWl0ZTogdGhpcy5jdXJyZW50U3VpdGU/Lm5hbWUsXG4gICAgICBwcm9ncmVzczogdGhpcy5jdXJyZW50U3VpdGUgPyAodGhpcy5jdXJyZW50U3VpdGUucmVzdWx0cy5sZW5ndGggLyA3KSAqIDEwMCA6IDBcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4cG9ydCBiZW5jaG1hcmsgcmVzdWx0c1xuICAgKi9cbiAgcHVibGljIGV4cG9ydFJlc3VsdHMoc3VpdGU6IEJlbmNobWFya1N1aXRlKTogc3RyaW5nIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3VpdGUsIG51bGwsIDIpO1xuICB9XG59XG5cbi8vIEV4cG9ydCBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBwZXJmb3JtYW5jZUJlbmNobWFyayA9IG5ldyBQZXJmb3JtYW5jZUJlbmNobWFyaygpOyJdLCJuYW1lcyI6WyJQZXJmb3JtYW5jZUJlbmNobWFyayIsInBlcmZvcm1hbmNlQmVuY2htYXJrIiwiRXZlbnRFbWl0dGVyIiwicnVuQmVuY2htYXJrU3VpdGUiLCJzdWl0ZU5hbWUiLCJpc1J1bm5pbmciLCJFcnJvciIsImVtaXQiLCJzdWl0ZSIsIm5hbWUiLCJyZXN1bHRzIiwic3VtbWFyeSIsInRvdGFsRHVyYXRpb24iLCJhdmVyYWdlVGhyb3VnaHB1dCIsImF2ZXJhZ2VFcnJvclJhdGUiLCJwZWFrTWVtb3J5VXNhZ2UiLCJyZWNvbW1lbmRhdGlvbnMiLCJjdXJyZW50U3VpdGUiLCJiZW5jaG1hcmtzIiwiYmVuY2htYXJrQW5hbHl0aWNzRW5naW5lIiwiYmVuY2htYXJrUmVwb3J0R2VuZXJhdGlvbiIsImJlbmNobWFya09wdGltaXphdGlvbkVuZ2luZSIsImJlbmNobWFya0RhdGFiYXNlUXVlcmllcyIsImJlbmNobWFya0NhY2hlUGVyZm9ybWFuY2UiLCJiZW5jaG1hcmtNZW1vcnlVc2FnZSIsImJlbmNobWFya0NvbmN1cnJlbnRPcGVyYXRpb25zIiwiYmVuY2htYXJrIiwicmVzdWx0IiwicHVzaCIsImVycm9yIiwiY29uc29sZSIsIm1lc3NhZ2UiLCJjYWxjdWxhdGVTdW1tYXJ5Iiwic3RhcnRUaW1lIiwicGVyZm9ybWFuY2UiLCJub3ciLCJzdGFydE1lbW9yeSIsInByb2Nlc3MiLCJtZW1vcnlVc2FnZSIsInN0YXJ0Q3B1IiwiY3B1VXNhZ2UiLCJpdGVyYXRpb25zIiwiZXJyb3JzIiwibG9nIiwiaSIsIlByb21pc2UiLCJhbGwiLCJhbmFseXRpY3NFbmdpbmUiLCJjYWxjdWxhdGVSZWFsdGltZU1ldHJpY3MiLCJjYWxjdWxhdGVIaXN0b3JpY2FsTWV0cmljcyIsImNhbGN1bGF0ZVRyZW5kcyIsImR1cmF0aW9uIiwiZW5kTWVtb3J5IiwiZW5kQ3B1IiwidGhyb3VnaHB1dCIsImVycm9yUmF0ZSIsInJzcyIsImhlYXBUb3RhbCIsImhlYXBVc2VkIiwiZXh0ZXJuYWwiLCJhcnJheUJ1ZmZlcnMiLCJ0aW1lc3RhbXAiLCJEYXRlIiwibWV0YWRhdGEiLCJvcGVyYXRpb25zUGVySXRlcmF0aW9uIiwiY2FjaGVIaXRSYXRlIiwiZ2V0Q2FjaGVTdGF0cyIsImhpdFJhdGUiLCJyZXBvcnRHZW5lcmF0b3IiLCJnZW5lcmF0ZVJlcG9ydCIsInN0YXJ0RGF0ZSIsInRvSVNPU3RyaW5nIiwiZW5kRGF0ZSIsImF2ZXJhZ2VSZXBvcnRTaXplIiwiY2FjaGVFZmZpY2llbmN5IiwiZ2V0UGVyZm9ybWFuY2VTdGF0cyIsInRlc3RQcm9tcHQiLCJvcHRpbWl6YXRpb25FbmdpbmUiLCJnZW5lcmF0ZU9wdGltaXphdGlvblN1Z2dlc3Rpb25zIiwic3VjY2Vzc1JhdGUiLCJyZXNwb25zZVRpbWUiLCJxdWFsaXR5U2NvcmUiLCJjYWNoZVN0YXRzIiwiYXZnU3VnZ2VzdGlvbnNQZXJQcm9tcHQiLCJxdWVyaWVzUGVySXRlcmF0aW9uIiwicXVlcnlTdGF0cyIsImdldFF1ZXJ5UGVyZm9ybWFuY2VTdGF0cyIsIm1lbW9yeVNuYXBzaG90cyIsImdsb2JhbCIsImdjIiwibWVtb3J5R3Jvd3RoIiwibGVuZ3RoIiwibWVtb3J5TGVha0RldGVjdGVkIiwiZ2NBdmFpbGFibGUiLCJjb25jdXJyZW5jeSIsIm9wZXJhdGlvbnMiLCJBcnJheSIsImZyb20iLCJjb25jdXJyZW5jeUxldmVsIiwicnVuTG9hZFRlc3QiLCJjb25maWciLCJ0YXJnZXQiLCJ0b3RhbFJlcXVlc3RzIiwic3VjY2Vzc2Z1bFJlcXVlc3RzIiwiZmFpbGVkUmVxdWVzdHMiLCJhdmVyYWdlUmVzcG9uc2VUaW1lIiwicDk1UmVzcG9uc2VUaW1lIiwicDk5UmVzcG9uc2VUaW1lIiwibWF4UmVzcG9uc2VUaW1lIiwibWluUmVzcG9uc2VUaW1lIiwiSW5maW5pdHkiLCJ0aW1lbGluZSIsInJlc3BvbnNlVGltZXMiLCJvcGVyYXRpb25TdGFydCIsInN1Y2Nlc3MiLCJzaW11bGF0ZU9wZXJhdGlvbiIsInBheWxvYWQiLCJzZXRUaW1lb3V0IiwicmFtcFVwIiwidG90YWxUaW1lIiwicmVkdWNlIiwiYSIsImIiLCJzb3J0ZWRUaW1lcyIsInNvcnQiLCJNYXRoIiwiZmxvb3IiLCJtYXgiLCJtaW4iLCJyYW5kb20iLCJzdW0iLCJyIiwibWFwIiwic2xvd1Jlc3VsdHMiLCJmaWx0ZXIiLCJqb2luIiwiZ2V0U3RhdHVzIiwicHJvZ3Jlc3MiLCJleHBvcnRSZXN1bHRzIiwiSlNPTiIsInN0cmluZ2lmeSIsIkFuYWx5dGljc0VuZ2luZSIsImdldEluc3RhbmNlIiwiUmVwb3J0R2VuZXJhdG9yIiwiT3B0aW1pemF0aW9uRW5naW5lIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQWlFYUE7ZUFBQUE7O1FBaW1CQUM7ZUFB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