{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/analytics/CapacityPlanner.ts"],"sourcesContent":["import { PredictiveAnalytics, CapacityPrediction } from './PredictiveAnalytics';\nimport { AnalyticsEngine } from './AnalyticsEngine';\nimport { PerformanceMonitor } from '../performance/PerformanceMonitor';\nimport { EventStore } from './EventStore';\nimport { LRUCache } from 'lru-cache';\n\nexport interface CapacityModel {\n  id: string;\n  resource: string;\n  currentCapacity: number;\n  utilizationHistory: Array<{\n    timestamp: Date;\n    utilization: number;\n    peak: number;\n    average: number;\n  }>;\n  growthTrend: {\n    rate: number; // percentage per day\n    confidence: number;\n    seasonality: {\n      daily: number[];\n      weekly: number[];\n      monthly: number[];\n    };\n  };\n  thresholds: {\n    warning: number; // utilization percentage\n    critical: number;\n    maximum: number;\n  };\n  forecasts: Array<{\n    timeframe: string;\n    predictedUtilization: number;\n    confidence: number;\n    willExceedThreshold: boolean;\n    recommendedAction: string;\n  }>;\n}\n\nexport interface ScalingRecommendation {\n  id: string;\n  resource: string;\n  currentState: {\n    capacity: number;\n    utilization: number;\n    performance: string;\n  };\n  recommendation: {\n    action: 'scale_up' | 'scale_down' | 'maintain' | 'optimize';\n    targetCapacity: number;\n    timeframe: string;\n    priority: 'low' | 'medium' | 'high' | 'critical';\n    estimatedCost: number;\n    expectedBenefit: string;\n  };\n  reasoning: {\n    factors: string[];\n    dataPoints: Array<{\n      metric: string;\n      current: number;\n      predicted: number;\n      threshold: number;\n    }>;\n    riskAssessment: {\n      level: 'low' | 'medium' | 'high';\n      factors: string[];\n    };\n  };\n  implementation: {\n    steps: string[];\n    estimatedTime: string;\n    rollbackPlan: string[];\n    monitoringPoints: string[];\n  };\n}\n\nexport interface CapacityAlert {\n  id: string;\n  timestamp: Date;\n  resource: string;\n  alertType: 'threshold_exceeded' | 'prediction_warning' | 'capacity_exhaustion' | 'optimization_opportunity';\n  severity: 'info' | 'warning' | 'critical';\n  current: {\n    utilization: number;\n    capacity: number;\n    performance: any;\n  };\n  prediction: {\n    timeToThreshold: Date | null;\n    peakUtilization: number;\n    confidence: number;\n  };\n  message: string;\n  recommendations: string[];\n  autoResolve: boolean;\n  resolved: boolean;\n}\n\nexport interface ResourceMetrics {\n  cpu: {\n    cores: number;\n    utilization: number;\n    peak24h: number;\n    average24h: number;\n    trend: number;\n  };\n  memory: {\n    total: number;\n    used: number;\n    utilization: number;\n    peak24h: number;\n    average24h: number;\n    trend: number;\n  };\n  storage: {\n    total: number;\n    used: number;\n    utilization: number;\n    iops: number;\n    throughput: number;\n    trend: number;\n  };\n  network: {\n    bandwidth: number;\n    utilization: number;\n    latency: number;\n    packetLoss: number;\n    trend: number;\n  };\n  application: {\n    concurrent_users: number;\n    requests_per_second: number;\n    queue_size: number;\n    response_time: number;\n    error_rate: number;\n  };\n}\n\nexport class CapacityPlanner {\n  private predictiveAnalytics: PredictiveAnalytics;\n  private analyticsEngine: AnalyticsEngine;\n  private performanceMonitor: PerformanceMonitor;\n  private eventStore: EventStore;\n  private cache: LRUCache<string, any>;\n  private capacityModels: Map<string, CapacityModel>;\n  private alerts: Map<string, CapacityAlert>;\n  private recommendations: Map<string, ScalingRecommendation>;\n  private isMonitoring: boolean = false;\n  private monitoringInterval: NodeJS.Timeout | null = null;\n\n  constructor() {\n    this.predictiveAnalytics = new PredictiveAnalytics();\n    this.analyticsEngine = AnalyticsEngine.getInstance();\n    this.performanceMonitor = new PerformanceMonitor();\n    this.eventStore = EventStore.getInstance();\n    \n    this.cache = new LRUCache({\n      max: 100,\n      ttl: 1000 * 60 * 15 // 15 minutes cache\n    });\n\n    this.capacityModels = new Map();\n    this.alerts = new Map();\n    this.recommendations = new Map();\n\n    this.initializeCapacityModels();\n  }\n\n  /**\n   * Start capacity monitoring and planning\n   */\n  public startMonitoring(intervalMs: number = 300000): void { // 5 minutes default\n    if (this.isMonitoring) {\n      console.log('Capacity monitoring already running');\n      return;\n    }\n\n    this.isMonitoring = true;\n    console.log(`Starting capacity monitoring with ${intervalMs}ms interval`);\n\n    this.monitoringInterval = setInterval(async () => {\n      try {\n        await this.performCapacityAnalysis();\n      } catch (error) {\n        console.error('Error during capacity analysis:', error);\n      }\n    }, intervalMs);\n\n    // Perform initial analysis\n    this.performCapacityAnalysis();\n  }\n\n  /**\n   * Stop capacity monitoring\n   */\n  public stopMonitoring(): void {\n    if (!this.isMonitoring) return;\n\n    this.isMonitoring = false;\n    \n    if (this.monitoringInterval) {\n      clearInterval(this.monitoringInterval);\n      this.monitoringInterval = null;\n    }\n\n    console.log('Capacity monitoring stopped');\n  }\n\n  /**\n   * Generate comprehensive capacity forecast\n   */\n  public async generateCapacityForecast(\n    resources: string[] = ['cpu', 'memory', 'storage', 'network'],\n    timeframes: string[] = ['1h', '6h', '24h', '7d', '30d']\n  ): Promise<Map<string, CapacityPrediction[]>> {\n    const forecasts = new Map<string, CapacityPrediction[]>();\n\n    for (const resource of resources) {\n      const resourceForecasts: CapacityPrediction[] = [];\n\n      for (const timeframe of timeframes) {\n        try {\n          const prediction = await this.predictiveAnalytics.predictCapacity(\n            `${resource}_usage`,\n            timeframe as any\n          );\n          resourceForecasts.push(prediction);\n        } catch (error) {\n          console.warn(`Failed to generate forecast for ${resource} at ${timeframe}:`, error.message);\n        }\n      }\n\n      if (resourceForecasts.length > 0) {\n        forecasts.set(resource, resourceForecasts);\n      }\n    }\n\n    return forecasts;\n  }\n\n  /**\n   * Generate scaling recommendations\n   */\n  public async generateScalingRecommendations(): Promise<ScalingRecommendation[]> {\n    const recommendations: ScalingRecommendation[] = [];\n    const currentMetrics = await this.getCurrentResourceMetrics();\n\n    // Analyze each resource type\n    for (const [resource, metrics] of Object.entries(currentMetrics)) {\n      if (resource === 'application') continue; // Skip application metrics for scaling\n\n      try {\n        const recommendation = await this.analyzeResourceScaling(resource, metrics);\n        if (recommendation) {\n          recommendations.push(recommendation);\n          this.recommendations.set(recommendation.id, recommendation);\n        }\n      } catch (error) {\n        console.error(`Error analyzing scaling for ${resource}:`, error);\n      }\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Analyze resource scaling needs\n   */\n  private async analyzeResourceScaling(\n    resource: string,\n    metrics: any\n  ): Promise<ScalingRecommendation | null> {\n    const utilizationKey = `${resource}_utilization`;\n    const currentUtilization = metrics.utilization || 0;\n    \n    // Get capacity model for this resource\n    const model = this.capacityModels.get(resource);\n    if (!model) {\n      await this.createCapacityModel(resource);\n    }\n\n    // Get predictions for different timeframes\n    const predictions = await Promise.all([\n      this.predictiveAnalytics.predictCapacity(`${resource}_usage`, '6h'),\n      this.predictiveAnalytics.predictCapacity(`${resource}_usage`, '24h'),\n      this.predictiveAnalytics.predictCapacity(`${resource}_usage`, '7d')\n    ]);\n\n    // Determine scaling action\n    const scalingAction = this.determineScalingAction(currentUtilization, predictions, model);\n    \n    if (scalingAction.action === 'maintain') {\n      return null; // No scaling needed\n    }\n\n    // Calculate target capacity\n    const targetCapacity = this.calculateTargetCapacity(\n      resource,\n      currentUtilization,\n      predictions,\n      scalingAction.action\n    );\n\n    // Estimate cost and benefit\n    const costBenefit = this.estimateCostBenefit(resource, scalingAction.action, targetCapacity);\n\n    // Assess risks\n    const riskAssessment = this.assessScalingRisks(resource, scalingAction.action, predictions);\n\n    const recommendation: ScalingRecommendation = {\n      id: `scaling_${resource}_${Date.now()}`,\n      resource,\n      currentState: {\n        capacity: metrics.total || metrics.cores || 100,\n        utilization: currentUtilization,\n        performance: this.assessPerformance(resource, metrics)\n      },\n      recommendation: {\n        action: scalingAction.action,\n        targetCapacity,\n        timeframe: scalingAction.timeframe,\n        priority: scalingAction.priority,\n        estimatedCost: costBenefit.cost,\n        expectedBenefit: costBenefit.benefit\n      },\n      reasoning: {\n        factors: scalingAction.factors,\n        dataPoints: predictions.map(p => ({\n          metric: p.metric,\n          current: p.currentValue,\n          predicted: p.predictedValue,\n          threshold: p.threshold\n        })),\n        riskAssessment\n      },\n      implementation: {\n        steps: this.generateImplementationSteps(resource, scalingAction.action),\n        estimatedTime: this.estimateImplementationTime(resource, scalingAction.action),\n        rollbackPlan: this.generateRollbackPlan(resource, scalingAction.action),\n        monitoringPoints: this.generateMonitoringPoints(resource)\n      }\n    };\n\n    return recommendation;\n  }\n\n  /**\n   * Create growth projections with ML models\n   */\n  public async createGrowthProjections(\n    resource: string,\n    projectionDays: number = 30\n  ): Promise<{\n    current: number;\n    projected: number;\n    growthRate: number;\n    seasonality: {\n      daily: number[];\n      weekly: number[];\n    };\n    scenarios: {\n      optimistic: number;\n      realistic: number;\n      pessimistic: number;\n    };\n    recommendations: string[];\n  }> {\n    const cacheKey = `growth_projection_${resource}_${projectionDays}`;\n    const cached = this.cache.get(cacheKey);\n    if (cached) return cached;\n\n    // Get growth projections from predictive analytics\n    const projections = await this.predictiveAnalytics.getGrowthProjections(\n      `${resource}_usage`,\n      projectionDays\n    );\n\n    // Analyze seasonality patterns\n    const seasonality = await this.analyzeSeasonality(resource, projectionDays * 2);\n\n    // Generate different scenarios\n    const scenarios = this.generateScenarios(projections.projected, projections.growthRate);\n\n    // Generate recommendations based on projections\n    const recommendations = this.generateGrowthRecommendations(\n      resource,\n      projections.current,\n      scenarios,\n      projections.growthRate\n    );\n\n    const result = {\n      current: projections.current,\n      projected: projections.projected,\n      growthRate: projections.growthRate,\n      seasonality,\n      scenarios,\n      recommendations\n    };\n\n    this.cache.set(cacheKey, result);\n    return result;\n  }\n\n  /**\n   * Generate capacity optimization recommendations\n   */\n  public async generateOptimizationRecommendations(): Promise<{\n    cpu: string[];\n    memory: string[];\n    storage: string[];\n    network: string[];\n    application: string[];\n    cost: string[];\n  }> {\n    const recommendations = {\n      cpu: [],\n      memory: [],\n      storage: [],\n      network: [],\n      application: [],\n      cost: []\n    };\n\n    const metrics = await this.getCurrentResourceMetrics();\n    const forecasts = await this.generateCapacityForecast();\n\n    // CPU optimization\n    if (metrics.cpu.utilization < 30) {\n      recommendations.cpu.push('CPU utilization is low - consider downsizing instances');\n      recommendations.cost.push('Potential cost savings from CPU optimization');\n    } else if (metrics.cpu.utilization > 80) {\n      recommendations.cpu.push('CPU utilization is high - consider scaling up or optimizing workloads');\n    }\n\n    // Memory optimization\n    if (metrics.memory.utilization < 40) {\n      recommendations.memory.push('Memory utilization is low - review memory allocation');\n      recommendations.cost.push('Potential cost savings from memory optimization');\n    } else if (metrics.memory.utilization > 85) {\n      recommendations.memory.push('Memory utilization is high - consider adding memory or optimizing usage');\n    }\n\n    // Storage optimization\n    if (metrics.storage.utilization > 80) {\n      recommendations.storage.push('Storage utilization is high - plan for capacity expansion');\n    }\n    if (metrics.storage.iops > 1000) {\n      recommendations.storage.push('High IOPS detected - consider faster storage or caching');\n    }\n\n    // Network optimization\n    if (metrics.network.latency > 100) {\n      recommendations.network.push('High network latency detected - investigate network bottlenecks');\n    }\n    if (metrics.network.utilization > 70) {\n      recommendations.network.push('Network utilization is high - consider bandwidth upgrade');\n    }\n\n    // Application optimization\n    if (metrics.application.response_time > 2000) {\n      recommendations.application.push('High response times - optimize application performance');\n    }\n    if (metrics.application.queue_size > 100) {\n      recommendations.application.push('Large queue size - consider horizontal scaling');\n    }\n    if (metrics.application.error_rate > 1) {\n      recommendations.application.push('High error rate - investigate and fix application issues');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get capacity alerts\n   */\n  public getCapacityAlerts(): CapacityAlert[] {\n    return Array.from(this.alerts.values())\n      .filter(alert => !alert.resolved)\n      .sort((a, b) => {\n        const severityOrder = { critical: 3, warning: 2, info: 1 };\n        return severityOrder[b.severity] - severityOrder[a.severity];\n      });\n  }\n\n  /**\n   * Get capacity dashboard data\n   */\n  public async getCapacityDashboard(): Promise<{\n    overview: {\n      totalResources: number;\n      resourcesAtRisk: number;\n      upcomingThresholds: number;\n      optimizationOpportunities: number;\n    };\n    resources: ResourceMetrics;\n    alerts: CapacityAlert[];\n    recommendations: ScalingRecommendation[];\n    forecasts: any;\n    trends: {\n      cpu: number[];\n      memory: number[];\n      storage: number[];\n      network: number[];\n    };\n  }> {\n    const [resources, alerts, recommendations, forecasts, trends] = await Promise.all([\n      this.getCurrentResourceMetrics(),\n      Promise.resolve(this.getCapacityAlerts()),\n      this.generateScalingRecommendations(),\n      this.generateCapacityForecast(),\n      this.getResourceTrends()\n    ]);\n\n    const resourcesAtRisk = alerts.filter(a => a.severity === 'critical').length;\n    const upcomingThresholds = alerts.filter(a => \n      a.alertType === 'prediction_warning' && \n      a.prediction.timeToThreshold\n    ).length;\n    const optimizationOpportunities = recommendations.filter(r => \n      r.recommendation.action === 'optimize'\n    ).length;\n\n    return {\n      overview: {\n        totalResources: Object.keys(resources).length - 1, // Exclude application\n        resourcesAtRisk,\n        upcomingThresholds,\n        optimizationOpportunities\n      },\n      resources,\n      alerts,\n      recommendations,\n      forecasts: Object.fromEntries(forecasts),\n      trends\n    };\n  }\n\n  // Private helper methods\n\n  private async initializeCapacityModels(): Promise<void> {\n    const resources = ['cpu', 'memory', 'storage', 'network'];\n    \n    for (const resource of resources) {\n      try {\n        await this.createCapacityModel(resource);\n      } catch (error) {\n        console.warn(`Failed to initialize capacity model for ${resource}:`, error.message);\n      }\n    }\n  }\n\n  private async createCapacityModel(resource: string): Promise<CapacityModel> {\n    // Get historical utilization data\n    const utilizationHistory = await this.getUtilizationHistory(resource, 30); // 30 days\n\n    // Calculate growth trend\n    const growthTrend = this.calculateGrowthTrend(utilizationHistory);\n\n    // Analyze seasonality\n    const seasonality = await this.analyzeSeasonality(resource, 30);\n\n    // Set thresholds based on resource type\n    const thresholds = this.getResourceThresholds(resource);\n\n    // Generate forecasts\n    const forecasts = await this.generateResourceForecasts(resource);\n\n    const model: CapacityModel = {\n      id: `capacity_${resource}_${Date.now()}`,\n      resource,\n      currentCapacity: await this.getCurrentCapacity(resource),\n      utilizationHistory,\n      growthTrend: {\n        rate: growthTrend.rate,\n        confidence: growthTrend.confidence,\n        seasonality\n      },\n      thresholds,\n      forecasts\n    };\n\n    this.capacityModels.set(resource, model);\n    return model;\n  }\n\n  private async performCapacityAnalysis(): Promise<void> {\n    try {\n      // Update capacity models\n      for (const resource of this.capacityModels.keys()) {\n        await this.updateCapacityModel(resource);\n      }\n\n      // Check for threshold violations\n      await this.checkCapacityThresholds();\n\n      // Generate alerts if needed\n      await this.generateCapacityAlerts();\n\n      // Update cache\n      this.cache.set('last_analysis', {\n        timestamp: new Date(),\n        models: this.capacityModels.size,\n        alerts: this.alerts.size\n      });\n\n    } catch (error) {\n      console.error('Error during capacity analysis:', error);\n    }\n  }\n\n  private async updateCapacityModel(resource: string): Promise<void> {\n    const model = this.capacityModels.get(resource);\n    if (!model) return;\n\n    // Get latest utilization data\n    const latestUtilization = await this.getLatestUtilization(resource);\n    \n    // Update utilization history\n    model.utilizationHistory.push({\n      timestamp: new Date(),\n      utilization: latestUtilization.current,\n      peak: latestUtilization.peak,\n      average: latestUtilization.average\n    });\n\n    // Keep only last 1000 data points\n    if (model.utilizationHistory.length > 1000) {\n      model.utilizationHistory = model.utilizationHistory.slice(-1000);\n    }\n\n    // Recalculate growth trend\n    model.growthTrend = {\n      ...model.growthTrend,\n      rate: this.calculateGrowthTrend(model.utilizationHistory).rate\n    };\n\n    // Update forecasts\n    model.forecasts = await this.generateResourceForecasts(resource);\n  }\n\n  private async checkCapacityThresholds(): Promise<void> {\n    const metrics = await this.getCurrentResourceMetrics();\n\n    for (const [resource, resourceMetrics] of Object.entries(metrics)) {\n      if (resource === 'application') continue;\n\n      const model = this.capacityModels.get(resource);\n      if (!model) continue;\n\n      const utilization = resourceMetrics.utilization || 0;\n\n      // Check immediate thresholds\n      if (utilization > model.thresholds.critical) {\n        this.createCapacityAlert(\n          resource,\n          'threshold_exceeded',\n          'critical',\n          `${resource} utilization exceeded critical threshold`,\n          utilization,\n          model\n        );\n      } else if (utilization > model.thresholds.warning) {\n        this.createCapacityAlert(\n          resource,\n          'threshold_exceeded',\n          'warning',\n          `${resource} utilization exceeded warning threshold`,\n          utilization,\n          model\n        );\n      }\n\n      // Check predictions\n      const predictions = await this.predictiveAnalytics.predictCapacity(`${resource}_usage`, '24h');\n      \n      if (predictions.willExceedThreshold && predictions.timeToThreshold) {\n        this.createCapacityAlert(\n          resource,\n          'prediction_warning',\n          'warning',\n          `${resource} predicted to exceed threshold within 24 hours`,\n          utilization,\n          model,\n          predictions.timeToThreshold\n        );\n      }\n    }\n  }\n\n  private createCapacityAlert(\n    resource: string,\n    alertType: CapacityAlert['alertType'],\n    severity: CapacityAlert['severity'],\n    message: string,\n    currentUtilization: number,\n    model: CapacityModel,\n    timeToThreshold?: Date\n  ): void {\n    const alertId = `capacity_${resource}_${alertType}_${Date.now()}`;\n    \n    // Check if similar alert already exists\n    const existingAlert = Array.from(this.alerts.values())\n      .find(alert => \n        alert.resource === resource && \n        alert.alertType === alertType &&\n        !alert.resolved &&\n        (Date.now() - alert.timestamp.getTime()) < 30 * 60 * 1000 // 30 minutes\n      );\n\n    if (existingAlert) return; // Don't create duplicate alerts\n\n    const alert: CapacityAlert = {\n      id: alertId,\n      timestamp: new Date(),\n      resource,\n      alertType,\n      severity,\n      current: {\n        utilization: currentUtilization,\n        capacity: model.currentCapacity,\n        performance: {} // Would include performance metrics\n      },\n      prediction: {\n        timeToThreshold,\n        peakUtilization: Math.max(...model.utilizationHistory.map(h => h.peak)),\n        confidence: model.growthTrend.confidence\n      },\n      message,\n      recommendations: this.generateAlertRecommendations(resource, alertType, currentUtilization),\n      autoResolve: severity === 'info',\n      resolved: false\n    };\n\n    this.alerts.set(alertId, alert);\n    console.log(`Capacity alert created: ${message}`);\n  }\n\n  private generateAlertRecommendations(\n    resource: string,\n    alertType: string,\n    utilization: number\n  ): string[] {\n    const recommendations: string[] = [];\n\n    if (alertType === 'threshold_exceeded') {\n      recommendations.push(`Immediate action required for ${resource}`);\n      recommendations.push('Consider scaling resources');\n      recommendations.push('Investigate high utilization causes');\n    }\n\n    if (alertType === 'prediction_warning') {\n      recommendations.push(`Plan capacity expansion for ${resource}`);\n      recommendations.push('Monitor growth trends closely');\n      recommendations.push('Prepare scaling procedures');\n    }\n\n    if (utilization > 90) {\n      recommendations.push('Critical utilization - immediate scaling recommended');\n    }\n\n    return recommendations;\n  }\n\n  // Additional helper methods would be implemented here...\n  // (Simplified for space considerations)\n\n  private async getCurrentResourceMetrics(): Promise<ResourceMetrics> {\n    // Implementation to get current resource metrics\n    return {\n      cpu: { cores: 4, utilization: 65, peak24h: 80, average24h: 60, trend: 0.5 },\n      memory: { total: 16000, used: 10000, utilization: 62.5, peak24h: 75, average24h: 58, trend: 0.3 },\n      storage: { total: 1000000, used: 600000, utilization: 60, iops: 500, throughput: 100, trend: 0.8 },\n      network: { bandwidth: 1000, utilization: 40, latency: 50, packetLoss: 0.1, trend: 0.2 },\n      application: { concurrent_users: 150, requests_per_second: 45, queue_size: 12, response_time: 800, error_rate: 0.5 }\n    };\n  }\n\n  private determineScalingAction(\n    currentUtilization: number,\n    predictions: CapacityPrediction[],\n    model?: CapacityModel\n  ): {\n    action: ScalingRecommendation['recommendation']['action'];\n    timeframe: string;\n    priority: ScalingRecommendation['recommendation']['priority'];\n    factors: string[];\n  } {\n    const factors: string[] = [];\n    let action: ScalingRecommendation['recommendation']['action'] = 'maintain';\n    let priority: ScalingRecommendation['recommendation']['priority'] = 'low';\n    let timeframe = 'within 7 days';\n\n    // Determine action based on current utilization and predictions\n    const maxPredicted = Math.max(...predictions.map(p => p.predictedValue));\n    \n    if (currentUtilization > 85 || maxPredicted > 90) {\n      action = 'scale_up';\n      priority = 'high';\n      timeframe = 'within 24 hours';\n      factors.push('High current or predicted utilization');\n    } else if (currentUtilization < 20 && maxPredicted < 30) {\n      action = 'scale_down';\n      priority = 'medium';\n      timeframe = 'within 7 days';\n      factors.push('Low utilization indicates over-provisioning');\n    } else if (currentUtilization > 70) {\n      action = 'optimize';\n      priority = 'medium';\n      factors.push('Moderate utilization - optimization opportunities exist');\n    }\n\n    return { action, timeframe, priority, factors };\n  }\n\n  private calculateTargetCapacity(\n    resource: string,\n    currentUtilization: number,\n    predictions: CapacityPrediction[],\n    action: string\n  ): number {\n    const maxPredicted = Math.max(...predictions.map(p => p.predictedValue));\n    \n    switch (action) {\n      case 'scale_up':\n        // Target 70% utilization of new capacity\n        return Math.ceil((maxPredicted * 1.2) / 0.7);\n      case 'scale_down':\n        // Target 60% utilization of new capacity\n        return Math.ceil((maxPredicted * 1.1) / 0.6);\n      default:\n        return 100; // Maintain current\n    }\n  }\n\n  private estimateCostBenefit(\n    resource: string,\n    action: string,\n    targetCapacity: number\n  ): { cost: number; benefit: string } {\n    // Simplified cost estimation\n    const baseCost = { cpu: 100, memory: 50, storage: 20, network: 30 }[resource] || 50;\n    \n    let cost = 0;\n    let benefit = '';\n\n    switch (action) {\n      case 'scale_up':\n        cost = baseCost * 1.5;\n        benefit = 'Improved performance and reliability';\n        break;\n      case 'scale_down':\n        cost = -baseCost * 0.3; // Cost savings\n        benefit = 'Reduced operational costs';\n        break;\n      case 'optimize':\n        cost = baseCost * 0.1;\n        benefit = 'Better resource utilization without scaling';\n        break;\n    }\n\n    return { cost, benefit };\n  }\n\n  private assessScalingRisks(\n    resource: string,\n    action: string,\n    predictions: CapacityPrediction[]\n  ): { level: 'low' | 'medium' | 'high'; factors: string[] } {\n    const factors: string[] = [];\n    let level: 'low' | 'medium' | 'high' = 'low';\n\n    const confidence = Math.min(...predictions.map(p => p.confidence));\n    \n    if (confidence < 0.7) {\n      factors.push('Low prediction confidence');\n      level = 'medium';\n    }\n\n    if (action === 'scale_down') {\n      factors.push('Risk of performance degradation');\n      level = level === 'medium' ? 'high' : 'medium';\n    }\n\n    if (action === 'scale_up') {\n      factors.push('Increased operational costs');\n    }\n\n    return { level, factors };\n  }\n\n  private generateImplementationSteps(resource: string, action: string): string[] {\n    const baseSteps = [\n      'Create backup of current configuration',\n      'Plan maintenance window',\n      'Notify stakeholders'\n    ];\n\n    switch (action) {\n      case 'scale_up':\n        return [\n          ...baseSteps,\n          `Add additional ${resource} capacity`,\n          'Update load balancer configuration',\n          'Test new capacity',\n          'Monitor performance'\n        ];\n      case 'scale_down':\n        return [\n          ...baseSteps,\n          'Drain traffic from excess capacity',\n          `Remove unnecessary ${resource} resources`,\n          'Update monitoring thresholds',\n          'Verify performance maintained'\n        ];\n      case 'optimize':\n        return [\n          ...baseSteps,\n          `Analyze ${resource} usage patterns`,\n          'Implement optimization recommendations',\n          'Monitor performance improvements',\n          'Document optimizations'\n        ];\n      default:\n        return baseSteps;\n    }\n  }\n\n  private estimateImplementationTime(resource: string, action: string): string {\n    const timeMap = {\n      scale_up: '2-4 hours',\n      scale_down: '1-2 hours',\n      optimize: '4-8 hours',\n      maintain: '0 hours'\n    };\n    return timeMap[action] || '2-4 hours';\n  }\n\n  private generateRollbackPlan(resource: string, action: string): string[] {\n    return [\n      'Monitor key performance indicators',\n      'Identify performance degradation',\n      'Restore previous configuration',\n      'Verify system stability',\n      'Document rollback reasons'\n    ];\n  }\n\n  private generateMonitoringPoints(resource: string): string[] {\n    return [\n      `${resource} utilization`,\n      `${resource} performance metrics`,\n      'Application response times',\n      'Error rates',\n      'User experience metrics'\n    ];\n  }\n\n  // Additional helper methods (simplified implementations)\n  private async getUtilizationHistory(resource: string, days: number): Promise<any[]> { return []; }\n  private calculateGrowthTrend(history: any[]): { rate: number; confidence: number } { return { rate: 0.1, confidence: 0.8 }; }\n  private async analyzeSeasonality(resource: string, days: number): Promise<{ daily: number[]; weekly: number[]; monthly: number[] }> { \n    return { daily: new Array(24).fill(0), weekly: new Array(7).fill(0), monthly: new Array(12).fill(0) }; \n  }\n  private getResourceThresholds(resource: string): { warning: number; critical: number; maximum: number } {\n    return { warning: 70, critical: 85, maximum: 95 };\n  }\n  private async generateResourceForecasts(resource: string): Promise<any[]> { return []; }\n  private async getCurrentCapacity(resource: string): Promise<number> { return 100; }\n  private async getLatestUtilization(resource: string): Promise<{ current: number; peak: number; average: number }> {\n    return { current: 65, peak: 80, average: 60 };\n  }\n  private async generateCapacityAlerts(): Promise<void> {}\n  private generateScenarios(projected: number, growthRate: number): { optimistic: number; realistic: number; pessimistic: number } {\n    return {\n      optimistic: projected * 0.8,\n      realistic: projected,\n      pessimistic: projected * 1.3\n    };\n  }\n  private generateGrowthRecommendations(resource: string, current: number, scenarios: any, growthRate: number): string[] {\n    return ['Monitor growth trends', 'Plan for capacity expansion', 'Optimize resource usage'];\n  }\n  private assessPerformance(resource: string, metrics: any): string {\n    const utilization = metrics.utilization || 0;\n    if (utilization > 85) return 'poor';\n    if (utilization > 70) return 'fair';\n    return 'good';\n  }\n  private async getResourceTrends(): Promise<{ cpu: number[]; memory: number[]; storage: number[]; network: number[] }> {\n    return {\n      cpu: [60, 62, 65, 63, 68, 70, 65],\n      memory: [55, 58, 60, 62, 59, 61, 63],\n      storage: [50, 52, 55, 58, 60, 62, 60],\n      network: [35, 38, 40, 42, 39, 41, 40]\n    };\n  }\n}\n\nexport const capacityPlanner = new CapacityPlanner();"],"names":["CapacityPlanner","capacityPlanner","startMonitoring","intervalMs","isMonitoring","console","log","monitoringInterval","setInterval","performCapacityAnalysis","error","stopMonitoring","clearInterval","generateCapacityForecast","resources","timeframes","forecasts","Map","resource","resourceForecasts","timeframe","prediction","predictiveAnalytics","predictCapacity","push","warn","message","length","set","generateScalingRecommendations","recommendations","currentMetrics","getCurrentResourceMetrics","metrics","Object","entries","recommendation","analyzeResourceScaling","id","utilizationKey","currentUtilization","utilization","model","capacityModels","get","createCapacityModel","predictions","Promise","all","scalingAction","determineScalingAction","action","targetCapacity","calculateTargetCapacity","costBenefit","estimateCostBenefit","riskAssessment","assessScalingRisks","Date","now","currentState","capacity","total","cores","performance","assessPerformance","priority","estimatedCost","cost","expectedBenefit","benefit","reasoning","factors","dataPoints","map","p","metric","current","currentValue","predicted","predictedValue","threshold","implementation","steps","generateImplementationSteps","estimatedTime","estimateImplementationTime","rollbackPlan","generateRollbackPlan","monitoringPoints","generateMonitoringPoints","createGrowthProjections","projectionDays","cacheKey","cached","cache","projections","getGrowthProjections","seasonality","analyzeSeasonality","scenarios","generateScenarios","projected","growthRate","generateGrowthRecommendations","result","generateOptimizationRecommendations","cpu","memory","storage","network","application","iops","latency","response_time","queue_size","error_rate","getCapacityAlerts","Array","from","alerts","values","filter","alert","resolved","sort","a","b","severityOrder","critical","warning","info","severity","getCapacityDashboard","trends","resolve","getResourceTrends","resourcesAtRisk","upcomingThresholds","alertType","timeToThreshold","optimizationOpportunities","r","overview","totalResources","keys","fromEntries","initializeCapacityModels","utilizationHistory","getUtilizationHistory","growthTrend","calculateGrowthTrend","thresholds","getResourceThresholds","generateResourceForecasts","currentCapacity","getCurrentCapacity","rate","confidence","updateCapacityModel","checkCapacityThresholds","generateCapacityAlerts","timestamp","models","size","latestUtilization","getLatestUtilization","peak","average","slice","resourceMetrics","createCapacityAlert","willExceedThreshold","alertId","existingAlert","find","getTime","peakUtilization","Math","max","h","generateAlertRecommendations","autoResolve","peak24h","average24h","trend","used","throughput","bandwidth","packetLoss","concurrent_users","requests_per_second","maxPredicted","ceil","baseCost","level","min","baseSteps","timeMap","scale_up","scale_down","optimize","maintain","days","history","daily","fill","weekly","monthly","maximum","optimistic","realistic","pessimistic","analyticsEngine","performanceMonitor","eventStore","PredictiveAnalytics","AnalyticsEngine","getInstance","PerformanceMonitor","EventStore","LRUCache","ttl"],"mappings":"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"}