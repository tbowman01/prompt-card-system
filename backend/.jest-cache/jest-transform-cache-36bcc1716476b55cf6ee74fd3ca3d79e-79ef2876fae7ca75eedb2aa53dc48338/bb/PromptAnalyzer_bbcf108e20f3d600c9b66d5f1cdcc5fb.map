{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/optimization/PromptAnalyzer.ts"],"sourcesContent":["import { EventStore } from '../analytics/EventStore';\nimport { AnalyticsEngine } from '../analytics/AnalyticsEngine';\nimport { llmService } from '../llmService';\nimport { EnhancedAssertionResult } from '../assertions/AssertionEngine';\n\nexport interface PromptAnalysisResult {\n  promptId: string;\n  analysisId: string;\n  effectiveness: {\n    score: number; // 0-100\n    category: 'poor' | 'fair' | 'good' | 'excellent';\n    reasoning: string;\n  };\n  patterns: {\n    successPatterns: string[];\n    failurePatterns: string[];\n    commonErrors: string[];\n  };\n  metrics: {\n    averageResponseTime: number;\n    successRate: number;\n    totalExecutions: number;\n    consistencyScore: number;\n  };\n  recommendations: {\n    priority: 'low' | 'medium' | 'high' | 'critical';\n    type: 'structure' | 'clarity' | 'specificity' | 'context' | 'security';\n    suggestion: string;\n    expectedImprovement: number; // percentage\n  }[];\n  trends: {\n    performanceOverTime: Array<{ timestamp: Date; score: number }>;\n    successRateOverTime: Array<{ timestamp: Date; rate: number }>;\n  };\n  securityIssues: {\n    severity: 'low' | 'medium' | 'high' | 'critical';\n    type: 'injection' | 'leakage' | 'manipulation' | 'compliance';\n    description: string;\n    recommendation: string;\n  }[];\n  timestamp: Date;\n}\n\nexport interface PromptComparisonResult {\n  promptA: string;\n  promptB: string;\n  winner: 'A' | 'B' | 'tie';\n  confidence: number;\n  metrics: {\n    responseTime: { A: number; B: number };\n    successRate: { A: number; B: number };\n    qualityScore: { A: number; B: number };\n  };\n  analysis: string;\n}\n\nexport class PromptAnalyzer {\n  private eventStore: EventStore;\n  private analyticsEngine: AnalyticsEngine;\n  \n  constructor() {\n    this.eventStore = EventStore.getInstance();\n    this.analyticsEngine = AnalyticsEngine.getInstance();\n  }\n\n  /**\n   * Analyze prompt effectiveness using historical data and AI insights\n   */\n  async analyzePrompt(\n    promptId: string,\n    promptText: string,\n    timeRange: { start: Date; end: Date } = this.getDefaultTimeRange()\n  ): Promise<PromptAnalysisResult> {\n    const analysisId = `analysis_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    try {\n      // Gather historical execution data\n      const executionEvents = await this.eventStore.getEvents({\n        event_type: 'test_execution',\n        start_time: timeRange.start,\n        end_time: timeRange.end\n      });\n\n      const promptExecutions = executionEvents.filter(event => \n        event.entity_id === promptId || event.data.prompt_id === promptId\n      );\n\n      // Calculate basic metrics\n      const metrics = this.calculatePromptMetrics(promptExecutions);\n      \n      // Analyze patterns using AI\n      const patterns = await this.analyzeExecutionPatterns(promptExecutions, promptText);\n      \n      // Generate effectiveness score\n      const effectiveness = this.calculateEffectivenessScore(metrics, patterns);\n      \n      // Generate AI-powered recommendations\n      const recommendations = await this.generateRecommendations(\n        promptText, \n        metrics, \n        patterns, \n        effectiveness\n      );\n      \n      // Calculate trends\n      const trends = this.calculateTrends(promptExecutions);\n      \n      // Perform security analysis\n      const securityIssues = await this.analyzeSecurityIssues(promptText);\n      \n      const result: PromptAnalysisResult = {\n        promptId,\n        analysisId,\n        effectiveness,\n        patterns,\n        metrics,\n        recommendations,\n        trends,\n        securityIssues,\n        timestamp: new Date()\n      };\n\n      // Store analysis result\n      await this.eventStore.recordEvent({\n        event_type: 'prompt_analysis',\n        entity_id: promptId,\n        entity_type: 'prompt',\n        data: result,\n        timestamp: new Date()\n      });\n\n      return result;\n    } catch (error) {\n      console.error('Error analyzing prompt:', error);\n      throw new Error(`Prompt analysis failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Compare two prompts and determine which performs better\n   */\n  async comparePrompts(\n    promptA: string,\n    promptB: string,\n    testCases: Array<{ input: string; expectedOutput: string }>,\n    model: string = 'llama3'\n  ): Promise<PromptComparisonResult> {\n    try {\n      const resultsA = await this.testPromptPerformance(promptA, testCases, model);\n      const resultsB = await this.testPromptPerformance(promptB, testCases, model);\n      \n      const metricsA = this.calculateTestMetrics(resultsA);\n      const metricsB = this.calculateTestMetrics(resultsB);\n      \n      // Determine winner based on weighted scoring\n      const scoreA = this.calculateWeightedScore(metricsA);\n      const scoreB = this.calculateWeightedScore(metricsB);\n      \n      let winner: 'A' | 'B' | 'tie';\n      let confidence: number;\n      \n      if (Math.abs(scoreA - scoreB) < 0.1) {\n        winner = 'tie';\n        confidence = 1 - Math.abs(scoreA - scoreB);\n      } else if (scoreA > scoreB) {\n        winner = 'A';\n        confidence = (scoreA - scoreB) / Math.max(scoreA, scoreB);\n      } else {\n        winner = 'B';\n        confidence = (scoreB - scoreA) / Math.max(scoreA, scoreB);\n      }\n      \n      // Generate AI analysis\n      const analysisPrompt = `\n        Compare these two prompts and their performance:\n        \n        Prompt A: \"${promptA}\"\n        Metrics A: Response Time: ${metricsA.responseTime}ms, Success Rate: ${metricsA.successRate}%, Quality: ${metricsA.qualityScore}\n        \n        Prompt B: \"${promptB}\"  \n        Metrics B: Response Time: ${metricsB.responseTime}ms, Success Rate: ${metricsB.successRate}%, Quality: ${metricsB.qualityScore}\n        \n        Provide a detailed analysis of the differences and why one performs better.\n      `;\n      \n      const analysis = await llmService.generate(analysisPrompt, model);\n      \n      return {\n        promptA,\n        promptB,\n        winner,\n        confidence,\n        metrics: {\n          responseTime: { A: metricsA.responseTime, B: metricsB.responseTime },\n          successRate: { A: metricsA.successRate, B: metricsB.successRate },\n          qualityScore: { A: metricsA.qualityScore, B: metricsB.qualityScore }\n        },\n        analysis: analysis.response\n      };\n    } catch (error) {\n      console.error('Error comparing prompts:', error);\n      throw new Error(`Prompt comparison failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Get evolution history of a prompt\n   */\n  async getPromptEvolution(promptId: string): Promise<Array<{\n    version: string;\n    timestamp: Date;\n    changes: string[];\n    performance: {\n      successRate: number;\n      responseTime: number;\n      qualityScore: number;\n    };\n    reasoning: string;\n  }>> {\n    const evolutionEvents = await this.eventStore.getEvents({\n      event_type: 'prompt_evolution',\n      entity_id: promptId\n    });\n    \n    return evolutionEvents.map(event => event.data);\n  }\n\n  /**\n   * Calculate basic metrics from execution events\n   */\n  private calculatePromptMetrics(executionEvents: any[]): PromptAnalysisResult['metrics'] {\n    if (executionEvents.length === 0) {\n      return {\n        averageResponseTime: 0,\n        successRate: 0,\n        totalExecutions: 0,\n        consistencyScore: 0\n      };\n    }\n\n    const totalExecutions = executionEvents.length;\n    const successfulExecutions = executionEvents.filter(e => e.data.passed).length;\n    const averageResponseTime = executionEvents.reduce((sum, e) => sum + e.data.execution_time, 0) / totalExecutions;\n    \n    // Calculate consistency score based on response time variance\n    const responseTimes = executionEvents.map(e => e.data.execution_time);\n    const variance = this.calculateVariance(responseTimes);\n    const consistencyScore = Math.max(0, 100 - (variance / averageResponseTime) * 100);\n    \n    return {\n      averageResponseTime,\n      successRate: (successfulExecutions / totalExecutions) * 100,\n      totalExecutions,\n      consistencyScore\n    };\n  }\n\n  /**\n   * Analyze execution patterns using AI\n   */\n  private async analyzeExecutionPatterns(\n    executionEvents: any[], \n    promptText: string\n  ): Promise<PromptAnalysisResult['patterns']> {\n    const successfulEvents = executionEvents.filter(e => e.data.passed);\n    const failedEvents = executionEvents.filter(e => !e.data.passed);\n    \n    const analysisPrompt = `\n      Analyze this prompt and its execution patterns:\n      \n      Prompt: \"${promptText}\"\n      \n      Successful executions: ${successfulEvents.length}\n      Failed executions: ${failedEvents.length}\n      \n      Based on this data, identify:\n      1. Patterns that lead to success\n      2. Patterns that lead to failure  \n      3. Common errors or issues\n      \n      Return a JSON object with arrays for successPatterns, failurePatterns, and commonErrors.\n    `;\n    \n    try {\n      const analysis = await llmService.generate(analysisPrompt);\n      const patterns = JSON.parse(analysis.response);\n      \n      return {\n        successPatterns: patterns.successPatterns || [],\n        failurePatterns: patterns.failurePatterns || [],\n        commonErrors: patterns.commonErrors || []\n      };\n    } catch (error) {\n      console.error('Error analyzing patterns:', error);\n      return {\n        successPatterns: [],\n        failurePatterns: [],\n        commonErrors: []\n      };\n    }\n  }\n\n  /**\n   * Calculate effectiveness score\n   */\n  private calculateEffectivenessScore(\n    metrics: PromptAnalysisResult['metrics'],\n    patterns: PromptAnalysisResult['patterns']\n  ): PromptAnalysisResult['effectiveness'] {\n    // Weighted scoring: Success Rate (40%), Response Time (30%), Consistency (20%), Pattern Quality (10%)\n    const successScore = metrics.successRate; // 0-100\n    const responseTimeScore = Math.max(0, 100 - (metrics.averageResponseTime / 1000) * 10); // Penalize slow responses\n    const consistencyScore = metrics.consistencyScore; // 0-100\n    const patternScore = Math.max(0, 100 - patterns.failurePatterns.length * 10); // Penalize failure patterns\n    \n    const weightedScore = (\n      successScore * 0.4 + \n      responseTimeScore * 0.3 + \n      consistencyScore * 0.2 + \n      patternScore * 0.1\n    );\n    \n    let category: 'poor' | 'fair' | 'good' | 'excellent';\n    let reasoning: string;\n    \n    if (weightedScore >= 85) {\n      category = 'excellent';\n      reasoning = 'High success rate with consistent performance and minimal failure patterns';\n    } else if (weightedScore >= 70) {\n      category = 'good';\n      reasoning = 'Good performance with room for minor improvements';\n    } else if (weightedScore >= 50) {\n      category = 'fair';\n      reasoning = 'Average performance with noticeable issues that need attention';\n    } else {\n      category = 'poor';\n      reasoning = 'Poor performance with significant issues requiring immediate attention';\n    }\n    \n    return {\n      score: Math.round(weightedScore),\n      category,\n      reasoning\n    };\n  }\n\n  /**\n   * Generate AI-powered recommendations\n   */\n  private async generateRecommendations(\n    promptText: string,\n    metrics: PromptAnalysisResult['metrics'],\n    patterns: PromptAnalysisResult['patterns'],\n    effectiveness: PromptAnalysisResult['effectiveness']\n  ): Promise<PromptAnalysisResult['recommendations']> {\n    const recommendationPrompt = `\n      Analyze this prompt and provide improvement recommendations:\n      \n      Prompt: \"${promptText}\"\n      \n      Current Performance:\n      - Success Rate: ${metrics.successRate}%\n      - Average Response Time: ${metrics.averageResponseTime}ms\n      - Consistency Score: ${metrics.consistencyScore}%\n      - Effectiveness: ${effectiveness.score}/100 (${effectiveness.category})\n      \n      Failure Patterns: ${patterns.failurePatterns.join(', ')}\n      Common Errors: ${patterns.commonErrors.join(', ')}\n      \n      Provide specific, actionable recommendations to improve this prompt.\n      Return a JSON array with objects containing: priority, type, suggestion, expectedImprovement.\n    `;\n    \n    try {\n      const response = await llmService.generate(recommendationPrompt);\n      const recommendations = JSON.parse(response.response);\n      \n      return recommendations.map((rec: any) => ({\n        priority: rec.priority || 'medium',\n        type: rec.type || 'structure',\n        suggestion: rec.suggestion || 'No specific suggestion provided',\n        expectedImprovement: rec.expectedImprovement || 5\n      }));\n    } catch (error) {\n      console.error('Error generating recommendations:', error);\n      return [\n        {\n          priority: 'medium' as const,\n          type: 'structure' as const,\n          suggestion: 'Consider adding more specific instructions and examples',\n          expectedImprovement: 10\n        }\n      ];\n    }\n  }\n\n  /**\n   * Calculate trends from execution data\n   */\n  private calculateTrends(executionEvents: any[]): PromptAnalysisResult['trends'] {\n    const groupedByHour = this.groupEventsByHour(executionEvents);\n    \n    const performanceOverTime = groupedByHour.map(group => ({\n      timestamp: group.timestamp,\n      score: group.events.length > 0 ? \n        group.events.reduce((sum, e) => sum + (e.data.passed ? 100 : 0), 0) / group.events.length : 0\n    }));\n    \n    const successRateOverTime = groupedByHour.map(group => ({\n      timestamp: group.timestamp,\n      rate: group.events.length > 0 ? \n        group.events.filter(e => e.data.passed).length / group.events.length : 0\n    }));\n    \n    return {\n      performanceOverTime,\n      successRateOverTime\n    };\n  }\n\n  /**\n   * Analyze security issues in prompt\n   */\n  private async analyzeSecurityIssues(promptText: string): Promise<PromptAnalysisResult['securityIssues']> {\n    const securityIssues: PromptAnalysisResult['securityIssues'] = [];\n    \n    // Check for prompt injection patterns\n    const injectionPatterns = [\n      /ignore.*previous.*instructions/i,\n      /system.*prompt/i,\n      /role.*play/i,\n      /jailbreak/i,\n      /pretend.*you.*are/i,\n      /forget.*everything/i,\n      /new.*instructions/i,\n      /override.*safety/i\n    ];\n    \n    for (const pattern of injectionPatterns) {\n      if (pattern.test(promptText)) {\n        securityIssues.push({\n          severity: 'high',\n          type: 'injection',\n          description: `Potential prompt injection pattern detected: ${pattern.source}`,\n          recommendation: 'Review and sanitize prompt to prevent injection attacks'\n        });\n      }\n    }\n    \n    // Check for sensitive information leakage\n    const sensitivePatterns = [\n      /password/i,\n      /api.*key/i,\n      /secret/i,\n      /token/i,\n      /credential/i,\n      /private.*key/i\n    ];\n    \n    for (const pattern of sensitivePatterns) {\n      if (pattern.test(promptText)) {\n        securityIssues.push({\n          severity: 'critical',\n          type: 'leakage',\n          description: `Potential sensitive information detected: ${pattern.source}`,\n          recommendation: 'Remove or mask sensitive information from prompt'\n        });\n      }\n    }\n    \n    // Check for manipulation attempts\n    const manipulationPatterns = [\n      /you.*must/i,\n      /you.*have.*to/i,\n      /required.*to/i,\n      /bypass.*restrictions/i,\n      /special.*permissions/i\n    ];\n    \n    for (const pattern of manipulationPatterns) {\n      if (pattern.test(promptText)) {\n        securityIssues.push({\n          severity: 'medium',\n          type: 'manipulation',\n          description: `Potential manipulation attempt detected: ${pattern.source}`,\n          recommendation: 'Review prompt for manipulative language'\n        });\n      }\n    }\n    \n    return securityIssues;\n  }\n\n  /**\n   * Test prompt performance with given test cases\n   */\n  private async testPromptPerformance(\n    prompt: string,\n    testCases: Array<{ input: string; expectedOutput: string }>,\n    model: string\n  ): Promise<Array<{ responseTime: number; success: boolean; quality: number }>> {\n    const results = [];\n    \n    for (const testCase of testCases) {\n      const startTime = Date.now();\n      const fullPrompt = `${prompt}\\n\\nInput: ${testCase.input}`;\n      \n      try {\n        const response = await llmService.generate(fullPrompt, model);\n        const responseTime = Date.now() - startTime;\n        \n        // Simple quality scoring based on similarity to expected output\n        const quality = this.calculateResponseQuality(response.response, testCase.expectedOutput);\n        const success = quality > 0.7; // Consider success if quality > 70%\n        \n        results.push({ responseTime, success, quality });\n      } catch (error) {\n        results.push({ responseTime: Date.now() - startTime, success: false, quality: 0 });\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Calculate metrics from test results\n   */\n  private calculateTestMetrics(results: Array<{ responseTime: number; success: boolean; quality: number }>) {\n    const totalTests = results.length;\n    const successfulTests = results.filter(r => r.success).length;\n    const averageResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / totalTests;\n    const averageQuality = results.reduce((sum, r) => sum + r.quality, 0) / totalTests;\n    \n    return {\n      responseTime: averageResponseTime,\n      successRate: (successfulTests / totalTests) * 100,\n      qualityScore: averageQuality * 100\n    };\n  }\n\n  /**\n   * Calculate weighted score for comparison\n   */\n  private calculateWeightedScore(metrics: { responseTime: number; successRate: number; qualityScore: number }) {\n    // Normalize response time (lower is better)\n    const normalizedResponseTime = Math.max(0, 100 - (metrics.responseTime / 1000) * 10);\n    \n    // Weighted scoring: Success Rate (40%), Quality (40%), Response Time (20%)\n    return (\n      metrics.successRate * 0.4 + \n      metrics.qualityScore * 0.4 + \n      normalizedResponseTime * 0.2\n    ) / 100;\n  }\n\n  /**\n   * Calculate response quality using simple similarity\n   */\n  private calculateResponseQuality(response: string, expected: string): number {\n    const responseWords = response.toLowerCase().split(/\\s+/);\n    const expectedWords = expected.toLowerCase().split(/\\s+/);\n    \n    const commonWords = responseWords.filter(word => expectedWords.includes(word));\n    const similarity = commonWords.length / Math.max(responseWords.length, expectedWords.length);\n    \n    return Math.min(1, similarity * 2); // Boost similarity score\n  }\n\n  /**\n   * Group events by hour\n   */\n  private groupEventsByHour(events: any[]): Array<{ timestamp: Date; events: any[] }> {\n    const groups = new Map<string, any[]>();\n    \n    events.forEach(event => {\n      const timestamp = new Date(event.timestamp);\n      const hourKey = `${timestamp.getFullYear()}-${timestamp.getMonth()}-${timestamp.getDate()}-${timestamp.getHours()}`;\n      \n      if (!groups.has(hourKey)) {\n        groups.set(hourKey, []);\n      }\n      groups.get(hourKey)!.push(event);\n    });\n    \n    return Array.from(groups.entries())\n      .map(([key, events]) => {\n        const parts = key.split('-').map(Number);\n        const timestamp = new Date(parts[0], parts[1], parts[2], parts[3]);\n        return { timestamp, events };\n      })\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n  }\n\n  /**\n   * Calculate variance of an array of numbers\n   */\n  private calculateVariance(numbers: number[]): number {\n    const mean = numbers.reduce((sum, num) => sum + num, 0) / numbers.length;\n    const squaredDiffs = numbers.map(num => Math.pow(num - mean, 2));\n    return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / numbers.length;\n  }\n\n  /**\n   * Get default time range (last 7 days)\n   */\n  private getDefaultTimeRange(): { start: Date; end: Date } {\n    const end = new Date();\n    const start = new Date();\n    start.setDate(end.getDate() - 7);\n    return { start, end };\n  }\n}\n\n// Export singleton instance\nexport const promptAnalyzer = new PromptAnalyzer();"],"names":["PromptAnalyzer","promptAnalyzer","analyzePrompt","promptId","promptText","timeRange","getDefaultTimeRange","analysisId","Date","now","Math","random","toString","substr","executionEvents","eventStore","getEvents","event_type","start_time","start","end_time","end","promptExecutions","filter","event","entity_id","data","prompt_id","metrics","calculatePromptMetrics","patterns","analyzeExecutionPatterns","effectiveness","calculateEffectivenessScore","recommendations","generateRecommendations","trends","calculateTrends","securityIssues","analyzeSecurityIssues","result","timestamp","recordEvent","entity_type","error","console","Error","message","comparePrompts","promptA","promptB","testCases","model","resultsA","testPromptPerformance","resultsB","metricsA","calculateTestMetrics","metricsB","scoreA","calculateWeightedScore","scoreB","winner","confidence","abs","max","analysisPrompt","responseTime","successRate","qualityScore","analysis","llmService","generate","A","B","response","getPromptEvolution","evolutionEvents","map","length","averageResponseTime","totalExecutions","consistencyScore","successfulExecutions","e","passed","reduce","sum","execution_time","responseTimes","variance","calculateVariance","successfulEvents","failedEvents","JSON","parse","successPatterns","failurePatterns","commonErrors","successScore","responseTimeScore","patternScore","weightedScore","category","reasoning","score","round","recommendationPrompt","join","rec","priority","type","suggestion","expectedImprovement","groupedByHour","groupEventsByHour","performanceOverTime","group","events","successRateOverTime","rate","injectionPatterns","pattern","test","push","severity","description","source","recommendation","sensitivePatterns","manipulationPatterns","prompt","results","testCase","startTime","fullPrompt","input","quality","calculateResponseQuality","expectedOutput","success","totalTests","successfulTests","r","averageQuality","normalizedResponseTime","expected","responseWords","toLowerCase","split","expectedWords","commonWords","word","includes","similarity","min","groups","Map","forEach","hourKey","getFullYear","getMonth","getDate","getHours","has","set","get","Array","from","entries","key","parts","Number","sort","a","b","getTime","numbers","mean","num","squaredDiffs","pow","diff","setDate","analyticsEngine","EventStore","getInstance","AnalyticsEngine"],"mappings":";;;;;;;;;;;QAwDaA;eAAAA;;QA8iBAC;eAAAA;;;4BAtmBc;iCACK;4BACL;;;;;;;;;;;;;;AAsDpB,MAAMD;IASX;;GAEC,GACD,MAAME,cACJC,QAAgB,EAChBC,UAAkB,EAClBC,YAAwC,IAAI,CAACC,mBAAmB,EAAE,EACnC;QAC/B,MAAMC,aAAa,CAAC,SAAS,EAAEC,KAAKC,GAAG,GAAG,CAAC,EAAEC,KAAKC,MAAM,GAAGC,QAAQ,CAAC,IAAIC,MAAM,CAAC,GAAG,IAAI;QAEtF,IAAI;YACF,mCAAmC;YACnC,MAAMC,kBAAkB,MAAM,IAAI,CAACC,UAAU,CAACC,SAAS,CAAC;gBACtDC,YAAY;gBACZC,YAAYb,UAAUc,KAAK;gBAC3BC,UAAUf,UAAUgB,GAAG;YACzB;YAEA,MAAMC,mBAAmBR,gBAAgBS,MAAM,CAACC,CAAAA,QAC9CA,MAAMC,SAAS,KAAKtB,YAAYqB,MAAME,IAAI,CAACC,SAAS,KAAKxB;YAG3D,0BAA0B;YAC1B,MAAMyB,UAAU,IAAI,CAACC,sBAAsB,CAACP;YAE5C,4BAA4B;YAC5B,MAAMQ,WAAW,MAAM,IAAI,CAACC,wBAAwB,CAACT,kBAAkBlB;YAEvE,+BAA+B;YAC/B,MAAM4B,gBAAgB,IAAI,CAACC,2BAA2B,CAACL,SAASE;YAEhE,sCAAsC;YACtC,MAAMI,kBAAkB,MAAM,IAAI,CAACC,uBAAuB,CACxD/B,YACAwB,SACAE,UACAE;YAGF,mBAAmB;YACnB,MAAMI,SAAS,IAAI,CAACC,eAAe,CAACf;YAEpC,4BAA4B;YAC5B,MAAMgB,iBAAiB,MAAM,IAAI,CAACC,qBAAqB,CAACnC;YAExD,MAAMoC,SAA+B;gBACnCrC;gBACAI;gBACAyB;gBACAF;gBACAF;gBACAM;gBACAE;gBACAE;gBACAG,WAAW,IAAIjC;YACjB;YAEA,wBAAwB;YACxB,MAAM,IAAI,CAACO,UAAU,CAAC2B,WAAW,CAAC;gBAChCzB,YAAY;gBACZQ,WAAWtB;gBACXwC,aAAa;gBACbjB,MAAMc;gBACNC,WAAW,IAAIjC;YACjB;YAEA,OAAOgC;QACT,EAAE,OAAOI,OAAO;YACdC,QAAQD,KAAK,CAAC,2BAA2BA;YACzC,MAAM,IAAIE,MAAM,CAAC,wBAAwB,EAAEF,iBAAiBE,QAAQF,MAAMG,OAAO,GAAG,iBAAiB;QACvG;IACF;IAEA;;GAEC,GACD,MAAMC,eACJC,OAAe,EACfC,OAAe,EACfC,SAA2D,EAC3DC,QAAgB,QAAQ,EACS;QACjC,IAAI;YACF,MAAMC,WAAW,MAAM,IAAI,CAACC,qBAAqB,CAACL,SAASE,WAAWC;YACtE,MAAMG,WAAW,MAAM,IAAI,CAACD,qBAAqB,CAACJ,SAASC,WAAWC;YAEtE,MAAMI,WAAW,IAAI,CAACC,oBAAoB,CAACJ;YAC3C,MAAMK,WAAW,IAAI,CAACD,oBAAoB,CAACF;YAE3C,6CAA6C;YAC7C,MAAMI,SAAS,IAAI,CAACC,sBAAsB,CAACJ;YAC3C,MAAMK,SAAS,IAAI,CAACD,sBAAsB,CAACF;YAE3C,IAAII;YACJ,IAAIC;YAEJ,IAAIrD,KAAKsD,GAAG,CAACL,SAASE,UAAU,KAAK;gBACnCC,SAAS;gBACTC,aAAa,IAAIrD,KAAKsD,GAAG,CAACL,SAASE;YACrC,OAAO,IAAIF,SAASE,QAAQ;gBAC1BC,SAAS;gBACTC,aAAa,AAACJ,CAAAA,SAASE,MAAK,IAAKnD,KAAKuD,GAAG,CAACN,QAAQE;YACpD,OAAO;gBACLC,SAAS;gBACTC,aAAa,AAACF,CAAAA,SAASF,MAAK,IAAKjD,KAAKuD,GAAG,CAACN,QAAQE;YACpD;YAEA,uBAAuB;YACvB,MAAMK,iBAAiB,CAAC;;;mBAGX,EAAEjB,QAAQ;kCACK,EAAEO,SAASW,YAAY,CAAC,kBAAkB,EAAEX,SAASY,WAAW,CAAC,YAAY,EAAEZ,SAASa,YAAY,CAAC;;mBAEpH,EAAEnB,QAAQ;kCACK,EAAEQ,SAASS,YAAY,CAAC,kBAAkB,EAAET,SAASU,WAAW,CAAC,YAAY,EAAEV,SAASW,YAAY,CAAC;;;MAGjI,CAAC;YAED,MAAMC,WAAW,MAAMC,sBAAU,CAACC,QAAQ,CAACN,gBAAgBd;YAE3D,OAAO;gBACLH;gBACAC;gBACAY;gBACAC;gBACAnC,SAAS;oBACPuC,cAAc;wBAAEM,GAAGjB,SAASW,YAAY;wBAAEO,GAAGhB,SAASS,YAAY;oBAAC;oBACnEC,aAAa;wBAAEK,GAAGjB,SAASY,WAAW;wBAAEM,GAAGhB,SAASU,WAAW;oBAAC;oBAChEC,cAAc;wBAAEI,GAAGjB,SAASa,YAAY;wBAAEK,GAAGhB,SAASW,YAAY;oBAAC;gBACrE;gBACAC,UAAUA,SAASK,QAAQ;YAC7B;QACF,EAAE,OAAO/B,OAAO;YACdC,QAAQD,KAAK,CAAC,4BAA4BA;YAC1C,MAAM,IAAIE,MAAM,CAAC,0BAA0B,EAAEF,iBAAiBE,QAAQF,MAAMG,OAAO,GAAG,iBAAiB;QACzG;IACF;IAEA;;GAEC,GACD,MAAM6B,mBAAmBzE,QAAgB,EAUrC;QACF,MAAM0E,kBAAkB,MAAM,IAAI,CAAC9D,UAAU,CAACC,SAAS,CAAC;YACtDC,YAAY;YACZQ,WAAWtB;QACb;QAEA,OAAO0E,gBAAgBC,GAAG,CAACtD,CAAAA,QAASA,MAAME,IAAI;IAChD;IAEA;;GAEC,GACD,AAAQG,uBAAuBf,eAAsB,EAAmC;QACtF,IAAIA,gBAAgBiE,MAAM,KAAK,GAAG;YAChC,OAAO;gBACLC,qBAAqB;gBACrBZ,aAAa;gBACba,iBAAiB;gBACjBC,kBAAkB;YACpB;QACF;QAEA,MAAMD,kBAAkBnE,gBAAgBiE,MAAM;QAC9C,MAAMI,uBAAuBrE,gBAAgBS,MAAM,CAAC6D,CAAAA,IAAKA,EAAE1D,IAAI,CAAC2D,MAAM,EAAEN,MAAM;QAC9E,MAAMC,sBAAsBlE,gBAAgBwE,MAAM,CAAC,CAACC,KAAKH,IAAMG,MAAMH,EAAE1D,IAAI,CAAC8D,cAAc,EAAE,KAAKP;QAEjG,8DAA8D;QAC9D,MAAMQ,gBAAgB3E,gBAAgBgE,GAAG,CAACM,CAAAA,IAAKA,EAAE1D,IAAI,CAAC8D,cAAc;QACpE,MAAME,WAAW,IAAI,CAACC,iBAAiB,CAACF;QACxC,MAAMP,mBAAmBxE,KAAKuD,GAAG,CAAC,GAAG,MAAM,AAACyB,WAAWV,sBAAuB;QAE9E,OAAO;YACLA;YACAZ,aAAa,AAACe,uBAAuBF,kBAAmB;YACxDA;YACAC;QACF;IACF;IAEA;;GAEC,GACD,MAAcnD,yBACZjB,eAAsB,EACtBV,UAAkB,EACyB;QAC3C,MAAMwF,mBAAmB9E,gBAAgBS,MAAM,CAAC6D,CAAAA,IAAKA,EAAE1D,IAAI,CAAC2D,MAAM;QAClE,MAAMQ,eAAe/E,gBAAgBS,MAAM,CAAC6D,CAAAA,IAAK,CAACA,EAAE1D,IAAI,CAAC2D,MAAM;QAE/D,MAAMnB,iBAAiB,CAAC;;;eAGb,EAAE9D,WAAW;;6BAEC,EAAEwF,iBAAiBb,MAAM,CAAC;yBAC9B,EAAEc,aAAad,MAAM,CAAC;;;;;;;;IAQ3C,CAAC;QAED,IAAI;YACF,MAAMT,WAAW,MAAMC,sBAAU,CAACC,QAAQ,CAACN;YAC3C,MAAMpC,WAAWgE,KAAKC,KAAK,CAACzB,SAASK,QAAQ;YAE7C,OAAO;gBACLqB,iBAAiBlE,SAASkE,eAAe,IAAI,EAAE;gBAC/CC,iBAAiBnE,SAASmE,eAAe,IAAI,EAAE;gBAC/CC,cAAcpE,SAASoE,YAAY,IAAI,EAAE;YAC3C;QACF,EAAE,OAAOtD,OAAO;YACdC,QAAQD,KAAK,CAAC,6BAA6BA;YAC3C,OAAO;gBACLoD,iBAAiB,EAAE;gBACnBC,iBAAiB,EAAE;gBACnBC,cAAc,EAAE;YAClB;QACF;IACF;IAEA;;GAEC,GACD,AAAQjE,4BACNL,OAAwC,EACxCE,QAA0C,EACH;QACvC,sGAAsG;QACtG,MAAMqE,eAAevE,QAAQwC,WAAW,EAAE,QAAQ;QAClD,MAAMgC,oBAAoB1F,KAAKuD,GAAG,CAAC,GAAG,MAAM,AAACrC,QAAQoD,mBAAmB,GAAG,OAAQ,KAAK,0BAA0B;QAClH,MAAME,mBAAmBtD,QAAQsD,gBAAgB,EAAE,QAAQ;QAC3D,MAAMmB,eAAe3F,KAAKuD,GAAG,CAAC,GAAG,MAAMnC,SAASmE,eAAe,CAAClB,MAAM,GAAG,KAAK,4BAA4B;QAE1G,MAAMuB,gBACJH,eAAe,MACfC,oBAAoB,MACpBlB,mBAAmB,MACnBmB,eAAe;QAGjB,IAAIE;QACJ,IAAIC;QAEJ,IAAIF,iBAAiB,IAAI;YACvBC,WAAW;YACXC,YAAY;QACd,OAAO,IAAIF,iBAAiB,IAAI;YAC9BC,WAAW;YACXC,YAAY;QACd,OAAO,IAAIF,iBAAiB,IAAI;YAC9BC,WAAW;YACXC,YAAY;QACd,OAAO;YACLD,WAAW;YACXC,YAAY;QACd;QAEA,OAAO;YACLC,OAAO/F,KAAKgG,KAAK,CAACJ;YAClBC;YACAC;QACF;IACF;IAEA;;GAEC,GACD,MAAcrE,wBACZ/B,UAAkB,EAClBwB,OAAwC,EACxCE,QAA0C,EAC1CE,aAAoD,EACF;QAClD,MAAM2E,uBAAuB,CAAC;;;eAGnB,EAAEvG,WAAW;;;sBAGN,EAAEwB,QAAQwC,WAAW,CAAC;+BACb,EAAExC,QAAQoD,mBAAmB,CAAC;2BAClC,EAAEpD,QAAQsD,gBAAgB,CAAC;uBAC/B,EAAElD,cAAcyE,KAAK,CAAC,MAAM,EAAEzE,cAAcuE,QAAQ,CAAC;;wBAEpD,EAAEzE,SAASmE,eAAe,CAACW,IAAI,CAAC,MAAM;qBACzC,EAAE9E,SAASoE,YAAY,CAACU,IAAI,CAAC,MAAM;;;;IAIpD,CAAC;QAED,IAAI;YACF,MAAMjC,WAAW,MAAMJ,sBAAU,CAACC,QAAQ,CAACmC;YAC3C,MAAMzE,kBAAkB4D,KAAKC,KAAK,CAACpB,SAASA,QAAQ;YAEpD,OAAOzC,gBAAgB4C,GAAG,CAAC,CAAC+B,MAAc,CAAA;oBACxCC,UAAUD,IAAIC,QAAQ,IAAI;oBAC1BC,MAAMF,IAAIE,IAAI,IAAI;oBAClBC,YAAYH,IAAIG,UAAU,IAAI;oBAC9BC,qBAAqBJ,IAAII,mBAAmB,IAAI;gBAClD,CAAA;QACF,EAAE,OAAOrE,OAAO;YACdC,QAAQD,KAAK,CAAC,qCAAqCA;YACnD,OAAO;gBACL;oBACEkE,UAAU;oBACVC,MAAM;oBACNC,YAAY;oBACZC,qBAAqB;gBACvB;aACD;QACH;IACF;IAEA;;GAEC,GACD,AAAQ5E,gBAAgBvB,eAAsB,EAAkC;QAC9E,MAAMoG,gBAAgB,IAAI,CAACC,iBAAiB,CAACrG;QAE7C,MAAMsG,sBAAsBF,cAAcpC,GAAG,CAACuC,CAAAA,QAAU,CAAA;gBACtD5E,WAAW4E,MAAM5E,SAAS;gBAC1BgE,OAAOY,MAAMC,MAAM,CAACvC,MAAM,GAAG,IAC3BsC,MAAMC,MAAM,CAAChC,MAAM,CAAC,CAACC,KAAKH,IAAMG,MAAOH,CAAAA,EAAE1D,IAAI,CAAC2D,MAAM,GAAG,MAAM,CAAA,GAAI,KAAKgC,MAAMC,MAAM,CAACvC,MAAM,GAAG;YAChG,CAAA;QAEA,MAAMwC,sBAAsBL,cAAcpC,GAAG,CAACuC,CAAAA,QAAU,CAAA;gBACtD5E,WAAW4E,MAAM5E,SAAS;gBAC1B+E,MAAMH,MAAMC,MAAM,CAACvC,MAAM,GAAG,IAC1BsC,MAAMC,MAAM,CAAC/F,MAAM,CAAC6D,CAAAA,IAAKA,EAAE1D,IAAI,CAAC2D,MAAM,EAAEN,MAAM,GAAGsC,MAAMC,MAAM,CAACvC,MAAM,GAAG;YAC3E,CAAA;QAEA,OAAO;YACLqC;YACAG;QACF;IACF;IAEA;;GAEC,GACD,MAAchF,sBAAsBnC,UAAkB,EAAmD;QACvG,MAAMkC,iBAAyD,EAAE;QAEjE,sCAAsC;QACtC,MAAMmF,oBAAoB;YACxB;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QAED,KAAK,MAAMC,WAAWD,kBAAmB;YACvC,IAAIC,QAAQC,IAAI,CAACvH,aAAa;gBAC5BkC,eAAesF,IAAI,CAAC;oBAClBC,UAAU;oBACVd,MAAM;oBACNe,aAAa,CAAC,6CAA6C,EAAEJ,QAAQK,MAAM,EAAE;oBAC7EC,gBAAgB;gBAClB;YACF;QACF;QAEA,0CAA0C;QAC1C,MAAMC,oBAAoB;YACxB;YACA;YACA;YACA;YACA;YACA;SACD;QAED,KAAK,MAAMP,WAAWO,kBAAmB;YACvC,IAAIP,QAAQC,IAAI,CAACvH,aAAa;gBAC5BkC,eAAesF,IAAI,CAAC;oBAClBC,UAAU;oBACVd,MAAM;oBACNe,aAAa,CAAC,0CAA0C,EAAEJ,QAAQK,MAAM,EAAE;oBAC1EC,gBAAgB;gBAClB;YACF;QACF;QAEA,kCAAkC;QAClC,MAAME,uBAAuB;YAC3B;YACA;YACA;YACA;YACA;SACD;QAED,KAAK,MAAMR,WAAWQ,qBAAsB;YAC1C,IAAIR,QAAQC,IAAI,CAACvH,aAAa;gBAC5BkC,eAAesF,IAAI,CAAC;oBAClBC,UAAU;oBACVd,MAAM;oBACNe,aAAa,CAAC,yCAAyC,EAAEJ,QAAQK,MAAM,EAAE;oBACzEC,gBAAgB;gBAClB;YACF;QACF;QAEA,OAAO1F;IACT;IAEA;;GAEC,GACD,MAAcgB,sBACZ6E,MAAc,EACdhF,SAA2D,EAC3DC,KAAa,EACgE;QAC7E,MAAMgF,UAAU,EAAE;QAElB,KAAK,MAAMC,YAAYlF,UAAW;YAChC,MAAMmF,YAAY9H,KAAKC,GAAG;YAC1B,MAAM8H,aAAa,GAAGJ,OAAO,WAAW,EAAEE,SAASG,KAAK,EAAE;YAE1D,IAAI;gBACF,MAAM7D,WAAW,MAAMJ,sBAAU,CAACC,QAAQ,CAAC+D,YAAYnF;gBACvD,MAAMe,eAAe3D,KAAKC,GAAG,KAAK6H;gBAElC,gEAAgE;gBAChE,MAAMG,UAAU,IAAI,CAACC,wBAAwB,CAAC/D,SAASA,QAAQ,EAAE0D,SAASM,cAAc;gBACxF,MAAMC,UAAUH,UAAU,KAAK,oCAAoC;gBAEnEL,QAAQR,IAAI,CAAC;oBAAEzD;oBAAcyE;oBAASH;gBAAQ;YAChD,EAAE,OAAO7F,OAAO;gBACdwF,QAAQR,IAAI,CAAC;oBAAEzD,cAAc3D,KAAKC,GAAG,KAAK6H;oBAAWM,SAAS;oBAAOH,SAAS;gBAAE;YAClF;QACF;QAEA,OAAOL;IACT;IAEA;;GAEC,GACD,AAAQ3E,qBAAqB2E,OAA2E,EAAE;QACxG,MAAMS,aAAaT,QAAQrD,MAAM;QACjC,MAAM+D,kBAAkBV,QAAQ7G,MAAM,CAACwH,CAAAA,IAAKA,EAAEH,OAAO,EAAE7D,MAAM;QAC7D,MAAMC,sBAAsBoD,QAAQ9C,MAAM,CAAC,CAACC,KAAKwD,IAAMxD,MAAMwD,EAAE5E,YAAY,EAAE,KAAK0E;QAClF,MAAMG,iBAAiBZ,QAAQ9C,MAAM,CAAC,CAACC,KAAKwD,IAAMxD,MAAMwD,EAAEN,OAAO,EAAE,KAAKI;QAExE,OAAO;YACL1E,cAAca;YACdZ,aAAa,AAAC0E,kBAAkBD,aAAc;YAC9CxE,cAAc2E,iBAAiB;QACjC;IACF;IAEA;;GAEC,GACD,AAAQpF,uBAAuBhC,OAA4E,EAAE;QAC3G,4CAA4C;QAC5C,MAAMqH,yBAAyBvI,KAAKuD,GAAG,CAAC,GAAG,MAAM,AAACrC,QAAQuC,YAAY,GAAG,OAAQ;QAEjF,2EAA2E;QAC3E,OAAO,AACLvC,CAAAA,QAAQwC,WAAW,GAAG,MACtBxC,QAAQyC,YAAY,GAAG,MACvB4E,yBAAyB,GAAE,IACzB;IACN;IAEA;;GAEC,GACD,AAAQP,yBAAyB/D,QAAgB,EAAEuE,QAAgB,EAAU;QAC3E,MAAMC,gBAAgBxE,SAASyE,WAAW,GAAGC,KAAK,CAAC;QACnD,MAAMC,gBAAgBJ,SAASE,WAAW,GAAGC,KAAK,CAAC;QAEnD,MAAME,cAAcJ,cAAc5H,MAAM,CAACiI,CAAAA,OAAQF,cAAcG,QAAQ,CAACD;QACxE,MAAME,aAAaH,YAAYxE,MAAM,GAAGrE,KAAKuD,GAAG,CAACkF,cAAcpE,MAAM,EAAEuE,cAAcvE,MAAM;QAE3F,OAAOrE,KAAKiJ,GAAG,CAAC,GAAGD,aAAa,IAAI,yBAAyB;IAC/D;IAEA;;GAEC,GACD,AAAQvC,kBAAkBG,MAAa,EAA6C;QAClF,MAAMsC,SAAS,IAAIC;QAEnBvC,OAAOwC,OAAO,CAACtI,CAAAA;YACb,MAAMiB,YAAY,IAAIjC,KAAKgB,MAAMiB,SAAS;YAC1C,MAAMsH,UAAU,GAAGtH,UAAUuH,WAAW,GAAG,CAAC,EAAEvH,UAAUwH,QAAQ,GAAG,CAAC,EAAExH,UAAUyH,OAAO,GAAG,CAAC,EAAEzH,UAAU0H,QAAQ,IAAI;YAEnH,IAAI,CAACP,OAAOQ,GAAG,CAACL,UAAU;gBACxBH,OAAOS,GAAG,CAACN,SAAS,EAAE;YACxB;YACAH,OAAOU,GAAG,CAACP,SAAUnC,IAAI,CAACpG;QAC5B;QAEA,OAAO+I,MAAMC,IAAI,CAACZ,OAAOa,OAAO,IAC7B3F,GAAG,CAAC,CAAC,CAAC4F,KAAKpD,OAAO;YACjB,MAAMqD,QAAQD,IAAIrB,KAAK,CAAC,KAAKvE,GAAG,CAAC8F;YACjC,MAAMnI,YAAY,IAAIjC,KAAKmK,KAAK,CAAC,EAAE,EAAEA,KAAK,CAAC,EAAE,EAAEA,KAAK,CAAC,EAAE,EAAEA,KAAK,CAAC,EAAE;YACjE,OAAO;gBAAElI;gBAAW6E;YAAO;QAC7B,GACCuD,IAAI,CAAC,CAACC,GAAGC,IAAMD,EAAErI,SAAS,CAACuI,OAAO,KAAKD,EAAEtI,SAAS,CAACuI,OAAO;IAC/D;IAEA;;GAEC,GACD,AAAQrF,kBAAkBsF,OAAiB,EAAU;QACnD,MAAMC,OAAOD,QAAQ3F,MAAM,CAAC,CAACC,KAAK4F,MAAQ5F,MAAM4F,KAAK,KAAKF,QAAQlG,MAAM;QACxE,MAAMqG,eAAeH,QAAQnG,GAAG,CAACqG,CAAAA,MAAOzK,KAAK2K,GAAG,CAACF,MAAMD,MAAM;QAC7D,OAAOE,aAAa9F,MAAM,CAAC,CAACC,KAAK+F,OAAS/F,MAAM+F,MAAM,KAAKL,QAAQlG,MAAM;IAC3E;IAEA;;GAEC,GACD,AAAQzE,sBAAkD;QACxD,MAAMe,MAAM,IAAIb;QAChB,MAAMW,QAAQ,IAAIX;QAClBW,MAAMoK,OAAO,CAAClK,IAAI6I,OAAO,KAAK;QAC9B,OAAO;YAAE/I;YAAOE;QAAI;IACtB;IAtiBA,aAAc;QAHd,uBAAQN,cAAR,KAAA;QACA,uBAAQyK,mBAAR,KAAA;QAGE,IAAI,CAACzK,UAAU,GAAG0K,sBAAU,CAACC,WAAW;QACxC,IAAI,CAACF,eAAe,GAAGG,gCAAe,CAACD,WAAW;IACpD;AAoiBF;AAGO,MAAMzL,iBAAiB,IAAID"}