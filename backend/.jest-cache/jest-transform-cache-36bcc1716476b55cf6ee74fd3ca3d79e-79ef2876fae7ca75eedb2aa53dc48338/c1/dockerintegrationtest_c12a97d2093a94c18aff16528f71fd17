952033e1dcb5160569a7258c9911e90d
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _supertest = /*#__PURE__*/ _interop_require_default(require("supertest"));
const _child_process = require("child_process");
const _util = require("util");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const execAsync = (0, _util.promisify)(_child_process.exec);
describe('Docker Integration Tests - Complete System Verification', ()=>{
    const services = [
        {
            name: 'frontend',
            container: 'prompt-frontend',
            port: 3000,
            healthEndpoint: '/api/health'
        },
        {
            name: 'backend',
            container: 'prompt-backend',
            port: 3001,
            healthEndpoint: '/api/health/comprehensive'
        },
        {
            name: 'ollama',
            container: 'prompt-ollama',
            port: 11434,
            healthEndpoint: '/api/version'
        },
        {
            name: 'redis',
            container: 'prompt-redis',
            port: 6379,
            healthEndpoint: '/ping'
        },
        {
            name: 'postgres',
            container: 'prompt-postgres',
            port: 5432,
            healthEndpoint: ''
        }
    ];
    let baselineMetrics;
    const testData = {
        cardId: 'docker-integration-test-card',
        testExecutionId: '',
        analyticsSessionId: ''
    };
    before(async function() {
        this.timeout(120000); // 2 minutes for setup
        console.log('ðŸ³ Starting Docker Integration Test Suite');
        console.log('ðŸ“Š Establishing baseline performance metrics...');
        // Establish baseline metrics
        baselineMetrics = await captureSystemMetrics();
        console.log('âœ… Baseline metrics captured:', baselineMetrics);
    });
    after(async function() {
        this.timeout(60000); // 1 minute for cleanup
        console.log('ðŸ§¹ Cleaning up Docker integration test resources...');
        await cleanupTestResources();
    });
    describe('ðŸ¥ Service Health and Connectivity', ()=>{
        it('should verify all Docker services are running and healthy', async ()=>{
            const healthResults = [];
            for (const service of services){
                const isHealthy = await checkServiceHealth(service);
                healthResults.push({
                    service: service.name,
                    healthy: isHealthy
                });
                expect(isHealthy).to.be.true;
            // `Service ${service.name} is not healthy`;
            }
            console.log('âœ… All services are healthy:', healthResults);
        });
        it('should verify inter-service network connectivity', async ()=>{
            // Test frontend -> backend connectivity
            const frontendToBackend = await testNetworkConnectivity('prompt-frontend', 'prompt-backend:3001');
            expect(frontendToBackend).to.be.true;
            // Test backend -> ollama connectivity
            const backendToOllama = await testNetworkConnectivity('prompt-backend', 'prompt-ollama:11434');
            expect(backendToOllama).to.be.true;
            // Test backend -> redis connectivity
            const backendToRedis = await testNetworkConnectivity('prompt-backend', 'prompt-redis:6379');
            expect(backendToRedis).to.be.true;
            // Test backend -> postgres connectivity
            const backendToPostgres = await testNetworkConnectivity('prompt-backend', 'prompt-postgres:5432');
            expect(backendToPostgres).to.be.true;
            console.log('âœ… All inter-service network connections verified');
        });
        it('should verify service startup order and dependencies', async ()=>{
            const startupOrder = await getServiceStartupOrder();
            // Verify postgres started before backend
            expect(startupOrder.postgres).to.be.below(startupOrder.backend);
            // Verify redis started before backend
            expect(startupOrder.redis).to.be.below(startupOrder.backend);
            // Verify ollama started before backend
            expect(startupOrder.ollama).to.be.below(startupOrder.backend);
            // Verify backend started before frontend
            expect(startupOrder.backend).to.be.below(startupOrder.frontend);
            console.log('âœ… Service startup order verified:', startupOrder);
        });
    });
    describe('ðŸ”„ End-to-End Data Flow', ()=>{
        it('should complete full prompt card creation and testing workflow', async ()=>{
            // 1. Create a prompt card via API
            const createResponse = await (0, _supertest.default)(`http://localhost:3001`).post('/api/prompt-cards').send({
                name: 'Docker Integration Test Card',
                description: 'Test card for Docker integration testing',
                prompts: [
                    {
                        role: 'user',
                        content: 'What is 2 + 2?'
                    }
                ],
                model: 'llama2:7b',
                parameters: {
                    temperature: 0.1,
                    maxTokens: 100
                }
            }).expect(201);
            testData.cardId = createResponse.body.data.id;
            expect(createResponse.body.success).to.be.true;
            expect(createResponse.body.data).to.have.property('id');
            // 2. Execute tests on the prompt card
            const testResponse = await (0, _supertest.default)(`http://localhost:3001`).post('/api/test-execution').send({
                cardId: testData.cardId,
                testCases: [
                    {
                        id: 'math-test-1',
                        input: 'What is 2 + 2?',
                        expectedOutput: '4'
                    },
                    {
                        id: 'math-test-2',
                        input: 'What is 5 + 3?',
                        expectedOutput: '8'
                    }
                ],
                model: 'llama2:7b'
            }).expect(200);
            testData.testExecutionId = testResponse.body.data.executionId;
            expect(testResponse.body.success).to.be.true;
            // 3. Wait for test completion and verify results
            await waitForTestCompletion(testData.testExecutionId);
            const resultsResponse = await (0, _supertest.default)(`http://localhost:3001`).get(`/api/test-execution/${testData.testExecutionId}/results`).expect(200);
            expect(resultsResponse.body.success).to.be.true;
            expect(resultsResponse.body.data).to.have.property('testResults');
            expect(resultsResponse.body.data.testResults).to.be.an('array');
            console.log('âœ… Complete workflow verified successfully');
        });
        it('should verify real-time WebSocket communication', async ()=>{
            const WebSocket = require('ws');
            const ws = new WebSocket('ws://localhost:3001');
            let connectionEstablished = false;
            let progressUpdatesReceived = 0;
            return new Promise((resolve, reject)=>{
                const timeout = setTimeout(()=>{
                    reject(new Error('WebSocket test timed out'));
                }, 30000);
                ws.on('open', ()=>{
                    connectionEstablished = true;
                    // Subscribe to test execution updates
                    ws.send(JSON.stringify({
                        type: 'subscribe',
                        channel: 'test-execution',
                        executionId: testData.testExecutionId
                    }));
                });
                ws.on('message', (data)=>{
                    const message = JSON.parse(data);
                    if (message.type === 'progress' || message.type === 'update') {
                        progressUpdatesReceived++;
                    }
                    if (message.type === 'completed' || progressUpdatesReceived >= 2) {
                        clearTimeout(timeout);
                        expect(connectionEstablished).to.be.true;
                        expect(progressUpdatesReceived).to.be.above(0);
                        ws.close();
                        resolve(undefined);
                    }
                });
                ws.on('error', (error)=>{
                    clearTimeout(timeout);
                    reject(error);
                });
            });
        });
        it('should verify analytics data collection and aggregation', async ()=>{
            // Trigger analytics collection
            const analyticsResponse = await (0, _supertest.default)(`http://localhost:3001`).post('/api/analytics/collect').send({
                event: 'test_execution_completed',
                cardId: testData.cardId,
                executionId: testData.testExecutionId,
                metadata: {
                    testType: 'docker-integration',
                    environment: 'container'
                }
            }).expect(200);
            testData.analyticsSessionId = analyticsResponse.body.data.sessionId;
            // Retrieve analytics data
            const metricsResponse = await (0, _supertest.default)(`http://localhost:3001`).get('/api/analytics/metrics').query({
                sessionId: testData.analyticsSessionId,
                timeRange: '1h'
            }).expect(200);
            expect(metricsResponse.body.success).to.be.true;
            expect(metricsResponse.body.data).to.have.property('executionMetrics');
            expect(metricsResponse.body.data).to.have.property('performanceMetrics');
            console.log('âœ… Analytics data collection verified');
        });
    });
    describe('âš¡ Performance and Load Testing', ()=>{
        it('should handle concurrent requests across services', async ()=>{
            const concurrentRequests = 20;
            const requests = [];
            // Create concurrent requests
            for(let i = 0; i < concurrentRequests; i++){
                requests.push((0, _supertest.default)(`http://localhost:3001`).get('/api/health/comprehensive').timeout(10000));
                requests.push((0, _supertest.default)(`http://localhost:3000`).get('/api/health').timeout(10000));
            }
            const startTime = Date.now();
            const responses = await Promise.allSettled(requests);
            const duration = Date.now() - startTime;
            const successful = responses.filter((r)=>r.status === 'fulfilled' && r.value.status === 200).length;
            const successRate = successful / responses.length * 100;
            expect(successRate).to.be.above(90); // 90% success rate
            expect(duration).to.be.below(15000); // Under 15 seconds
            console.log(`âœ… Concurrent load test: ${successRate}% success rate in ${duration}ms`);
        });
        it('should maintain performance under sustained load', async ()=>{
            const loadTestDuration = 30000; // 30 seconds
            const requestInterval = 500; // 500ms between requests
            const metricsStart = await captureSystemMetrics();
            const startTime = Date.now();
            let requestCount = 0;
            let successCount = 0;
            const loadTestPromise = new Promise((resolve)=>{
                const interval = setInterval(async ()=>{
                    if (Date.now() - startTime >= loadTestDuration) {
                        clearInterval(interval);
                        resolve();
                        return;
                    }
                    requestCount++;
                    try {
                        const response = await (0, _supertest.default)(`http://localhost:3001`).get('/api/health').timeout(5000);
                        if (response.status === 200) {
                            successCount++;
                        }
                    } catch (error) {
                    // Request failed
                    }
                }, requestInterval);
            });
            await loadTestPromise;
            const metricsEnd = await captureSystemMetrics();
            const successRate = successCount / requestCount * 100;
            const performanceDegradation = calculatePerformanceDegradation(metricsStart, metricsEnd);
            expect(successRate).to.be.above(85); // 85% success rate under load
            expect(performanceDegradation).to.be.below(30); // Less than 30% degradation
            console.log(`âœ… Sustained load test: ${successRate}% success rate, ${performanceDegradation}% performance degradation`);
        });
        it('should verify container resource utilization', async ()=>{
            const resourceMetrics = await getContainerResourceMetrics();
            // Verify no container is using excessive resources
            for (const [containerName, metrics] of Object.entries(resourceMetrics)){
                expect(metrics.cpuPercent).to.be.below(80); // Less than 80% CPU
                expect(metrics.memoryPercent).to.be.below(85); // Less than 85% memory
                console.log(`ðŸ“Š ${containerName}: CPU ${metrics.cpuPercent}%, Memory ${metrics.memoryPercent}%`);
            }
            console.log('âœ… Container resource utilization within acceptable limits');
        });
    });
    describe('ðŸ›¡ï¸ Security and Error Handling', ()=>{
        it('should handle service failures gracefully', async ()=>{
            // Temporarily stop Redis to test error handling
            console.log('ðŸ”„ Testing Redis failure scenario...');
            await execAsync('docker stop prompt-redis');
            try {
                // Backend should still respond but with degraded functionality
                const response = await (0, _supertest.default)(`http://localhost:3001`).get('/api/health').expect(200);
                expect(response.body).to.have.property('status');
                // Health check might report degraded status
                // Test caching functionality (should gracefully degrade)
                const cacheTestResponse = await (0, _supertest.default)(`http://localhost:3001`).post('/api/test-execution').send({
                    cardId: testData.cardId,
                    testCases: [
                        {
                            id: 'cache-test',
                            input: 'Test without Redis',
                            expectedOutput: 'Should work without cache'
                        }
                    ],
                    model: 'llama2:7b'
                });
                // Should still work but might be slower
                expect(cacheTestResponse.status).to.be.oneOf([
                    200,
                    503
                ]);
            } finally{
                // Restart Redis
                await execAsync('docker start prompt-redis');
                // Wait for Redis to be ready
                await new Promise((resolve)=>setTimeout(resolve, 5000));
                // Verify Redis is back online
                const redisHealth = await checkServiceHealth(services.find((s)=>s.name === 'redis'));
                expect(redisHealth).to.be.true;
            }
            console.log('âœ… Service failure handling verified');
        });
        it('should enforce proper security headers and CORS', async ()=>{
            const response = await (0, _supertest.default)(`http://localhost:3001`).get('/api/health').expect(200);
            // Check security headers
            expect(response.headers).to.have.property('x-frame-options');
            expect(response.headers).to.have.property('x-content-type-options');
            expect(response.headers['x-content-type-options']).to.equal('nosniff');
            // Test CORS
            const corsResponse = await (0, _supertest.default)(`http://localhost:3001`).options('/api/health').set('Origin', 'http://localhost:3000').expect(200);
            expect(corsResponse.headers['access-control-allow-origin']).to.exist;
            console.log('âœ… Security headers and CORS verified');
        });
        it('should handle database connection issues', async ()=>{
            // Test database connection resilience
            const dbTestResponse = await (0, _supertest.default)(`http://localhost:3001`).get('/api/prompt-cards').expect(200);
            expect(dbTestResponse.body.success).to.be.true;
            // Verify database is properly connected
            const dbHealthResponse = await (0, _supertest.default)(`http://localhost:3001`).get('/api/health/database').expect(200);
            expect(dbHealthResponse.body.database).to.have.property('connected');
            expect(dbHealthResponse.body.database.connected).to.be.true;
            console.log('âœ… Database connection handling verified');
        });
    });
    describe('ðŸ“Š Monitoring and Observability', ()=>{
        it('should provide comprehensive health monitoring', async ()=>{
            const healthResponse = await (0, _supertest.default)(`http://localhost:3001`).get('/api/health/comprehensive').expect(200);
            expect(healthResponse.body).to.have.property('status');
            expect(healthResponse.body).to.have.property('timestamp');
            expect(healthResponse.body).to.have.property('services');
            expect(healthResponse.body).to.have.property('database');
            expect(healthResponse.body).to.have.property('cache');
            expect(healthResponse.body).to.have.property('llm');
            expect(healthResponse.body).to.have.property('system');
            // Verify all service statuses
            expect(healthResponse.body.services.backend).to.equal('healthy');
            expect(healthResponse.body.database.connected).to.be.true;
            expect(healthResponse.body.cache.connected).to.be.true;
            expect(healthResponse.body.llm.available).to.be.true;
            console.log('âœ… Comprehensive health monitoring verified');
        });
        it('should collect and export metrics for monitoring', async ()=>{
            const metricsResponse = await (0, _supertest.default)(`http://localhost:3001`).get('/api/metrics').expect(200);
            // Should return Prometheus-format metrics
            expect(metricsResponse.text).to.include('# HELP');
            expect(metricsResponse.text).to.include('# TYPE');
            expect(metricsResponse.text).to.include('http_requests_total');
            expect(metricsResponse.text).to.include('process_cpu_user_seconds_total');
            console.log('âœ… Metrics collection and export verified');
        });
    });
    // Helper Functions
    async function checkServiceHealth(service) {
        try {
            if (service.name === 'redis') {
                const { stdout } = await execAsync(`docker exec ${service.container} redis-cli ping`);
                return stdout.trim() === 'PONG';
            }
            if (service.name === 'postgres') {
                const { stdout } = await execAsync(`docker exec ${service.container} pg_isready -U promptcard -d promptcard_dev`);
                return stdout.includes('accepting connections');
            }
            const response = await (0, _supertest.default)(`http://localhost:${service.port}`).get(service.healthEndpoint).timeout(10000);
            return response.status === 200;
        } catch (error) {
            console.error(`Health check failed for ${service.name}:`, error.message);
            return false;
        }
    }
    async function testNetworkConnectivity(fromContainer, toAddress) {
        try {
            const command = `docker exec ${fromContainer} sh -c "nc -z ${toAddress.split(':')[0]} ${toAddress.split(':')[1]}"`;
            await execAsync(command);
            return true;
        } catch (error) {
            console.error(`Network connectivity test failed from ${fromContainer} to ${toAddress}:`, error.message);
            return false;
        }
    }
    async function getServiceStartupOrder() {
        const order = {};
        for (const service of services){
            try {
                const { stdout } = await execAsync(`docker inspect ${service.container} --format='{{.State.StartedAt}}'`);
                order[service.name] = new Date(stdout.trim()).getTime();
            } catch (error) {
                order[service.name] = 0;
            }
        }
        return order;
    }
    async function captureSystemMetrics() {
        try {
            // CPU usage
            const cpuInfo = await execAsync("docker stats --no-stream --format 'table {{.CPUPerc}}' | tail -n +2 | head -1");
            const cpu = parseFloat(cpuInfo.stdout.replace('%', '')) || 0;
            // Memory usage
            const memInfo = await execAsync("docker stats --no-stream --format 'table {{.MemPerc}}' | tail -n +2 | head -1");
            const memory = parseFloat(memInfo.stdout.replace('%', '')) || 0;
            // Network latency (ping to backend)
            const latencyStart = Date.now();
            await (0, _supertest.default)('http://localhost:3001').get('/api/health').timeout(5000);
            const networkLatency = Date.now() - latencyStart;
            // Response time for a standard request
            const responseStart = Date.now();
            await (0, _supertest.default)('http://localhost:3001').get('/api/prompt-cards').timeout(10000);
            const responseTime = Date.now() - responseStart;
            // Throughput (requests per second) - simple estimation
            const throughputStart = Date.now();
            const requests = Array(10).fill(null).map(()=>(0, _supertest.default)('http://localhost:3001').get('/api/health').timeout(5000));
            await Promise.all(requests);
            const throughputDuration = Date.now() - throughputStart;
            const throughput = 10 / throughputDuration * 1000; // requests per second
            return {
                cpu,
                memory,
                networkLatency,
                responseTime,
                throughput
            };
        } catch (error) {
            console.warn('Failed to capture complete system metrics:', error.message);
            return {
                cpu: 0,
                memory: 0,
                networkLatency: 1000,
                responseTime: 1000,
                throughput: 0
            };
        }
    }
    async function waitForTestCompletion(executionId, timeout = 60000) {
        const startTime = Date.now();
        while(Date.now() - startTime < timeout){
            try {
                const response = await (0, _supertest.default)(`http://localhost:3001`).get(`/api/test-execution/${executionId}/status`).timeout(5000);
                if (response.body.data.status === 'completed' || response.body.data.status === 'failed') {
                    return;
                }
                await new Promise((resolve)=>setTimeout(resolve, 2000));
            } catch (error) {
                await new Promise((resolve)=>setTimeout(resolve, 2000));
            }
        }
        throw new Error(`Test execution ${executionId} did not complete within ${timeout}ms`);
    }
    function calculatePerformanceDegradation(start, end) {
        const responseTimeDegradation = (end.responseTime - start.responseTime) / start.responseTime * 100;
        const throughputDegradation = (start.throughput - end.throughput) / start.throughput * 100;
        return Math.max(responseTimeDegradation, throughputDegradation);
    }
    async function getContainerResourceMetrics() {
        const metrics = {};
        try {
            const { stdout } = await execAsync("docker stats --no-stream --format 'table {{.Name}}\t{{.CPUPerc}}\t{{.MemPerc}}'");
            const lines = stdout.split('\n').slice(1); // Skip header
            for (const line of lines){
                if (line.trim()) {
                    const [name, cpu, memory] = line.split('\t');
                    metrics[name] = {
                        cpuPercent: parseFloat(cpu.replace('%', '')),
                        memoryPercent: parseFloat(memory.replace('%', ''))
                    };
                }
            }
        } catch (error) {
            console.warn('Failed to get container resource metrics:', error.message);
        }
        return metrics;
    }
    async function cleanupTestResources() {
        try {
            // Clean up test data
            if (testData.cardId && testData.cardId !== 'docker-integration-test-card') {
                await (0, _supertest.default)(`http://localhost:3001`).delete(`/api/prompt-cards/${testData.cardId}`).timeout(5000);
            }
            // Clean up test executions
            if (testData.testExecutionId) {
                await (0, _supertest.default)(`http://localhost:3001`).delete(`/api/test-execution/${testData.testExecutionId}`).timeout(5000);
            }
            console.log('âœ… Test resources cleaned up');
        } catch (error) {
            console.warn('Failed to clean up some test resources:', error.message);
        }
    }
});
