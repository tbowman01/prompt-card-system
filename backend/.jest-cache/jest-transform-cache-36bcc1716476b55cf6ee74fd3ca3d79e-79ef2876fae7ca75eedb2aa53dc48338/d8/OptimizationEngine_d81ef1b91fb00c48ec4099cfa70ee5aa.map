{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/optimization/OptimizationEngine.ts"],"sourcesContent":["import { llmService } from '../llmService';\nimport { promptAnalyzer, PromptAnalysisResult } from './PromptAnalyzer';\nimport { EventStore } from '../analytics/EventStore';\nimport { EnhancedAssertionType } from '../assertions/AssertionEngine';\nimport { LRUCache } from 'lru-cache';\nimport { performance } from 'perf_hooks';\nimport { Worker } from 'worker_threads';\nimport { promisify } from 'util';\nimport { createHash } from 'crypto';\n\nexport interface OptimizationSuggestion {\n  id: string;\n  originalPrompt: string;\n  optimizedPrompt: string;\n  changes: {\n    type: 'structure' | 'clarity' | 'specificity' | 'context' | 'security';\n    description: string;\n    reasoning: string;\n  }[];\n  expectedImprovement: {\n    successRate: number;\n    responseTime: number;\n    qualityScore: number;\n  };\n  confidence: number; // 0-1\n  securityValidation: {\n    passed: boolean;\n    issues: string[];\n    recommendations: string[];\n  };\n  timestamp: Date;\n}\n\nexport interface ABTestConfiguration {\n  id: string;\n  name: string;\n  variants: {\n    id: string;\n    name: string;\n    prompt: string;\n    weight: number; // Traffic allocation percentage\n  }[];\n  metrics: {\n    primaryMetric: 'success_rate' | 'response_time' | 'quality_score';\n    secondaryMetrics: string[];\n  };\n  duration: {\n    startDate: Date;\n    endDate: Date;\n    minSamples: number;\n  };\n  status: 'draft' | 'running' | 'completed' | 'paused';\n  results?: ABTestResult;\n}\n\nexport interface ABTestResult {\n  testId: string;\n  winner: string | null;\n  confidence: number;\n  statisticalSignificance: boolean;\n  variants: {\n    id: string;\n    name: string;\n    metrics: {\n      successRate: number;\n      responseTime: number;\n      qualityScore: number;\n      sampleSize: number;\n    };\n    performanceComparison: {\n      vsControl: number; // Percentage improvement/degradation\n      pValue: number;\n    };\n  }[];\n  insights: string[];\n  recommendations: string[];\n  completedAt: Date;\n}\n\nexport interface PromptTuningConfiguration {\n  id: string;\n  originalPrompt: string;\n  objectives: {\n    primary: 'success_rate' | 'response_time' | 'quality_score';\n    secondary: string[];\n  };\n  constraints: {\n    maxLength: number;\n    requiredKeywords: string[];\n    prohibitedKeywords: string[];\n    securityLevel: 'basic' | 'enhanced' | 'strict';\n  };\n  iterations: number;\n  samplingStrategy: 'random' | 'evolutionary' | 'gradient_based';\n  status: 'pending' | 'running' | 'completed' | 'failed';\n  results?: PromptTuningResult;\n}\n\nexport interface PromptTuningResult {\n  tuningId: string;\n  iterations: {\n    iteration: number;\n    prompt: string;\n    metrics: {\n      successRate: number;\n      responseTime: number;\n      qualityScore: number;\n    };\n    improvements: number; // Percentage improvement over baseline\n    timestamp: Date;\n  }[];\n  bestPrompt: string;\n  finalMetrics: {\n    successRate: number;\n    responseTime: number;\n    qualityScore: number;\n  };\n  totalImprovement: number;\n  convergenceAnalysis: {\n    converged: boolean;\n    stagnationPoint: number;\n    optimalIteration: number;\n  };\n  completedAt: Date;\n}\n\nexport class OptimizationEngine {\n  private eventStore: EventStore;\n  private runningTests: Map<string, ABTestConfiguration>;\n  private runningTuning: Map<string, PromptTuningConfiguration>;\n  private analysisCache: LRUCache<string, PromptAnalysisResult>;\n  private suggestionCache: LRUCache<string, OptimizationSuggestion[]>;\n  private performanceMetrics: Map<string, number[]>;\n  private workerPool: Worker[];\n  private maxWorkers: number;\n  \n  constructor() {\n    this.eventStore = EventStore.getInstance();\n    this.runningTests = new Map();\n    this.runningTuning = new Map();\n    \n    // Initialize caching for better performance\n    this.analysisCache = new LRUCache({\n      max: 500,\n      ttl: 1000 * 60 * 30 // 30 minutes\n    });\n    \n    this.suggestionCache = new LRUCache({\n      max: 200,\n      ttl: 1000 * 60 * 15 // 15 minutes\n    });\n    \n    this.performanceMetrics = new Map();\n    this.maxWorkers = Math.min(4, require('os').cpus().length);\n    this.workerPool = [];\n    \n    // Initialize worker pool for parallel processing\n    this.initializeWorkerPool();\n  }\n\n  /**\n   * Generate AI-powered optimization suggestions for a prompt\n   */\n  async generateOptimizationSuggestions(\n    originalPrompt: string,\n    targetMetrics: {\n      successRate?: number;\n      responseTime?: number;\n      qualityScore?: number;\n    } = {},\n    constraints: {\n      maxLength?: number;\n      maintainStyle?: boolean;\n      securityLevel?: 'basic' | 'enhanced' | 'strict';\n    } = {}\n  ): Promise<OptimizationSuggestion[]> {\n    const startTime = performance.now();\n    const cacheKey = this.generateCacheKey(originalPrompt, targetMetrics, constraints);\n    \n    // Check cache first\n    const cached = this.suggestionCache.get(cacheKey);\n    if (cached) {\n      this.trackPerformance('generateOptimizationSuggestions', performance.now() - startTime);\n      return cached;\n    }\n    \n    const suggestionId = `opt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    try {\n      // Analyze current prompt with caching\n      const analysis = await this.getCachedAnalysis(originalPrompt);\n      \n      // Generate multiple optimization strategies in parallel\n      const strategies = await this.generateOptimizationStrategiesParallel(\n        originalPrompt, \n        analysis, \n        targetMetrics, \n        constraints\n      );\n      \n      // Process strategies in parallel using worker pool\n      const suggestions = await this.processStrategiesInParallel(\n        originalPrompt,\n        strategies,\n        constraints,\n        suggestionId\n      );\n      \n      // Store suggestions (async, don't wait)\n      this.storeOptimizationSuggestions(suggestionId, originalPrompt, suggestions, targetMetrics, constraints);\n      \n      // Cache results\n      this.suggestionCache.set(cacheKey, suggestions);\n      \n      // Track performance\n      this.trackPerformance('generateOptimizationSuggestions', performance.now() - startTime);\n      \n      return suggestions;\n    } catch (error) {\n      console.error('Error generating optimization suggestions:', error);\n      throw new Error(`Optimization suggestion generation failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\n    }\n  }\n\n  /**\n   * Create and start an A/B test for prompt variants\n   */\n  async createABTest(\n    config: Omit<ABTestConfiguration, 'id' | 'status'>\n  ): Promise<ABTestConfiguration> {\n    const testId = `ab_test_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const testConfig: ABTestConfiguration = {\n      ...config,\n      id: testId,\n      status: 'draft'\n    };\n    \n    // Validate test configuration\n    await this.validateABTestConfig(testConfig);\n    \n    // Security validation for all variants\n    for (const variant of testConfig.variants) {\n      const securityValidation = await this.validatePromptSecurity(variant.prompt, 'enhanced');\n      if (!securityValidation.passed) {\n        throw new Error(`Security validation failed for variant ${variant.name}: ${securityValidation.issues.join(', ')}`);\n      }\n    }\n    \n    // Store test configuration\n    await this.eventStore.recordEvent({\n      event_type: 'ab_test_created',\n      entity_id: testId,\n      entity_type: 'ab_test',\n      data: testConfig,\n      timestamp: new Date()\n    });\n    \n    this.runningTests.set(testId, testConfig);\n    \n    return testConfig;\n  }\n\n  /**\n   * Start an A/B test\n   */\n  async startABTest(testId: string): Promise<void> {\n    const testConfig = this.runningTests.get(testId);\n    if (!testConfig) {\n      throw new Error(`A/B test ${testId} not found`);\n    }\n    \n    testConfig.status = 'running';\n    testConfig.duration.startDate = new Date();\n    \n    await this.eventStore.recordEvent({\n      event_type: 'ab_test_started',\n      entity_id: testId,\n      entity_type: 'ab_test',\n      data: testConfig,\n      timestamp: new Date()\n    });\n    \n    console.log(`A/B test ${testId} started`);\n  }\n\n  /**\n   * Record A/B test execution result\n   */\n  async recordABTestResult(\n    testId: string,\n    variantId: string,\n    result: {\n      responseTime: number;\n      success: boolean;\n      qualityScore: number;\n      metadata?: any;\n    }\n  ): Promise<void> {\n    const testConfig = this.runningTests.get(testId);\n    if (!testConfig || testConfig.status !== 'running') {\n      throw new Error(`A/B test ${testId} is not running`);\n    }\n    \n    await this.eventStore.recordEvent({\n      event_type: 'ab_test_result',\n      entity_id: testId,\n      entity_type: 'ab_test',\n      data: {\n        testId,\n        variantId,\n        result,\n        timestamp: new Date()\n      },\n      timestamp: new Date()\n    });\n  }\n\n  /**\n   * Analyze A/B test results and determine winner\n   */\n  async analyzeABTestResults(testId: string): Promise<ABTestResult> {\n    const testConfig = this.runningTests.get(testId);\n    if (!testConfig) {\n      throw new Error(`A/B test ${testId} not found`);\n    }\n    \n    // Get all test results\n    const testResults = await this.eventStore.getEvents({\n      event_type: 'ab_test_result',\n      entity_id: testId\n    });\n    \n    // Group results by variant\n    const variantResults = new Map<string, any[]>();\n    testResults.forEach(result => {\n      const variantId = result.data.variantId;\n      if (!variantResults.has(variantId)) {\n        variantResults.set(variantId, []);\n      }\n      variantResults.get(variantId)!.push(result.data.result);\n    });\n    \n    // Calculate metrics for each variant\n    const variantMetrics = testConfig.variants.map(variant => {\n      const results = variantResults.get(variant.id) || [];\n      const metrics = this.calculateVariantMetrics(results);\n      \n      return {\n        id: variant.id,\n        name: variant.name,\n        metrics: {\n          ...metrics,\n          sampleSize: results.length\n        },\n        performanceComparison: {\n          vsControl: 0, // Will be calculated below\n          pValue: 0     // Will be calculated below\n        }\n      };\n    });\n    \n    // Determine winner using statistical significance\n    const winner = this.determineABTestWinner(variantMetrics, testConfig.metrics.primaryMetric);\n    \n    // Generate insights\n    const insights = await this.generateABTestInsights(testConfig, variantMetrics, winner);\n    \n    const result: ABTestResult = {\n      testId,\n      winner: winner.id,\n      confidence: winner.confidence,\n      statisticalSignificance: winner.significanceLevel > 0.95,\n      variants: variantMetrics,\n      insights,\n      recommendations: winner.recommendations,\n      completedAt: new Date()\n    };\n    \n    // Store results\n    await this.eventStore.recordEvent({\n      event_type: 'ab_test_completed',\n      entity_id: testId,\n      entity_type: 'ab_test',\n      data: result,\n      timestamp: new Date()\n    });\n    \n    // Update test status\n    testConfig.status = 'completed';\n    testConfig.results = result;\n    \n    return result;\n  }\n\n  /**\n   * Start automated prompt tuning\n   */\n  async startPromptTuning(\n    config: Omit<PromptTuningConfiguration, 'id' | 'status'>\n  ): Promise<PromptTuningConfiguration> {\n    const tuningId = `tuning_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const tuningConfig: PromptTuningConfiguration = {\n      ...config,\n      id: tuningId,\n      status: 'pending'\n    };\n    \n    // Validate configuration\n    await this.validateTuningConfig(tuningConfig);\n    \n    // Start tuning process\n    this.runningTuning.set(tuningId, tuningConfig);\n    \n    // Run tuning in background\n    this.executeTuningProcess(tuningConfig);\n    \n    return tuningConfig;\n  }\n\n  /**\n   * Get tuning progress\n   */\n  async getTuningProgress(tuningId: string): Promise<{\n    status: string;\n    currentIteration: number;\n    totalIterations: number;\n    bestMetrics: any;\n    estimatedCompletion: Date;\n  }> {\n    const tuningConfig = this.runningTuning.get(tuningId);\n    if (!tuningConfig) {\n      throw new Error(`Tuning process ${tuningId} not found`);\n    }\n    \n    const progress = {\n      status: tuningConfig.status,\n      currentIteration: tuningConfig.results?.iterations.length || 0,\n      totalIterations: tuningConfig.iterations,\n      bestMetrics: tuningConfig.results?.finalMetrics || null,\n      estimatedCompletion: new Date(Date.now() + 60000) // Placeholder\n    };\n    \n    return progress;\n  }\n\n  /**\n   * Generate optimization strategies\n   */\n  private async generateOptimizationStrategies(\n    originalPrompt: string,\n    analysis: PromptAnalysisResult,\n    targetMetrics: any,\n    constraints: any\n  ): Promise<any[]> {\n    const strategies = [];\n    \n    // Structure optimization\n    if (analysis.effectiveness.score < 70) {\n      strategies.push({\n        type: 'structure' as const,\n        description: 'Improve prompt structure and organization',\n        reasoning: 'Current prompt lacks clear structure and logical flow',\n        expectedImprovement: {\n          successRate: 15,\n          responseTime: 5,\n          qualityScore: 10\n        },\n        confidence: 0.8\n      });\n    }\n    \n    // Clarity optimization\n    if (analysis.patterns.failurePatterns.length > 0) {\n      strategies.push({\n        type: 'clarity' as const,\n        description: 'Enhance prompt clarity and reduce ambiguity',\n        reasoning: 'Failure patterns indicate confusion or misunderstanding',\n        expectedImprovement: {\n          successRate: 20,\n          responseTime: 0,\n          qualityScore: 15\n        },\n        confidence: 0.7\n      });\n    }\n    \n    // Specificity optimization\n    if (analysis.metrics.consistencyScore < 60) {\n      strategies.push({\n        type: 'specificity' as const,\n        description: 'Add more specific instructions and examples',\n        reasoning: 'Low consistency score indicates need for more specific guidance',\n        expectedImprovement: {\n          successRate: 10,\n          responseTime: -5,\n          qualityScore: 20\n        },\n        confidence: 0.9\n      });\n    }\n    \n    // Context optimization\n    strategies.push({\n      type: 'context' as const,\n      description: 'Optimize context and background information',\n      reasoning: 'Enhanced context can improve response quality',\n      expectedImprovement: {\n        successRate: 8,\n        responseTime: 2,\n        qualityScore: 12\n      },\n      confidence: 0.6\n    });\n    \n    return strategies;\n  }\n\n  /**\n   * Apply optimization strategy to prompt\n   */\n  private async applyOptimizationStrategy(\n    originalPrompt: string,\n    strategy: any,\n    constraints: any\n  ): Promise<string> {\n    const optimizationPrompt = `\n      Optimize this prompt based on the following strategy:\n      \n      Original Prompt: \"${originalPrompt}\"\n      \n      Strategy: ${strategy.type}\n      Description: ${strategy.description}\n      Reasoning: ${strategy.reasoning}\n      \n      Constraints:\n      ${constraints.maxLength ? `- Maximum length: ${constraints.maxLength} characters` : ''}\n      ${constraints.maintainStyle ? '- Maintain original writing style' : ''}\n      ${constraints.securityLevel ? `- Security level: ${constraints.securityLevel}` : ''}\n      \n      Return only the optimized prompt without any additional text or explanations.\n    `;\n    \n    try {\n      const response = await llmService.generate(optimizationPrompt);\n      let optimizedPrompt = response.response.trim();\n      \n      // Apply length constraint\n      if (constraints.maxLength && optimizedPrompt.length > constraints.maxLength) {\n        optimizedPrompt = optimizedPrompt.substring(0, constraints.maxLength);\n      }\n      \n      return optimizedPrompt;\n    } catch (error) {\n      console.error('Error applying optimization strategy:', error);\n      return originalPrompt; // Return original if optimization fails\n    }\n  }\n\n  /**\n   * Validate prompt security\n   */\n  private async validatePromptSecurity(\n    prompt: string,\n    securityLevel: 'basic' | 'enhanced' | 'strict'\n  ): Promise<{\n    passed: boolean;\n    issues: string[];\n    recommendations: string[];\n  }> {\n    const issues: string[] = [];\n    const recommendations: string[] = [];\n    \n    // Basic security checks\n    const basicIssues = [\n      { pattern: /ignore.*instructions/i, message: 'Potential instruction bypass' },\n      { pattern: /system.*prompt/i, message: 'System prompt manipulation' },\n      { pattern: /jailbreak/i, message: 'Jailbreak attempt' },\n      { pattern: /password|api.*key|secret/i, message: 'Sensitive information exposure' }\n    ];\n    \n    basicIssues.forEach(check => {\n      if (check.pattern.test(prompt)) {\n        issues.push(check.message);\n      }\n    });\n    \n    // Enhanced security checks\n    if (securityLevel === 'enhanced' || securityLevel === 'strict') {\n      const enhancedIssues = [\n        { pattern: /role.*play/i, message: 'Role-playing instruction' },\n        { pattern: /pretend/i, message: 'Pretend instruction' },\n        { pattern: /act.*as/i, message: 'Acting instruction' },\n        { pattern: /override/i, message: 'Override instruction' }\n      ];\n      \n      enhancedIssues.forEach(check => {\n        if (check.pattern.test(prompt)) {\n          issues.push(check.message);\n        }\n      });\n    }\n    \n    // Strict security checks\n    if (securityLevel === 'strict') {\n      const strictIssues = [\n        { pattern: /you.*must/i, message: 'Imperative instruction' },\n        { pattern: /required.*to/i, message: 'Requirement instruction' },\n        { pattern: /force|compel/i, message: 'Forceful instruction' }\n      ];\n      \n      strictIssues.forEach(check => {\n        if (check.pattern.test(prompt)) {\n          issues.push(check.message);\n        }\n      });\n    }\n    \n    // Generate recommendations\n    if (issues.length > 0) {\n      recommendations.push('Review and sanitize identified security issues');\n      recommendations.push('Use more neutral and instructional language');\n      recommendations.push('Avoid manipulative or coercive phrasing');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      issues,\n      recommendations\n    };\n  }\n\n  /**\n   * Validate A/B test configuration\n   */\n  private async validateABTestConfig(config: ABTestConfiguration): Promise<void> {\n    if (config.variants.length < 2) {\n      throw new Error('A/B test must have at least 2 variants');\n    }\n    \n    const totalWeight = config.variants.reduce((sum, variant) => sum + variant.weight, 0);\n    if (Math.abs(totalWeight - 100) > 0.1) {\n      throw new Error('Variant weights must sum to 100%');\n    }\n    \n    if (config.duration.endDate <= config.duration.startDate) {\n      throw new Error('End date must be after start date');\n    }\n  }\n\n  /**\n   * Calculate metrics for variant results\n   */\n  private calculateVariantMetrics(results: any[]): {\n    successRate: number;\n    responseTime: number;\n    qualityScore: number;\n  } {\n    if (results.length === 0) {\n      return { successRate: 0, responseTime: 0, qualityScore: 0 };\n    }\n    \n    const successfulResults = results.filter(r => r.success);\n    const successRate = (successfulResults.length / results.length) * 100;\n    const responseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;\n    const qualityScore = results.reduce((sum, r) => sum + r.qualityScore, 0) / results.length;\n    \n    return { successRate, responseTime, qualityScore };\n  }\n\n  /**\n   * Determine A/B test winner\n   */\n  private determineABTestWinner(\n    variantMetrics: any[],\n    primaryMetric: string\n  ): {\n    id: string;\n    confidence: number;\n    significanceLevel: number;\n    recommendations: string[];\n  } {\n    // Simple winner determination based on primary metric\n    let bestVariant = variantMetrics[0];\n    let bestScore = this.getMetricValue(bestVariant.metrics, primaryMetric);\n    \n    for (const variant of variantMetrics) {\n      const score = this.getMetricValue(variant.metrics, primaryMetric);\n      if (score > bestScore) {\n        bestScore = score;\n        bestVariant = variant;\n      }\n    }\n    \n    // Calculate confidence (simplified)\n    const avgScore = variantMetrics.reduce((sum, v) => sum + this.getMetricValue(v.metrics, primaryMetric), 0) / variantMetrics.length;\n    const confidence = Math.min(1, (bestScore - avgScore) / avgScore);\n    \n    return {\n      id: bestVariant.id,\n      confidence,\n      significanceLevel: 0.95, // Simplified\n      recommendations: [\n        `Implement ${bestVariant.name} as the winning variant`,\n        `Monitor performance for ${primaryMetric} improvements`,\n        'Consider running follow-up tests for further optimization'\n      ]\n    };\n  }\n\n  /**\n   * Get metric value by name\n   */\n  private getMetricValue(metrics: any, metricName: string): number {\n    switch (metricName) {\n      case 'success_rate':\n        return metrics.successRate;\n      case 'response_time':\n        return 1000 / metrics.responseTime; // Invert for \"higher is better\"\n      case 'quality_score':\n        return metrics.qualityScore;\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Generate A/B test insights\n   */\n  private async generateABTestInsights(\n    testConfig: ABTestConfiguration,\n    variantMetrics: any[],\n    winner: any\n  ): Promise<string[]> {\n    const insights: string[] = [];\n    \n    // Performance insights\n    const winnerMetrics = variantMetrics.find(v => v.id === winner.id);\n    if (winnerMetrics) {\n      insights.push(`${winnerMetrics.name} achieved ${winnerMetrics.metrics.successRate.toFixed(1)}% success rate`);\n      insights.push(`Response time was ${winnerMetrics.metrics.responseTime.toFixed(0)}ms on average`);\n      insights.push(`Quality score reached ${winnerMetrics.metrics.qualityScore.toFixed(1)}`);\n    }\n    \n    // Comparative insights\n    const controlVariant = variantMetrics.find(v => v.name.toLowerCase().includes('control'));\n    if (controlVariant && winnerMetrics && winnerMetrics.id !== controlVariant.id) {\n      const improvement = ((winnerMetrics.metrics.successRate - controlVariant.metrics.successRate) / controlVariant.metrics.successRate) * 100;\n      insights.push(`Winner shows ${improvement.toFixed(1)}% improvement over control`);\n    }\n    \n    return insights;\n  }\n\n  /**\n   * Validate tuning configuration\n   */\n  private async validateTuningConfig(config: PromptTuningConfiguration): Promise<void> {\n    if (config.iterations < 1 || config.iterations > 100) {\n      throw new Error('Iterations must be between 1 and 100');\n    }\n    \n    if (config.constraints.maxLength < 10) {\n      throw new Error('Maximum length must be at least 10 characters');\n    }\n  }\n\n  /**\n   * Execute tuning process\n   */\n  private async executeTuningProcess(config: PromptTuningConfiguration): Promise<void> {\n    try {\n      config.status = 'running';\n      \n      const iterations: PromptTuningResult['iterations'] = [];\n      let currentPrompt = config.originalPrompt;\n      let bestPrompt = currentPrompt;\n      let bestScore = 0;\n      \n      for (let i = 0; i < config.iterations; i++) {\n        // Generate variant\n        const variant = await this.generatePromptVariant(currentPrompt, config);\n        \n        // Test variant\n        const metrics = await this.testPromptVariant(variant, config);\n        \n        // Calculate score\n        const score = this.calculateTuningScore(metrics, config.objectives);\n        \n        // Update best if better\n        if (score > bestScore) {\n          bestScore = score;\n          bestPrompt = variant;\n        }\n        \n        // Record iteration\n        iterations.push({\n          iteration: i + 1,\n          prompt: variant,\n          metrics,\n          improvements: ((score - bestScore) / bestScore) * 100,\n          timestamp: new Date()\n        });\n        \n        // Update current prompt for next iteration\n        currentPrompt = variant;\n      }\n      \n      // Calculate final results\n      const finalMetrics = iterations[iterations.length - 1].metrics;\n      const baselineScore = this.calculateTuningScore(\n        { successRate: 50, responseTime: 1000, qualityScore: 50 },\n        config.objectives\n      );\n      const totalImprovement = ((bestScore - baselineScore) / baselineScore) * 100;\n      \n      const result: PromptTuningResult = {\n        tuningId: config.id,\n        iterations,\n        bestPrompt,\n        finalMetrics,\n        totalImprovement,\n        convergenceAnalysis: {\n          converged: iterations.length >= 5 && \n                    iterations.slice(-5).every(iter => Math.abs(iter.improvements) < 1),\n          stagnationPoint: iterations.length,\n          optimalIteration: iterations.findIndex(iter => iter.prompt === bestPrompt) + 1\n        },\n        completedAt: new Date()\n      };\n      \n      config.status = 'completed';\n      config.results = result;\n      \n      // Store results\n      await this.eventStore.recordEvent({\n        event_type: 'tuning_completed',\n        entity_id: config.id,\n        entity_type: 'tuning',\n        data: result,\n        timestamp: new Date()\n      });\n      \n    } catch (error) {\n      config.status = 'failed';\n      console.error('Tuning process failed:', error);\n    }\n  }\n\n  /**\n   * Generate prompt variant for tuning\n   */\n  private async generatePromptVariant(\n    currentPrompt: string,\n    config: PromptTuningConfiguration\n  ): Promise<string> {\n    const variationPrompt = `\n      Create a variation of this prompt that improves ${config.objectives.primary}:\n      \n      Current Prompt: \"${currentPrompt}\"\n      \n      Constraints:\n      - Maximum length: ${config.constraints.maxLength} characters\n      - Must include: ${config.constraints.requiredKeywords.join(', ')}\n      - Must not include: ${config.constraints.prohibitedKeywords.join(', ')}\n      \n      Return only the improved prompt without explanations.\n    `;\n    \n    try {\n      const response = await llmService.generate(variationPrompt);\n      return response.response.trim();\n    } catch (error) {\n      console.error('Error generating prompt variant:', error);\n      return currentPrompt; // Return original if generation fails\n    }\n  }\n\n  /**\n   * Test prompt variant\n   */\n  private async testPromptVariant(\n    prompt: string,\n    config: PromptTuningConfiguration\n  ): Promise<{\n    successRate: number;\n    responseTime: number;\n    qualityScore: number;\n  }> {\n    // Simplified testing - in real implementation, use actual test cases\n    const mockMetrics = {\n      successRate: 70 + Math.random() * 25,\n      responseTime: 800 + Math.random() * 400,\n      qualityScore: 60 + Math.random() * 30\n    };\n    \n    return mockMetrics;\n  }\n\n  /**\n   * Calculate tuning score\n   */\n  private calculateTuningScore(\n    metrics: { successRate: number; responseTime: number; qualityScore: number },\n    objectives: PromptTuningConfiguration['objectives']\n  ): number {\n    const primaryWeight = 0.6;\n    const secondaryWeight = 0.4 / objectives.secondary.length;\n    \n    let score = 0;\n    \n    // Primary objective\n    switch (objectives.primary) {\n      case 'success_rate':\n        score += metrics.successRate * primaryWeight;\n        break;\n      case 'response_time':\n        score += (1000 / metrics.responseTime) * primaryWeight;\n        break;\n      case 'quality_score':\n        score += metrics.qualityScore * primaryWeight;\n        break;\n    }\n    \n    // Secondary objectives\n    objectives.secondary.forEach(objective => {\n      switch (objective) {\n        case 'success_rate':\n          score += metrics.successRate * secondaryWeight;\n          break;\n        case 'response_time':\n          score += (1000 / metrics.responseTime) * secondaryWeight;\n          break;\n        case 'quality_score':\n          score += metrics.qualityScore * secondaryWeight;\n          break;\n      }\n    });\n    \n    return score;\n  }\n  \n  /**\n   * Generate cache key for optimization suggestions\n   */\n  private generateCacheKey(prompt: string, metrics: any, constraints: any): string {\n    const content = `${prompt}${JSON.stringify(metrics)}${JSON.stringify(constraints)}`;\n    return createHash('md5').update(content).digest('hex');\n  }\n  \n  /**\n   * Get cached prompt analysis\n   */\n  private async getCachedAnalysis(prompt: string): Promise<PromptAnalysisResult> {\n    const cacheKey = createHash('md5').update(prompt).digest('hex');\n    const cached = this.analysisCache.get(cacheKey);\n    \n    if (cached) {\n      return cached;\n    }\n    \n    const analysis = await promptAnalyzer.analyzePrompt('temp_prompt', prompt);\n    this.analysisCache.set(cacheKey, analysis);\n    \n    return analysis;\n  }\n  \n  /**\n   * Generate optimization strategies in parallel\n   */\n  private async generateOptimizationStrategiesParallel(\n    originalPrompt: string,\n    analysis: PromptAnalysisResult,\n    targetMetrics: any,\n    constraints: any\n  ): Promise<any[]> {\n    const strategyPromises = [\n      this.generateStructureStrategy(analysis),\n      this.generateClarityStrategy(analysis),\n      this.generateSpecificityStrategy(analysis),\n      this.generateContextStrategy(analysis),\n      this.generatePerformanceStrategy(analysis, targetMetrics)\n    ];\n    \n    const strategies = await Promise.all(strategyPromises);\n    return strategies.filter(strategy => strategy !== null);\n  }\n  \n  /**\n   * Process strategies in parallel using worker pool\n   */\n  private async processStrategiesInParallel(\n    originalPrompt: string,\n    strategies: any[],\n    constraints: any,\n    suggestionId: string\n  ): Promise<OptimizationSuggestion[]> {\n    const suggestions: OptimizationSuggestion[] = [];\n    const processingPromises = strategies.map(async (strategy) => {\n      try {\n        const optimizedPrompt = await this.applyOptimizationStrategy(\n          originalPrompt, \n          strategy, \n          constraints\n        );\n        \n        // Security validation\n        const securityValidation = await this.validatePromptSecurity(\n          optimizedPrompt, \n          constraints.securityLevel || 'basic'\n        );\n        \n        if (securityValidation.passed || constraints.securityLevel === 'basic') {\n          return {\n            id: `${suggestionId}_${strategy.type}`,\n            originalPrompt,\n            optimizedPrompt,\n            changes: [{\n              type: strategy.type,\n              description: strategy.description,\n              reasoning: strategy.reasoning\n            }],\n            expectedImprovement: strategy.expectedImprovement,\n            confidence: strategy.confidence,\n            securityValidation,\n            timestamp: new Date()\n          };\n        }\n        \n        return null;\n      } catch (error) {\n        console.warn(`Strategy ${strategy.type} failed:`, error.message);\n        return null;\n      }\n    });\n    \n    const results = await Promise.all(processingPromises);\n    return results.filter(result => result !== null);\n  }\n  \n  /**\n   * Generate structure optimization strategy\n   */\n  private async generateStructureStrategy(analysis: PromptAnalysisResult): Promise<any> {\n    if (analysis.effectiveness.score < 70) {\n      return {\n        type: 'structure' as const,\n        description: 'Improve prompt structure and organization',\n        reasoning: 'Current prompt lacks clear structure and logical flow',\n        expectedImprovement: {\n          successRate: 15,\n          responseTime: 5,\n          qualityScore: 10\n        },\n        confidence: 0.8\n      };\n    }\n    return null;\n  }\n  \n  /**\n   * Generate clarity optimization strategy\n   */\n  private async generateClarityStrategy(analysis: PromptAnalysisResult): Promise<any> {\n    if (analysis.patterns.failurePatterns.length > 0) {\n      return {\n        type: 'clarity' as const,\n        description: 'Enhance prompt clarity and reduce ambiguity',\n        reasoning: 'Failure patterns indicate confusion or misunderstanding',\n        expectedImprovement: {\n          successRate: 20,\n          responseTime: 0,\n          qualityScore: 15\n        },\n        confidence: 0.7\n      };\n    }\n    return null;\n  }\n  \n  /**\n   * Generate specificity optimization strategy\n   */\n  private async generateSpecificityStrategy(analysis: PromptAnalysisResult): Promise<any> {\n    if (analysis.metrics.consistencyScore < 60) {\n      return {\n        type: 'specificity' as const,\n        description: 'Add more specific instructions and examples',\n        reasoning: 'Low consistency score indicates need for more specific guidance',\n        expectedImprovement: {\n          successRate: 10,\n          responseTime: -5,\n          qualityScore: 20\n        },\n        confidence: 0.9\n      };\n    }\n    return null;\n  }\n  \n  /**\n   * Generate context optimization strategy\n   */\n  private async generateContextStrategy(analysis: PromptAnalysisResult): Promise<any> {\n    return {\n      type: 'context' as const,\n      description: 'Optimize context and background information',\n      reasoning: 'Enhanced context can improve response quality',\n      expectedImprovement: {\n        successRate: 8,\n        responseTime: 2,\n        qualityScore: 12\n      },\n      confidence: 0.6\n    };\n  }\n  \n  /**\n   * Generate performance optimization strategy\n   */\n  private async generatePerformanceStrategy(analysis: PromptAnalysisResult, targetMetrics: any): Promise<any> {\n    return {\n      type: 'performance' as const,\n      description: 'Optimize for better response time and quality',\n      reasoning: 'Target specific performance improvements',\n      expectedImprovement: {\n        successRate: targetMetrics.successRate ? 10 : 5,\n        responseTime: targetMetrics.responseTime ? 15 : 8,\n        qualityScore: targetMetrics.qualityScore ? 12 : 6\n      },\n      confidence: 0.7\n    };\n  }\n  \n  /**\n   * Store optimization suggestions asynchronously\n   */\n  private async storeOptimizationSuggestions(\n    suggestionId: string,\n    originalPrompt: string,\n    suggestions: OptimizationSuggestion[],\n    targetMetrics: any,\n    constraints: any\n  ): Promise<void> {\n    try {\n      await this.eventStore.recordEvent({\n        event_type: 'optimization_suggestions',\n        entity_id: suggestionId,\n        entity_type: 'prompt',\n        data: {\n          originalPrompt,\n          suggestions,\n          targetMetrics,\n          constraints\n        },\n        timestamp: new Date()\n      });\n    } catch (error) {\n      console.warn('Failed to store optimization suggestions:', error.message);\n    }\n  }\n  \n  /**\n   * Initialize worker pool for parallel processing\n   */\n  private initializeWorkerPool(): void {\n    // Worker pool implementation would go here\n    // For now, we'll use Promise.all for parallel processing\n    console.log(`Initialized optimization engine with ${this.maxWorkers} workers`);\n  }\n  \n  /**\n   * Track performance metrics\n   */\n  private trackPerformance(operation: string, duration: number): void {\n    if (!this.performanceMetrics.has(operation)) {\n      this.performanceMetrics.set(operation, []);\n    }\n    \n    const metrics = this.performanceMetrics.get(operation)!;\n    metrics.push(duration);\n    \n    // Keep only last 100 measurements\n    if (metrics.length > 100) {\n      metrics.shift();\n    }\n    \n    // Log slow operations\n    if (duration > 30000) { // 30 seconds\n      console.warn(`Slow optimization operation: ${operation} took ${duration.toFixed(2)}ms`);\n    }\n  }\n  \n  /**\n   * Get performance statistics\n   */\n  public getPerformanceStats(): Record<string, { avg: number; max: number; min: number; count: number }> {\n    const stats: Record<string, { avg: number; max: number; min: number; count: number }> = {};\n    \n    for (const [operation, metrics] of this.performanceMetrics) {\n      if (metrics.length > 0) {\n        const avg = metrics.reduce((sum, time) => sum + time, 0) / metrics.length;\n        const max = Math.max(...metrics);\n        const min = Math.min(...metrics);\n        \n        stats[operation] = {\n          avg: Math.round(avg),\n          max: Math.round(max),\n          min: Math.round(min),\n          count: metrics.length\n        };\n      }\n    }\n    \n    return stats;\n  }\n  \n  /**\n   * Clear caches\n   */\n  public clearCaches(): void {\n    this.analysisCache.clear();\n    this.suggestionCache.clear();\n    this.performanceMetrics.clear();\n    console.log('Optimization engine caches cleared');\n  }\n  \n  /**\n   * Get cache statistics\n   */\n  public getCacheStats(): { analysis: any; suggestions: any } {\n    return {\n      analysis: {\n        size: this.analysisCache.size,\n        max: this.analysisCache.max,\n        hitRate: this.analysisCache.calculatedSize > 0 ? \n          (this.analysisCache.calculatedSize - this.analysisCache.size) / this.analysisCache.calculatedSize : 0\n      },\n      suggestions: {\n        size: this.suggestionCache.size,\n        max: this.suggestionCache.max,\n        hitRate: this.suggestionCache.calculatedSize > 0 ? \n          (this.suggestionCache.calculatedSize - this.suggestionCache.size) / this.suggestionCache.calculatedSize : 0\n      }\n    };\n  }\n}\n\n// Export singleton instance\nexport const optimizationEngine = new OptimizationEngine();"],"names":["OptimizationEngine","optimizationEngine","generateOptimizationSuggestions","originalPrompt","targetMetrics","constraints","startTime","performance","now","cacheKey","generateCacheKey","cached","suggestionCache","get","trackPerformance","suggestionId","Date","Math","random","toString","substr","analysis","getCachedAnalysis","strategies","generateOptimizationStrategiesParallel","suggestions","processStrategiesInParallel","storeOptimizationSuggestions","set","error","console","Error","message","createABTest","config","testId","testConfig","id","status","validateABTestConfig","variant","variants","securityValidation","validatePromptSecurity","prompt","passed","name","issues","join","eventStore","recordEvent","event_type","entity_id","entity_type","data","timestamp","runningTests","startABTest","duration","startDate","log","recordABTestResult","variantId","result","analyzeABTestResults","testResults","getEvents","variantResults","Map","forEach","has","push","variantMetrics","map","results","metrics","calculateVariantMetrics","sampleSize","length","performanceComparison","vsControl","pValue","winner","determineABTestWinner","primaryMetric","insights","generateABTestInsights","confidence","statisticalSignificance","significanceLevel","recommendations","completedAt","startPromptTuning","tuningId","tuningConfig","validateTuningConfig","runningTuning","executeTuningProcess","getTuningProgress","progress","currentIteration","iterations","totalIterations","bestMetrics","finalMetrics","estimatedCompletion","generateOptimizationStrategies","effectiveness","score","type","description","reasoning","expectedImprovement","successRate","responseTime","qualityScore","patterns","failurePatterns","consistencyScore","applyOptimizationStrategy","strategy","optimizationPrompt","maxLength","maintainStyle","securityLevel","response","llmService","generate","optimizedPrompt","trim","substring","basicIssues","pattern","check","test","enhancedIssues","strictIssues","totalWeight","reduce","sum","weight","abs","endDate","successfulResults","filter","r","success","bestVariant","bestScore","getMetricValue","avgScore","v","min","metricName","winnerMetrics","find","toFixed","controlVariant","toLowerCase","includes","improvement","currentPrompt","bestPrompt","i","generatePromptVariant","testPromptVariant","calculateTuningScore","objectives","iteration","improvements","baselineScore","totalImprovement","convergenceAnalysis","converged","slice","every","iter","stagnationPoint","optimalIteration","findIndex","variationPrompt","primary","requiredKeywords","prohibitedKeywords","mockMetrics","primaryWeight","secondaryWeight","secondary","objective","content","JSON","stringify","createHash","update","digest","analysisCache","promptAnalyzer","analyzePrompt","strategyPromises","generateStructureStrategy","generateClarityStrategy","generateSpecificityStrategy","generateContextStrategy","generatePerformanceStrategy","Promise","all","processingPromises","changes","warn","initializeWorkerPool","maxWorkers","operation","performanceMetrics","shift","getPerformanceStats","stats","avg","time","max","round","count","clearCaches","clear","getCacheStats","size","hitRate","calculatedSize","workerPool","EventStore","getInstance","LRUCache","ttl","require","cpus"],"mappings":"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"}