{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/analytics/AnalyticsEngine.ts"],"sourcesContent":["import { EventStore, AnalyticsEvent } from './EventStore';\nimport { initializeDatabase } from '../../database/connection';\nimport { Database } from 'better-sqlite3';\nimport { LRUCache } from 'lru-cache';\nimport { performance } from 'perf_hooks';\n\nexport interface MetricDefinition {\n  name: string;\n  type: 'counter' | 'gauge' | 'histogram' | 'rate';\n  description: string;\n  unit?: string;\n  labels?: string[];\n}\n\nexport interface AnalyticsInsight {\n  id: string;\n  type: 'trend' | 'anomaly' | 'comparison' | 'prediction';\n  title: string;\n  description: string;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  data: any;\n  timestamp: Date;\n  recommendations?: string[];\n}\n\nexport interface MetricValue {\n  name: string;\n  value: number;\n  timestamp: Date;\n  labels?: Record<string, string>;\n}\n\nexport interface DashboardMetrics {\n  realtime: {\n    activeTests: number;\n    testsPerSecond: number;\n    successRate: number;\n    averageResponseTime: number;\n    errorRate: number;\n  };\n  historical: {\n    totalTests: number;\n    totalExecutions: number;\n    overallSuccessRate: number;\n    averageExecutionTime: number;\n    mostUsedModels: Array<{ model: string; count: number }>;\n  };\n  trends: {\n    testsOverTime: Array<{ timestamp: Date; count: number }>;\n    successRateOverTime: Array<{ timestamp: Date; rate: number }>;\n    performanceOverTime: Array<{ timestamp: Date; avgTime: number }>;\n  };\n  insights: AnalyticsInsight[];\n}\n\nexport class AnalyticsEngine {\n  private eventStore: EventStore;\n  private db: any;\n  private static instance: AnalyticsEngine;\n  private queryCache: LRUCache<string, any>;\n  private preparedStatements: Map<string, any>;\n  private performanceMetrics: Map<string, number[]>;\n\n  private constructor() {\n    this.eventStore = EventStore.getInstance();\n    this.initializeDb();\n    \n    // Initialize performance optimizations\n    this.queryCache = new LRUCache({\n      max: 1000,\n      ttl: 1000 * 60 * 5 // 5 minutes cache\n    });\n    \n    this.preparedStatements = new Map();\n    this.performanceMetrics = new Map();\n    \n    // Pre-compile frequently used queries\n    this.prepareOptimizedQueries();\n    \n    // Set up database optimizations\n    this.optimizeDatabase();\n  }\n\n  private async initializeDb(): Promise<void> {\n    this.db = await initializeDatabase();\n  }\n\n  public static getInstance(): AnalyticsEngine {\n    if (!AnalyticsEngine.instance) {\n      AnalyticsEngine.instance = new AnalyticsEngine();\n    }\n    return AnalyticsEngine.instance;\n  }\n\n  // Event recording methods\n  public async recordTestExecution(\n    testCaseId: string,\n    executionId: string,\n    model: string,\n    passed: boolean,\n    executionTime: number,\n    metadata: any = {}\n  ): Promise<void> {\n    await this.eventStore.recordEvent({\n      event_type: 'test_execution',\n      entity_id: testCaseId,\n      entity_type: 'test_case',\n      data: {\n        execution_id: executionId,\n        model,\n        passed,\n        execution_time: executionTime,\n        ...metadata\n      },\n      timestamp: new Date(),\n      session_id: executionId\n    });\n  }\n\n  public async recordBatchExecution(\n    promptCardId: string,\n    executionId: string,\n    model: string,\n    totalTests: number,\n    passedTests: number,\n    executionTime: number,\n    metadata: any = {}\n  ): Promise<void> {\n    await this.eventStore.recordEvent({\n      event_type: 'batch_execution',\n      entity_id: promptCardId,\n      entity_type: 'prompt_card',\n      data: {\n        execution_id: executionId,\n        model,\n        total_tests: totalTests,\n        passed_tests: passedTests,\n        failed_tests: totalTests - passedTests,\n        execution_time: executionTime,\n        success_rate: passedTests / totalTests,\n        ...metadata\n      },\n      timestamp: new Date(),\n      session_id: executionId\n    });\n  }\n\n  public async recordModelUsage(\n    model: string,\n    usage: {\n      promptTokens: number;\n      completionTokens: number;\n      totalTokens: number;\n      cost?: number;\n    }\n  ): Promise<void> {\n    await this.eventStore.recordEvent({\n      event_type: 'model_usage',\n      entity_id: model,\n      entity_type: 'model',\n      data: usage,\n      timestamp: new Date()\n    });\n  }\n\n  public async recordSystemMetrics(\n    metrics: {\n      cpuUsage: number;\n      memoryUsage: number;\n      diskUsage: number;\n      networkLatency: number;\n      queueSize: number;\n    }\n  ): Promise<void> {\n    await this.eventStore.recordEvent({\n      event_type: 'system_metrics',\n      entity_id: 'system',\n      entity_type: 'system',\n      data: metrics,\n      timestamp: new Date()\n    });\n  }\n\n  // Metrics calculation methods\n  public async calculateRealtimeMetrics(): Promise<DashboardMetrics['realtime']> {\n    const cacheKey = 'realtime_metrics';\n    const cached = this.queryCache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    \n    const startTime = performance.now();\n    const now = new Date();\n    const oneMinuteAgo = new Date(now.getTime() - 60 * 1000);\n\n    // Get recent test executions\n    const recentTests = await this.eventStore.getEvents({\n      event_type: 'test_execution',\n      start_time: oneMinuteAgo,\n      end_time: now\n    });\n\n    // Get currently running tests from database\n    const activeTestsQuery = this.db.prepare(`\n      SELECT COUNT(*) as count\n      FROM test_results\n      WHERE created_at >= datetime('now', '-5 minutes')\n      AND execution_id NOT IN (\n        SELECT DISTINCT execution_id \n        FROM test_results \n        WHERE created_at >= datetime('now', '-5 minutes')\n        GROUP BY execution_id\n        HAVING COUNT(*) > 1\n      )\n    `);\n    const activeTests = (activeTestsQuery.get() as any)?.count || 0;\n\n    const testsPerSecond = recentTests.length / 60;\n    const passedTests = recentTests.filter(t => t.data.passed).length;\n    const successRate = recentTests.length > 0 ? passedTests / recentTests.length : 0;\n    const averageResponseTime = recentTests.length > 0 \n      ? recentTests.reduce((sum, t) => sum + t.data.execution_time, 0) / recentTests.length \n      : 0;\n    const errorRate = 1 - successRate;\n\n    const result = {\n      activeTests,\n      testsPerSecond,\n      successRate,\n      averageResponseTime,\n      errorRate\n    };\n    \n    // Cache result with shorter TTL for real-time data\n    this.queryCache.set(cacheKey, result, { ttl: 1000 * 30 }); // 30 seconds\n    \n    // Track performance\n    const executionTime = performance.now() - startTime;\n    this.trackQueryPerformance('calculateRealtimeMetrics', executionTime);\n    \n    return result;\n  }\n\n  public async calculateHistoricalMetrics(): Promise<DashboardMetrics['historical']> {\n    const cacheKey = 'historical_metrics';\n    const cached = this.queryCache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    \n    const startTime = performance.now();\n    // Get total tests from database\n    const totalTestsQuery = this.db.prepare(`SELECT COUNT(*) as count FROM test_results`);\n    const totalTests = (totalTestsQuery.get() as any)?.count || 0;\n\n    // Get total executions (unique execution_ids)\n    const totalExecutionsQuery = this.db.prepare(`\n      SELECT COUNT(DISTINCT execution_id) as count FROM test_results\n    `);\n    const totalExecutions = (totalExecutionsQuery.get() as any)?.count || 0;\n\n    // Get overall success rate\n    const successRateQuery = this.db.prepare(`\n      SELECT \n        COUNT(*) as total,\n        SUM(CASE WHEN passed = 1 THEN 1 ELSE 0 END) as passed\n      FROM test_results\n    `);\n    const successData = successRateQuery.get() as any;\n    const overallSuccessRate = successData && successData.total > 0 \n      ? successData.passed / successData.total \n      : 0;\n\n    // Get average execution time\n    const avgTimeQuery = this.db.prepare(`\n      SELECT AVG(execution_time_ms) as avg_time FROM test_results\n    `);\n    const avgTime = (avgTimeQuery.get() as any)?.avg_time || 0;\n\n    // Get most used models from events\n    const modelUsageEvents = await this.eventStore.getEvents({\n      event_type: 'test_execution',\n      limit: 10000\n    });\n\n    const modelCounts = modelUsageEvents.reduce((acc, event) => {\n      const model = event.data.model;\n      acc[model] = (acc[model] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const mostUsedModels = Object.entries(modelCounts)\n      .sort(([, a], [, b]) => b - a)\n      .slice(0, 10)\n      .map(([model, count]) => ({ model, count }));\n\n    const result = {\n      totalTests,\n      totalExecutions,\n      overallSuccessRate,\n      averageExecutionTime: avgTime,\n      mostUsedModels\n    };\n    \n    // Cache result with longer TTL for historical data\n    this.queryCache.set(cacheKey, result, { ttl: 1000 * 60 * 10 }); // 10 minutes\n    \n    // Track performance\n    const executionTime = performance.now() - startTime;\n    this.trackQueryPerformance('calculateHistoricalMetrics', executionTime);\n    \n    return result;\n  }\n\n  public async calculateTrends(\n    period: 'hour' | 'day' | 'week' | 'month' = 'day',\n    limit: number = 30\n  ): Promise<DashboardMetrics['trends']> {\n    const cacheKey = `trends_${period}_${limit}`;\n    const cached = this.queryCache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    \n    const startTime = performance.now();\n    const now = new Date();\n    const periodStartTime = new Date();\n    \n    switch (period) {\n      case 'hour':\n        periodStartTime.setHours(now.getHours() - limit);\n        break;\n      case 'day':\n        periodStartTime.setDate(now.getDate() - limit);\n        break;\n      case 'week':\n        periodStartTime.setDate(now.getDate() - (limit * 7));\n        break;\n      case 'month':\n        periodStartTime.setMonth(now.getMonth() - limit);\n        break;\n    }\n\n    // Get test execution events for the period\n    const events = await this.eventStore.getEvents({\n      event_type: 'test_execution',\n      start_time: periodStartTime,\n      end_time: now\n    });\n\n    // Group events by time period\n    const timeGroups = this.groupEventsByTime(events, period);\n\n    const testsOverTime = timeGroups.map(group => ({\n      timestamp: group.timestamp,\n      count: group.events.length\n    }));\n\n    const successRateOverTime = timeGroups.map(group => ({\n      timestamp: group.timestamp,\n      rate: group.events.length > 0 \n        ? group.events.filter(e => e.data.passed).length / group.events.length \n        : 0\n    }));\n\n    const performanceOverTime = timeGroups.map(group => ({\n      timestamp: group.timestamp,\n      avgTime: group.events.length > 0\n        ? group.events.reduce((sum, e) => sum + e.data.execution_time, 0) / group.events.length\n        : 0\n    }));\n\n    const result = {\n      testsOverTime,\n      successRateOverTime,\n      performanceOverTime\n    };\n    \n    // Cache result with appropriate TTL based on period\n    const ttl = period === 'hour' ? 1000 * 60 * 5 : 1000 * 60 * 30; // 5 or 30 minutes\n    this.queryCache.set(cacheKey, result, { ttl });\n    \n    // Track performance\n    const executionTime = performance.now() - startTime;\n    this.trackQueryPerformance('calculateTrends', executionTime);\n    \n    return result;\n  }\n\n  public async generateInsights(): Promise<AnalyticsInsight[]> {\n    const insights: AnalyticsInsight[] = [];\n\n    // Performance insight\n    const recentPerformance = await this.calculateTrends('hour', 24);\n    const avgPerformance = recentPerformance.performanceOverTime\n      .reduce((sum, p) => sum + p.avgTime, 0) / recentPerformance.performanceOverTime.length;\n    \n    if (avgPerformance > 5000) { // 5 seconds\n      insights.push({\n        id: 'performance_degradation',\n        type: 'anomaly',\n        title: 'Performance Degradation Detected',\n        description: `Average response time has increased to ${avgPerformance.toFixed(0)}ms`,\n        severity: 'high',\n        data: { avgPerformance },\n        timestamp: new Date(),\n        recommendations: [\n          'Check system resources',\n          'Optimize slow queries',\n          'Consider scaling infrastructure'\n        ]\n      });\n    }\n\n    // Success rate insight\n    const recentSuccess = await this.calculateTrends('hour', 24);\n    const avgSuccessRate = recentSuccess.successRateOverTime\n      .reduce((sum, s) => sum + s.rate, 0) / recentSuccess.successRateOverTime.length;\n    \n    if (avgSuccessRate < 0.8) { // Less than 80% success rate\n      insights.push({\n        id: 'low_success_rate',\n        type: 'anomaly',\n        title: 'Low Success Rate Detected',\n        description: `Test success rate has dropped to ${(avgSuccessRate * 100).toFixed(1)}%`,\n        severity: 'critical',\n        data: { avgSuccessRate },\n        timestamp: new Date(),\n        recommendations: [\n          'Review failing test cases',\n          'Check assertion logic',\n          'Validate model configurations'\n        ]\n      });\n    }\n\n    // Usage trend insight\n    const usageTrend = await this.calculateTrends('day', 7);\n    const recentUsage = usageTrend.testsOverTime.slice(-3).reduce((sum, t) => sum + t.count, 0);\n    const previousUsage = usageTrend.testsOverTime.slice(-6, -3).reduce((sum, t) => sum + t.count, 0);\n    \n    if (recentUsage > previousUsage * 1.5) {\n      insights.push({\n        id: 'usage_spike',\n        type: 'trend',\n        title: 'Usage Spike Detected',\n        description: `Test execution volume has increased by ${((recentUsage / previousUsage - 1) * 100).toFixed(1)}%`,\n        severity: 'medium',\n        data: { recentUsage, previousUsage },\n        timestamp: new Date(),\n        recommendations: [\n          'Monitor system capacity',\n          'Consider auto-scaling',\n          'Review resource allocation'\n        ]\n      });\n    }\n\n    return insights;\n  }\n\n  public async getDashboardMetrics(): Promise<DashboardMetrics> {\n    const [realtime, historical, trends, insights] = await Promise.all([\n      this.calculateRealtimeMetrics(),\n      this.calculateHistoricalMetrics(),\n      this.calculateTrends(),\n      this.generateInsights()\n    ]);\n\n    return {\n      realtime,\n      historical,\n      trends,\n      insights\n    };\n  }\n\n  private groupEventsByTime(\n    events: AnalyticsEvent[],\n    period: 'hour' | 'day' | 'week' | 'month'\n  ): Array<{ timestamp: Date; events: AnalyticsEvent[] }> {\n    const groups = new Map<string, AnalyticsEvent[]>();\n\n    events.forEach(event => {\n      const timestamp = new Date(event.timestamp);\n      let key: string;\n\n      switch (period) {\n        case 'hour':\n          key = `${timestamp.getFullYear()}-${timestamp.getMonth()}-${timestamp.getDate()}-${timestamp.getHours()}`;\n          break;\n        case 'day':\n          key = `${timestamp.getFullYear()}-${timestamp.getMonth()}-${timestamp.getDate()}`;\n          break;\n        case 'week':\n          const weekStart = new Date(timestamp);\n          weekStart.setDate(timestamp.getDate() - timestamp.getDay());\n          key = `${weekStart.getFullYear()}-${weekStart.getMonth()}-${weekStart.getDate()}`;\n          break;\n        case 'month':\n          key = `${timestamp.getFullYear()}-${timestamp.getMonth()}`;\n          break;\n      }\n\n      if (!groups.has(key)) {\n        groups.set(key, []);\n      }\n      groups.get(key)!.push(event);\n    });\n\n    return Array.from(groups.entries())\n      .map(([key, events]) => {\n        const parts = key.split('-').map(Number);\n        let timestamp: Date;\n        \n        switch (period) {\n          case 'hour':\n            timestamp = new Date(parts[0], parts[1], parts[2], parts[3]);\n            break;\n          case 'day':\n            timestamp = new Date(parts[0], parts[1], parts[2]);\n            break;\n          case 'week':\n            timestamp = new Date(parts[0], parts[1], parts[2]);\n            break;\n          case 'month':\n            timestamp = new Date(parts[0], parts[1]);\n            break;\n          default:\n            timestamp = new Date();\n        }\n\n        return { timestamp, events };\n      })\n      .sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n  }\n  \n  /**\n   * Prepare optimized SQL queries for better performance\n   */\n  private prepareOptimizedQueries(): void {\n    // Optimized query for active tests with indexes\n    this.preparedStatements.set('activeTests', this.db.prepare(`\n      SELECT COUNT(*) as count\n      FROM test_results\n      WHERE created_at >= datetime('now', '-5 minutes')\n      AND execution_id NOT IN (\n        SELECT DISTINCT execution_id \n        FROM test_results \n        WHERE created_at >= datetime('now', '-5 minutes')\n        GROUP BY execution_id\n        HAVING COUNT(*) > 1\n      )\n    `));\n    \n    // Optimized query for total tests with covering index\n    this.preparedStatements.set('totalTests', this.db.prepare(`\n      SELECT COUNT(*) as count FROM test_results\n    `));\n    \n    // Optimized query for total executions using distinct\n    this.preparedStatements.set('totalExecutions', this.db.prepare(`\n      SELECT COUNT(DISTINCT execution_id) as count FROM test_results\n    `));\n    \n    // Optimized query for success rate with index hint\n    this.preparedStatements.set('successRate', this.db.prepare(`\n      SELECT \n        COUNT(*) as total,\n        SUM(CASE WHEN passed = 1 THEN 1 ELSE 0 END) as passed\n      FROM test_results\n      WHERE created_at >= ?\n    `));\n    \n    // Optimized query for average execution time\n    this.preparedStatements.set('avgExecutionTime', this.db.prepare(`\n      SELECT AVG(execution_time_ms) as avg_time \n      FROM test_results\n      WHERE execution_time_ms > 0\n    `));\n  }\n  \n  /**\n   * Optimize database settings for performance\n   */\n  private optimizeDatabase(): void {\n    // Set WAL mode for better concurrent performance\n    this.db.pragma('journal_mode = WAL');\n    \n    // Optimize memory usage\n    this.db.pragma('cache_size = 10000');\n    this.db.pragma('temp_store = memory');\n    \n    // Optimize synchronous mode for better performance\n    this.db.pragma('synchronous = NORMAL');\n    \n    // Enable query planner optimization\n    this.db.pragma('optimize');\n    \n    // Create additional performance indexes\n    this.createPerformanceIndexes();\n  }\n  \n  /**\n   * Create additional indexes for better query performance\n   */\n  private createPerformanceIndexes(): void {\n    try {\n      // Composite index for time-based queries\n      this.db.exec(`\n        CREATE INDEX IF NOT EXISTS idx_test_results_created_at_passed \n        ON test_results(created_at, passed);\n      `);\n      \n      // Composite index for execution time analysis\n      this.db.exec(`\n        CREATE INDEX IF NOT EXISTS idx_test_results_execution_time \n        ON test_results(execution_time_ms, created_at) \n        WHERE execution_time_ms > 0;\n      `);\n      \n      // Index for model performance analysis\n      this.db.exec(`\n        CREATE INDEX IF NOT EXISTS idx_test_results_model_performance \n        ON test_results(model, passed, execution_time_ms);\n      `);\n      \n      // Covering index for execution ID queries\n      this.db.exec(`\n        CREATE INDEX IF NOT EXISTS idx_test_results_execution_id_covering \n        ON test_results(execution_id, created_at, passed);\n      `);\n      \n      console.log('Performance indexes created successfully');\n    } catch (error) {\n      console.warn('Some performance indexes already exist:', error.message);\n    }\n  }\n  \n  /**\n   * Track query performance for optimization\n   */\n  private trackQueryPerformance(queryName: string, executionTime: number): void {\n    if (!this.performanceMetrics.has(queryName)) {\n      this.performanceMetrics.set(queryName, []);\n    }\n    \n    const metrics = this.performanceMetrics.get(queryName)!;\n    metrics.push(executionTime);\n    \n    // Keep only last 100 measurements\n    if (metrics.length > 100) {\n      metrics.shift();\n    }\n    \n    // Log slow queries\n    if (executionTime > 100) {\n      console.warn(`Slow query detected: ${queryName} took ${executionTime.toFixed(2)}ms`);\n    }\n  }\n  \n  /**\n   * Get query performance statistics\n   */\n  public getQueryPerformanceStats(): Record<string, { avg: number; max: number; min: number; count: number }> {\n    const stats: Record<string, { avg: number; max: number; min: number; count: number }> = {};\n    \n    for (const [queryName, metrics] of this.performanceMetrics) {\n      if (metrics.length > 0) {\n        const avg = metrics.reduce((sum, time) => sum + time, 0) / metrics.length;\n        const max = Math.max(...metrics);\n        const min = Math.min(...metrics);\n        \n        stats[queryName] = {\n          avg: Math.round(avg * 100) / 100,\n          max: Math.round(max * 100) / 100,\n          min: Math.round(min * 100) / 100,\n          count: metrics.length\n        };\n      }\n    }\n    \n    return stats;\n  }\n  \n  /**\n   * Clear cache and performance metrics\n   */\n  public clearCache(): void {\n    this.queryCache.clear();\n    this.performanceMetrics.clear();\n    console.log('Analytics cache and performance metrics cleared');\n  }\n  \n  /**\n   * Get cache statistics\n   */\n  public getCacheStats(): { size: number; max: number; hitRate: number } {\n    return {\n      size: this.queryCache.size,\n      max: this.queryCache.max,\n      hitRate: this.queryCache.calculatedSize > 0 ? \n        (this.queryCache.calculatedSize - this.queryCache.size) / this.queryCache.calculatedSize : 0\n    };\n  }\n}"],"names":["AnalyticsEngine","initializeDb","db","initializeDatabase","getInstance","instance","recordTestExecution","testCaseId","executionId","model","passed","executionTime","metadata","eventStore","recordEvent","event_type","entity_id","entity_type","data","execution_id","execution_time","timestamp","Date","session_id","recordBatchExecution","promptCardId","totalTests","passedTests","total_tests","passed_tests","failed_tests","success_rate","recordModelUsage","usage","recordSystemMetrics","metrics","calculateRealtimeMetrics","cacheKey","cached","queryCache","get","startTime","performance","now","oneMinuteAgo","getTime","recentTests","getEvents","start_time","end_time","activeTestsQuery","prepare","activeTests","count","testsPerSecond","length","filter","t","successRate","averageResponseTime","reduce","sum","errorRate","result","set","ttl","trackQueryPerformance","calculateHistoricalMetrics","totalTestsQuery","totalExecutionsQuery","totalExecutions","successRateQuery","successData","overallSuccessRate","total","avgTimeQuery","avgTime","avg_time","modelUsageEvents","limit","modelCounts","acc","event","mostUsedModels","Object","entries","sort","a","b","slice","map","averageExecutionTime","calculateTrends","period","periodStartTime","setHours","getHours","setDate","getDate","setMonth","getMonth","events","timeGroups","groupEventsByTime","testsOverTime","group","successRateOverTime","rate","e","performanceOverTime","generateInsights","insights","recentPerformance","avgPerformance","p","push","id","type","title","description","toFixed","severity","recommendations","recentSuccess","avgSuccessRate","s","usageTrend","recentUsage","previousUsage","getDashboardMetrics","realtime","historical","trends","Promise","all","groups","Map","forEach","key","getFullYear","weekStart","getDay","has","Array","from","parts","split","Number","prepareOptimizedQueries","preparedStatements","optimizeDatabase","pragma","createPerformanceIndexes","exec","console","log","error","warn","message","queryName","performanceMetrics","shift","getQueryPerformanceStats","stats","avg","time","max","Math","min","round","clearCache","clear","getCacheStats","size","hitRate","calculatedSize","EventStore","LRUCache"],"mappings":"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"}