4ba9f1eedec49a5f39b7092feb189ca2
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get MLAnalyticsCoordinator () {
        return MLAnalyticsCoordinator;
    },
    get mlAnalyticsCoordinator () {
        return mlAnalyticsCoordinator;
    }
});
const _events = require("events");
const _PredictiveAnalytics = require("./PredictiveAnalytics");
const _AnomalyDetector = require("./AnomalyDetector");
const _CapacityPlanner = require("./CapacityPlanner");
const _AnalyticsEngine = require("./AnalyticsEngine");
const _PerformanceMonitor = require("../performance/PerformanceMonitor");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
class MLAnalyticsCoordinator extends _events.EventEmitter {
    /**
   * Initialize all ML analytics services
   */ async initialize() {
        if (this.isInitialized) {
            console.log('ML Analytics Coordinator already initialized');
            return;
        }
        try {
            console.log('Initializing ML Analytics Coordinator...');
            // Initialize performance monitoring first
            this.performanceMonitor.startMonitoring(this.config.monitoring.performanceInterval);
            // Initialize anomaly detection if enabled
            if (this.config.enableAnomalyDetection) {
                await this.initializeAnomalyDetection();
            }
            // Initialize capacity planning if enabled
            if (this.config.enableCapacityPlanning) {
                await this.initializeCapacityPlanning();
            }
            // Initialize predictive analytics if enabled
            if (this.config.enablePredictiveAnalytics) {
                await this.initializePredictiveAnalytics();
            }
            // Start auto-training if enabled
            if (this.config.autoTraining.enabled) {
                this.startAutoTraining();
            }
            // Start health monitoring
            this.startHealthMonitoring();
            this.isInitialized = true;
            this.isRunning = true;
            console.log('ML Analytics Coordinator initialized successfully');
            this.emit('initialized');
        } catch (error) {
            console.error('Failed to initialize ML Analytics Coordinator:', error);
            this.emit('error', error);
            throw error;
        }
    }
    /**
   * Start all ML analytics services
   */ async start() {
        if (!this.isInitialized) {
            await this.initialize();
        }
        if (this.isRunning) {
            console.log('ML Analytics Coordinator already running');
            return;
        }
        try {
            console.log('Starting ML Analytics Coordinator services...');
            // Start anomaly detection
            if (this.config.enableAnomalyDetection) {
                this.anomalyDetector.startDetection(this.config.monitoring.anomalyDetectionInterval);
            }
            // Start capacity monitoring
            if (this.config.enableCapacityPlanning) {
                this.capacityPlanner.startMonitoring(this.config.monitoring.capacityPlanningInterval);
            }
            // Start performance monitoring
            this.performanceMonitor.startMonitoring(this.config.monitoring.performanceInterval);
            this.isRunning = true;
            console.log('ML Analytics Coordinator services started');
            this.emit('started');
        } catch (error) {
            console.error('Failed to start ML Analytics Coordinator:', error);
            this.emit('error', error);
            throw error;
        }
    }
    /**
   * Stop all ML analytics services
   */ async stop() {
        if (!this.isRunning) {
            return;
        }
        try {
            console.log('Stopping ML Analytics Coordinator services...');
            // Stop auto-training
            if (this.autoTrainingInterval) {
                clearInterval(this.autoTrainingInterval);
                this.autoTrainingInterval = null;
            }
            // Stop health monitoring
            if (this.healthCheckInterval) {
                clearInterval(this.healthCheckInterval);
                this.healthCheckInterval = null;
            }
            // Stop anomaly detection
            this.anomalyDetector.stopDetection();
            // Stop capacity monitoring
            this.capacityPlanner.stopMonitoring();
            // Stop performance monitoring
            this.performanceMonitor.stopMonitoring();
            this.isRunning = false;
            console.log('ML Analytics Coordinator services stopped');
            this.emit('stopped');
        } catch (error) {
            console.error('Failed to stop ML Analytics Coordinator:', error);
            this.emit('error', error);
        }
    }
    /**
   * Get comprehensive system health score
   */ async getSystemHealthScore() {
        try {
            // Get performance metrics
            const performanceStats = this.performanceMonitor.getPerformanceSummary();
            const performanceScore = this.calculatePerformanceScore(performanceStats);
            // Get capacity health
            const capacityAlerts = this.capacityPlanner.getCapacityAlerts();
            const capacityScore = this.calculateCapacityScore(capacityAlerts);
            // Get anomaly status
            const anomalyStats = this.anomalyDetector.getDetectionStats();
            const anomalyScore = this.calculateAnomalyScore(anomalyStats);
            // Get prediction confidence
            const predictionScore = await this.calculatePredictionScore();
            // Calculate overall score
            const overall = Math.round(performanceScore * 0.3 + capacityScore * 0.3 + anomalyScore * 0.2 + predictionScore * 0.2);
            // Determine trends
            const trends = await this.analyzeTrends();
            // Determine risk level
            const riskLevel = this.determineRiskLevel(overall, anomalyStats, capacityAlerts);
            // Generate recommendations
            const recommendations = await this.generateHealthRecommendations(overall, performanceStats, capacityAlerts, anomalyStats);
            return {
                overall,
                components: {
                    performance: performanceScore,
                    capacity: capacityScore,
                    anomalies: anomalyScore,
                    predictions: predictionScore
                },
                trends,
                riskLevel,
                recommendations
            };
        } catch (error) {
            console.error('Error calculating system health score:', error);
            return {
                overall: 50,
                components: {
                    performance: 50,
                    capacity: 50,
                    anomalies: 50,
                    predictions: 50
                },
                trends: {
                    improving: false,
                    stable: true,
                    degrading: false
                },
                riskLevel: 'medium',
                recommendations: [
                    'Unable to calculate system health - check ML analytics services'
                ]
            };
        }
    }
    /**
   * Get ML analytics summary
   */ async getAnalyticsSummary() {
        const systemHealth = await this.getSystemHealthScore();
        const anomalyStats = this.anomalyDetector.getDetectionStats();
        const capacityAlerts = this.capacityPlanner.getCapacityAlerts();
        const performanceStats = this.performanceMonitor.getPerformanceSummary();
        // Get insights
        const insights = await this.generateInsights();
        return {
            timestamp: new Date(),
            systemHealth,
            activePredictions: 0,
            activeAnomalies: anomalyStats.activeAlerts,
            capacityAlerts: capacityAlerts.length,
            modelsTraining: 0,
            uptime: Date.now() - this.startTime.getTime(),
            performanceMetrics: {
                avgResponseTime: 0,
                errorRate: 0,
                throughput: 0,
                resourceUtilization: 0
            },
            insights
        };
    }
    /**
   * Update coordinator configuration
   */ updateConfig(newConfig) {
        this.config = {
            ...this.config,
            ...newConfig
        };
        console.log('ML Analytics Coordinator configuration updated');
        this.emit('config_updated', this.config);
    }
    /**
   * Get current configuration
   */ getConfig() {
        return {
            ...this.config
        };
    }
    /**
   * Get service status
   */ getStatus() {
        return {
            isInitialized: this.isInitialized,
            isRunning: this.isRunning,
            uptime: Date.now() - this.startTime.getTime(),
            services: {
                predictiveAnalytics: this.config.enablePredictiveAnalytics,
                anomalyDetection: this.config.enableAnomalyDetection && this.anomalyDetector['isRunning'],
                capacityPlanning: this.config.enableCapacityPlanning && this.capacityPlanner['isMonitoring'],
                performanceMonitoring: this.performanceMonitor['isMonitoring']
            }
        };
    }
    /**
   * Perform comprehensive system analysis
   */ async performSystemAnalysis() {
        console.log('Performing comprehensive system analysis...');
        try {
            const [healthScore, predictions, anomalies, capacityForecasts, optimizationRecommendations] = await Promise.all([
                this.getSystemHealthScore(),
                this.getPredictions(),
                this.getAnomalies(),
                this.getCapacityForecasts(),
                this.getOptimizationRecommendations()
            ]);
            // Generate action plan
            const actionPlan = this.generateActionPlan(healthScore, anomalies, capacityForecasts, optimizationRecommendations);
            return {
                healthScore,
                predictions,
                anomalies,
                capacityForecasts,
                optimizationRecommendations,
                actionPlan
            };
        } catch (error) {
            console.error('Error performing system analysis:', error);
            throw error;
        }
    }
    // Private methods
    initializeServices() {
        this.predictiveAnalytics = new _PredictiveAnalytics.PredictiveAnalytics();
        this.anomalyDetector = _AnomalyDetector.anomalyDetector;
        this.capacityPlanner = _CapacityPlanner.capacityPlanner;
        this.analyticsEngine = _AnalyticsEngine.AnalyticsEngine.getInstance();
        this.performanceMonitor = new _PerformanceMonitor.PerformanceMonitor();
        // Set up event listeners
        this.setupEventListeners();
    }
    setupEventListeners() {
        // Anomaly detection events
        this.anomalyDetector.on('anomaly_detected', (anomaly)=>{
            this.handleAnomalyDetected(anomaly);
        });
        this.anomalyDetector.on('alert_resolved', (alert)=>{
            this.handleAlertResolved(alert);
        });
        // Performance monitoring events
        this.performanceMonitor.on('alert', (alert)=>{
            this.handlePerformanceAlert(alert);
        });
    // Capacity planning events (would need to be implemented in CapacityPlanner)
    // this.capacityPlanner.on('capacity_alert', (alert) => {
    //   this.handleCapacityAlert(alert);
    // });
    }
    async initializeAnomalyDetection() {
        console.log('Initializing anomaly detection...');
        try {
            // Train initial models if needed
            const keyMetrics = [
                'cpu_usage',
                'memory_usage',
                'app_response_time',
                'app_error_rate'
            ];
            await this.anomalyDetector.trainAutoencoderModel(keyMetrics, 7);
            // Update statistical thresholds
            for (const metric of keyMetrics){
                try {
                    await this.anomalyDetector.updateStatisticalThresholds(metric, 7);
                } catch (error) {
                    console.warn(`Failed to update thresholds for ${metric}:`, error.message);
                }
            }
            console.log('Anomaly detection initialized');
        } catch (error) {
            console.warn('Failed to fully initialize anomaly detection:', error.message);
        }
    }
    async initializeCapacityPlanning() {
        console.log('Initializing capacity planning...');
        try {
            // Capacity planner initializes itself
            console.log('Capacity planning initialized');
        } catch (error) {
            console.warn('Failed to initialize capacity planning:', error.message);
        }
    }
    async initializePredictiveAnalytics() {
        console.log('Initializing predictive analytics...');
        try {
            // Train initial models if needed
            const keyMetrics = [
                'cpu_usage',
                'memory_usage',
                'app_response_time'
            ];
            for (const metric of keyMetrics){
                try {
                    await this.predictiveAnalytics.trainCapacityModel(metric, 30);
                } catch (error) {
                    console.warn(`Failed to train capacity model for ${metric}:`, error.message);
                }
            }
            console.log('Predictive analytics initialized');
        } catch (error) {
            console.warn('Failed to fully initialize predictive analytics:', error.message);
        }
    }
    startAutoTraining() {
        const intervalMs = this.config.autoTraining.interval * 60 * 60 * 1000; // Convert hours to ms
        this.autoTrainingInterval = setInterval(async ()=>{
            try {
                console.log('Starting auto-training cycle...');
                await this.predictiveAnalytics.autoRetrainModels();
                console.log('Auto-training cycle completed');
            } catch (error) {
                console.error('Error during auto-training:', error);
            }
        }, intervalMs);
        console.log(`Auto-training scheduled every ${this.config.autoTraining.interval} hours`);
    }
    startHealthMonitoring() {
        this.healthCheckInterval = setInterval(async ()=>{
            try {
                const healthScore = await this.getSystemHealthScore();
                // Emit health update
                this.emit('health_update', healthScore);
                // Check for critical issues
                if (healthScore.riskLevel === 'critical') {
                    this.emit('critical_health_alert', healthScore);
                }
            } catch (error) {
                console.error('Error during health check:', error);
            }
        }, 60000); // Every minute
    }
    calculatePerformanceScore(stats) {
        if (stats.systemHealth === 'good') return 90;
        if (stats.systemHealth === 'warning') return 60;
        if (stats.systemHealth === 'critical') return 20;
        return 50;
    }
    calculateCapacityScore(alerts) {
        const criticalAlerts = alerts.filter((a)=>a.severity === 'critical').length;
        const warningAlerts = alerts.filter((a)=>a.severity === 'warning').length;
        if (criticalAlerts > 0) return 20;
        if (warningAlerts > 2) return 50;
        if (warningAlerts > 0) return 70;
        return 90;
    }
    calculateAnomalyScore(stats) {
        const { activeAlerts, detectionAccuracy, falsePositiveRate } = stats;
        let score = 90;
        // Penalize active alerts
        score -= Math.min(activeAlerts * 10, 50);
        // Adjust for accuracy
        score = score * detectionAccuracy;
        // Penalize false positives
        score -= falsePositiveRate * 20;
        return Math.max(Math.round(score), 0);
    }
    async calculatePredictionScore() {
        // Simplified prediction score - would calculate based on model confidence
        return 75;
    }
    async analyzeTrends() {
        // Simplified trend analysis - would analyze historical health scores
        return {
            improving: false,
            stable: true,
            degrading: false
        };
    }
    determineRiskLevel(overall, anomalyStats, capacityAlerts) {
        if (overall < 30 || capacityAlerts.some((a)=>a.severity === 'critical')) {
            return 'critical';
        }
        if (overall < 50 || anomalyStats.activeAlerts > 3) {
            return 'high';
        }
        if (overall < 70 || anomalyStats.activeAlerts > 1) {
            return 'medium';
        }
        return 'low';
    }
    async generateHealthRecommendations(overall, performanceStats, capacityAlerts, anomalyStats) {
        const recommendations = [];
        if (overall < 50) {
            recommendations.push('System health is poor - immediate action required');
        }
        if (capacityAlerts.length > 0) {
            recommendations.push('Address capacity alerts to prevent resource exhaustion');
        }
        if (anomalyStats.activeAlerts > 2) {
            recommendations.push('Investigate multiple active anomalies');
        }
        if (performanceStats.systemHealth === 'critical') {
            recommendations.push('Performance is critical - check system resources');
        }
        if (recommendations.length === 0) {
            recommendations.push('System health is good - continue monitoring');
        }
        return recommendations;
    }
    async generateInsights() {
        return {
            topRisks: [
                'High memory utilization',
                'Increasing response times'
            ],
            optimizationOpportunities: [
                'CPU optimization possible',
                'Cache hit rate improvements'
            ],
            trendingMetrics: [
                'cpu_usage',
                'memory_usage',
                'response_time'
            ]
        };
    }
    generateActionPlan(healthScore, anomalies, capacityForecasts, optimizations) {
        const actions = [];
        if (healthScore.riskLevel === 'critical') {
            actions.push('URGENT: Address critical system health issues');
        }
        if (anomalies.length > 0) {
            actions.push(`Investigate ${anomalies.length} active anomalies`);
        }
        if (optimizations.length > 0) {
            actions.push('Implement identified optimization opportunities');
        }
        actions.push('Continue monitoring system health trends');
        return actions;
    }
    handleAnomalyDetected(anomaly) {
        console.log(`Anomaly detected: ${anomaly.description}`);
        this.emit('anomaly', anomaly);
    }
    handleAlertResolved(alert) {
        console.log(`Alert resolved: ${alert.alert.id}`);
        this.emit('alert_resolved', alert);
    }
    handlePerformanceAlert(alert) {
        console.log(`Performance alert: ${alert.message}`);
        this.emit('performance_alert', alert);
    }
    // Simplified data getters (would be more comprehensive in real implementation)
    async getPredictions() {
        return [];
    }
    async getAnomalies() {
        return this.anomalyDetector.getActiveAlerts();
    }
    async getCapacityForecasts() {
        const forecasts = await this.capacityPlanner.generateCapacityForecast();
        return Array.from(forecasts.values()).flat();
    }
    async getOptimizationRecommendations() {
        return Object.values(await this.capacityPlanner.generateOptimizationRecommendations()).flat();
    }
    constructor(config){
        super(), _define_property(this, "predictiveAnalytics", void 0), _define_property(this, "anomalyDetector", void 0), _define_property(this, "capacityPlanner", void 0), _define_property(this, "analyticsEngine", void 0), _define_property(this, "performanceMonitor", void 0), _define_property(this, "config", void 0), _define_property(this, "isInitialized", false), _define_property(this, "isRunning", false), _define_property(this, "autoTrainingInterval", null), _define_property(this, "healthCheckInterval", null), _define_property(this, "startTime", void 0);
        this.startTime = new Date();
        this.config = {
            enablePredictiveAnalytics: true,
            enableAnomalyDetection: true,
            enableCapacityPlanning: true,
            autoTraining: {
                enabled: true,
                interval: 24,
                trainingData: {
                    timeframeDays: 30,
                    minSamples: 100
                }
            },
            monitoring: {
                anomalyDetectionInterval: 30000,
                capacityPlanningInterval: 300000,
                performanceInterval: 5000 // 5 seconds
            },
            alerting: {
                enableSlackIntegration: false,
                enableEmailAlerts: false,
                severityThresholds: {
                    critical: 0.9,
                    high: 0.7,
                    medium: 0.5
                }
            },
            models: {
                retentionDays: 30,
                maxModelsPerType: 5,
                autoCleanup: true
            },
            ...config
        };
        this.initializeServices();
    }
}
const mlAnalyticsCoordinator = new MLAnalyticsCoordinator();

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3Byb21wdC1jYXJkLXN5c3RlbS9iYWNrZW5kL3NyYy9zZXJ2aWNlcy9hbmFseXRpY3MvTUxBbmFseXRpY3NDb29yZGluYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuaW1wb3J0IHsgUHJlZGljdGl2ZUFuYWx5dGljcyB9IGZyb20gJy4vUHJlZGljdGl2ZUFuYWx5dGljcyc7XG5pbXBvcnQgeyBBbm9tYWx5RGV0ZWN0b3IsIGFub21hbHlEZXRlY3RvciB9IGZyb20gJy4vQW5vbWFseURldGVjdG9yJztcbmltcG9ydCB7IENhcGFjaXR5UGxhbm5lciwgY2FwYWNpdHlQbGFubmVyIH0gZnJvbSAnLi9DYXBhY2l0eVBsYW5uZXInO1xuaW1wb3J0IHsgQW5hbHl0aWNzRW5naW5lIH0gZnJvbSAnLi9BbmFseXRpY3NFbmdpbmUnO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VNb25pdG9yIH0gZnJvbSAnLi4vcGVyZm9ybWFuY2UvUGVyZm9ybWFuY2VNb25pdG9yJztcblxuZXhwb3J0IGludGVyZmFjZSBNTEFuYWx5dGljc0NvbmZpZyB7XG4gIGVuYWJsZVByZWRpY3RpdmVBbmFseXRpY3M6IGJvb2xlYW47XG4gIGVuYWJsZUFub21hbHlEZXRlY3Rpb246IGJvb2xlYW47XG4gIGVuYWJsZUNhcGFjaXR5UGxhbm5pbmc6IGJvb2xlYW47XG4gIGF1dG9UcmFpbmluZzoge1xuICAgIGVuYWJsZWQ6IGJvb2xlYW47XG4gICAgaW50ZXJ2YWw6IG51bWJlcjsgLy8gaG91cnNcbiAgICB0cmFpbmluZ0RhdGE6IHtcbiAgICAgIHRpbWVmcmFtZURheXM6IG51bWJlcjtcbiAgICAgIG1pblNhbXBsZXM6IG51bWJlcjtcbiAgICB9O1xuICB9O1xuICBtb25pdG9yaW5nOiB7XG4gICAgYW5vbWFseURldGVjdGlvbkludGVydmFsOiBudW1iZXI7IC8vIG1pbGxpc2Vjb25kc1xuICAgIGNhcGFjaXR5UGxhbm5pbmdJbnRlcnZhbDogbnVtYmVyOyAvLyBtaWxsaXNlY29uZHNcbiAgICBwZXJmb3JtYW5jZUludGVydmFsOiBudW1iZXI7IC8vIG1pbGxpc2Vjb25kc1xuICB9O1xuICBhbGVydGluZzoge1xuICAgIGVuYWJsZVNsYWNrSW50ZWdyYXRpb246IGJvb2xlYW47XG4gICAgZW5hYmxlRW1haWxBbGVydHM6IGJvb2xlYW47XG4gICAgc2V2ZXJpdHlUaHJlc2hvbGRzOiB7XG4gICAgICBjcml0aWNhbDogbnVtYmVyO1xuICAgICAgaGlnaDogbnVtYmVyO1xuICAgICAgbWVkaXVtOiBudW1iZXI7XG4gICAgfTtcbiAgfTtcbiAgbW9kZWxzOiB7XG4gICAgcmV0ZW50aW9uRGF5czogbnVtYmVyO1xuICAgIG1heE1vZGVsc1BlclR5cGU6IG51bWJlcjtcbiAgICBhdXRvQ2xlYW51cDogYm9vbGVhbjtcbiAgfTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTeXN0ZW1IZWFsdGhTY29yZSB7XG4gIG92ZXJhbGw6IG51bWJlcjsgLy8gMC0xMDBcbiAgY29tcG9uZW50czoge1xuICAgIHBlcmZvcm1hbmNlOiBudW1iZXI7XG4gICAgY2FwYWNpdHk6IG51bWJlcjtcbiAgICBhbm9tYWxpZXM6IG51bWJlcjtcbiAgICBwcmVkaWN0aW9uczogbnVtYmVyO1xuICB9O1xuICB0cmVuZHM6IHtcbiAgICBpbXByb3Zpbmc6IGJvb2xlYW47XG4gICAgc3RhYmxlOiBib29sZWFuO1xuICAgIGRlZ3JhZGluZzogYm9vbGVhbjtcbiAgfTtcbiAgcmlza0xldmVsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJztcbiAgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNTEFuYWx5dGljc1N1bW1hcnkge1xuICB0aW1lc3RhbXA6IERhdGU7XG4gIHN5c3RlbUhlYWx0aDogU3lzdGVtSGVhbHRoU2NvcmU7XG4gIGFjdGl2ZVByZWRpY3Rpb25zOiBudW1iZXI7XG4gIGFjdGl2ZUFub21hbGllczogbnVtYmVyO1xuICBjYXBhY2l0eUFsZXJ0czogbnVtYmVyO1xuICBtb2RlbHNUcmFpbmluZzogbnVtYmVyO1xuICB1cHRpbWU6IG51bWJlcjtcbiAgcGVyZm9ybWFuY2VNZXRyaWNzOiB7XG4gICAgYXZnUmVzcG9uc2VUaW1lOiBudW1iZXI7XG4gICAgZXJyb3JSYXRlOiBudW1iZXI7XG4gICAgdGhyb3VnaHB1dDogbnVtYmVyO1xuICAgIHJlc291cmNlVXRpbGl6YXRpb246IG51bWJlcjtcbiAgfTtcbiAgaW5zaWdodHM6IHtcbiAgICB0b3BSaXNrczogc3RyaW5nW107XG4gICAgb3B0aW1pemF0aW9uT3Bwb3J0dW5pdGllczogc3RyaW5nW107XG4gICAgdHJlbmRpbmdNZXRyaWNzOiBzdHJpbmdbXTtcbiAgfTtcbn1cblxuZXhwb3J0IGNsYXNzIE1MQW5hbHl0aWNzQ29vcmRpbmF0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBwcml2YXRlIHByZWRpY3RpdmVBbmFseXRpY3M6IFByZWRpY3RpdmVBbmFseXRpY3M7XG4gIHByaXZhdGUgYW5vbWFseURldGVjdG9yOiBBbm9tYWx5RGV0ZWN0b3I7XG4gIHByaXZhdGUgY2FwYWNpdHlQbGFubmVyOiBDYXBhY2l0eVBsYW5uZXI7XG4gIHByaXZhdGUgYW5hbHl0aWNzRW5naW5lOiBBbmFseXRpY3NFbmdpbmU7XG4gIHByaXZhdGUgcGVyZm9ybWFuY2VNb25pdG9yOiBQZXJmb3JtYW5jZU1vbml0b3I7XG4gIFxuICBwcml2YXRlIGNvbmZpZzogTUxBbmFseXRpY3NDb25maWc7XG4gIHByaXZhdGUgaXNJbml0aWFsaXplZDogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGlzUnVubmluZzogYm9vbGVhbiA9IGZhbHNlO1xuICBwcml2YXRlIGF1dG9UcmFpbmluZ0ludGVydmFsOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsO1xuICBwcml2YXRlIGhlYWx0aENoZWNrSW50ZXJ2YWw6IE5vZGVKUy5UaW1lb3V0IHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3RhcnRUaW1lOiBEYXRlO1xuICBcbiAgY29uc3RydWN0b3IoY29uZmlnPzogUGFydGlhbDxNTEFuYWx5dGljc0NvbmZpZz4pIHtcbiAgICBzdXBlcigpO1xuICAgIFxuICAgIHRoaXMuc3RhcnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICBcbiAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgIGVuYWJsZVByZWRpY3RpdmVBbmFseXRpY3M6IHRydWUsXG4gICAgICBlbmFibGVBbm9tYWx5RGV0ZWN0aW9uOiB0cnVlLFxuICAgICAgZW5hYmxlQ2FwYWNpdHlQbGFubmluZzogdHJ1ZSxcbiAgICAgIGF1dG9UcmFpbmluZzoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBpbnRlcnZhbDogMjQsIC8vIDI0IGhvdXJzXG4gICAgICAgIHRyYWluaW5nRGF0YToge1xuICAgICAgICAgIHRpbWVmcmFtZURheXM6IDMwLFxuICAgICAgICAgIG1pblNhbXBsZXM6IDEwMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9uaXRvcmluZzoge1xuICAgICAgICBhbm9tYWx5RGV0ZWN0aW9uSW50ZXJ2YWw6IDMwMDAwLCAvLyAzMCBzZWNvbmRzXG4gICAgICAgIGNhcGFjaXR5UGxhbm5pbmdJbnRlcnZhbDogMzAwMDAwLCAvLyA1IG1pbnV0ZXNcbiAgICAgICAgcGVyZm9ybWFuY2VJbnRlcnZhbDogNTAwMCAvLyA1IHNlY29uZHNcbiAgICAgIH0sXG4gICAgICBhbGVydGluZzoge1xuICAgICAgICBlbmFibGVTbGFja0ludGVncmF0aW9uOiBmYWxzZSxcbiAgICAgICAgZW5hYmxlRW1haWxBbGVydHM6IGZhbHNlLFxuICAgICAgICBzZXZlcml0eVRocmVzaG9sZHM6IHtcbiAgICAgICAgICBjcml0aWNhbDogMC45LFxuICAgICAgICAgIGhpZ2g6IDAuNyxcbiAgICAgICAgICBtZWRpdW06IDAuNVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9kZWxzOiB7XG4gICAgICAgIHJldGVudGlvbkRheXM6IDMwLFxuICAgICAgICBtYXhNb2RlbHNQZXJUeXBlOiA1LFxuICAgICAgICBhdXRvQ2xlYW51cDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH07XG5cbiAgICB0aGlzLmluaXRpYWxpemVTZXJ2aWNlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYWxsIE1MIGFuYWx5dGljcyBzZXJ2aWNlc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIGluaXRpYWxpemUoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMuaXNJbml0aWFsaXplZCkge1xuICAgICAgY29uc29sZS5sb2coJ01MIEFuYWx5dGljcyBDb29yZGluYXRvciBhbHJlYWR5IGluaXRpYWxpemVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdJbml0aWFsaXppbmcgTUwgQW5hbHl0aWNzIENvb3JkaW5hdG9yLi4uJyk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgcGVyZm9ybWFuY2UgbW9uaXRvcmluZyBmaXJzdFxuICAgICAgdGhpcy5wZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNb25pdG9yaW5nKHRoaXMuY29uZmlnLm1vbml0b3JpbmcucGVyZm9ybWFuY2VJbnRlcnZhbCk7XG5cbiAgICAgIC8vIEluaXRpYWxpemUgYW5vbWFseSBkZXRlY3Rpb24gaWYgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUFub21hbHlEZXRlY3Rpb24pIHtcbiAgICAgICAgYXdhaXQgdGhpcy5pbml0aWFsaXplQW5vbWFseURldGVjdGlvbigpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIGNhcGFjaXR5IHBsYW5uaW5nIGlmIGVuYWJsZWRcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVDYXBhY2l0eVBsYW5uaW5nKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaW5pdGlhbGl6ZUNhcGFjaXR5UGxhbm5pbmcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSBwcmVkaWN0aXZlIGFuYWx5dGljcyBpZiBlbmFibGVkXG4gICAgICBpZiAodGhpcy5jb25maWcuZW5hYmxlUHJlZGljdGl2ZUFuYWx5dGljcykge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemVQcmVkaWN0aXZlQW5hbHl0aWNzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0YXJ0IGF1dG8tdHJhaW5pbmcgaWYgZW5hYmxlZFxuICAgICAgaWYgKHRoaXMuY29uZmlnLmF1dG9UcmFpbmluZy5lbmFibGVkKSB7XG4gICAgICAgIHRoaXMuc3RhcnRBdXRvVHJhaW5pbmcoKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgaGVhbHRoIG1vbml0b3JpbmdcbiAgICAgIHRoaXMuc3RhcnRIZWFsdGhNb25pdG9yaW5nKCk7XG5cbiAgICAgIHRoaXMuaXNJbml0aWFsaXplZCA9IHRydWU7XG4gICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XG5cbiAgICAgIGNvbnNvbGUubG9nKCdNTCBBbmFseXRpY3MgQ29vcmRpbmF0b3IgaW5pdGlhbGl6ZWQgc3VjY2Vzc2Z1bGx5Jyk7XG4gICAgICB0aGlzLmVtaXQoJ2luaXRpYWxpemVkJyk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGluaXRpYWxpemUgTUwgQW5hbHl0aWNzIENvb3JkaW5hdG9yOicsIGVycm9yKTtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYWxsIE1MIGFuYWx5dGljcyBzZXJ2aWNlc1xuICAgKi9cbiAgcHVibGljIGFzeW5jIHN0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1J1bm5pbmcpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdNTCBBbmFseXRpY3MgQ29vcmRpbmF0b3IgYWxyZWFkeSBydW5uaW5nJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBNTCBBbmFseXRpY3MgQ29vcmRpbmF0b3Igc2VydmljZXMuLi4nKTtcblxuICAgICAgLy8gU3RhcnQgYW5vbWFseSBkZXRlY3Rpb25cbiAgICAgIGlmICh0aGlzLmNvbmZpZy5lbmFibGVBbm9tYWx5RGV0ZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuYW5vbWFseURldGVjdG9yLnN0YXJ0RGV0ZWN0aW9uKHRoaXMuY29uZmlnLm1vbml0b3JpbmcuYW5vbWFseURldGVjdGlvbkludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgY2FwYWNpdHkgbW9uaXRvcmluZ1xuICAgICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZUNhcGFjaXR5UGxhbm5pbmcpIHtcbiAgICAgICAgdGhpcy5jYXBhY2l0eVBsYW5uZXIuc3RhcnRNb25pdG9yaW5nKHRoaXMuY29uZmlnLm1vbml0b3JpbmcuY2FwYWNpdHlQbGFubmluZ0ludGVydmFsKTtcbiAgICAgIH1cblxuICAgICAgLy8gU3RhcnQgcGVyZm9ybWFuY2UgbW9uaXRvcmluZ1xuICAgICAgdGhpcy5wZXJmb3JtYW5jZU1vbml0b3Iuc3RhcnRNb25pdG9yaW5nKHRoaXMuY29uZmlnLm1vbml0b3JpbmcucGVyZm9ybWFuY2VJbnRlcnZhbCk7XG5cbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gdHJ1ZTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coJ01MIEFuYWx5dGljcyBDb29yZGluYXRvciBzZXJ2aWNlcyBzdGFydGVkJyk7XG4gICAgICB0aGlzLmVtaXQoJ3N0YXJ0ZWQnKTtcblxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc3RhcnQgTUwgQW5hbHl0aWNzIENvb3JkaW5hdG9yOicsIGVycm9yKTtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3RvcCBhbGwgTUwgYW5hbHl0aWNzIHNlcnZpY2VzXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3RvcCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAoIXRoaXMuaXNSdW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdTdG9wcGluZyBNTCBBbmFseXRpY3MgQ29vcmRpbmF0b3Igc2VydmljZXMuLi4nKTtcblxuICAgICAgLy8gU3RvcCBhdXRvLXRyYWluaW5nXG4gICAgICBpZiAodGhpcy5hdXRvVHJhaW5pbmdJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuYXV0b1RyYWluaW5nSW50ZXJ2YWwpO1xuICAgICAgICB0aGlzLmF1dG9UcmFpbmluZ0ludGVydmFsID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gU3RvcCBoZWFsdGggbW9uaXRvcmluZ1xuICAgICAgaWYgKHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFN0b3AgYW5vbWFseSBkZXRlY3Rpb25cbiAgICAgIHRoaXMuYW5vbWFseURldGVjdG9yLnN0b3BEZXRlY3Rpb24oKTtcblxuICAgICAgLy8gU3RvcCBjYXBhY2l0eSBtb25pdG9yaW5nXG4gICAgICB0aGlzLmNhcGFjaXR5UGxhbm5lci5zdG9wTW9uaXRvcmluZygpO1xuXG4gICAgICAvLyBTdG9wIHBlcmZvcm1hbmNlIG1vbml0b3JpbmdcbiAgICAgIHRoaXMucGVyZm9ybWFuY2VNb25pdG9yLnN0b3BNb25pdG9yaW5nKCk7XG5cbiAgICAgIHRoaXMuaXNSdW5uaW5nID0gZmFsc2U7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdNTCBBbmFseXRpY3MgQ29vcmRpbmF0b3Igc2VydmljZXMgc3RvcHBlZCcpO1xuICAgICAgdGhpcy5lbWl0KCdzdG9wcGVkJyk7XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHN0b3AgTUwgQW5hbHl0aWNzIENvb3JkaW5hdG9yOicsIGVycm9yKTtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb21wcmVoZW5zaXZlIHN5c3RlbSBoZWFsdGggc2NvcmVcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRTeXN0ZW1IZWFsdGhTY29yZSgpOiBQcm9taXNlPFN5c3RlbUhlYWx0aFNjb3JlPiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBwZXJmb3JtYW5jZSBtZXRyaWNzXG4gICAgICBjb25zdCBwZXJmb3JtYW5jZVN0YXRzID0gdGhpcy5wZXJmb3JtYW5jZU1vbml0b3IuZ2V0UGVyZm9ybWFuY2VTdW1tYXJ5KCk7XG4gICAgICBjb25zdCBwZXJmb3JtYW5jZVNjb3JlID0gdGhpcy5jYWxjdWxhdGVQZXJmb3JtYW5jZVNjb3JlKHBlcmZvcm1hbmNlU3RhdHMpO1xuXG4gICAgICAvLyBHZXQgY2FwYWNpdHkgaGVhbHRoXG4gICAgICBjb25zdCBjYXBhY2l0eUFsZXJ0cyA9IHRoaXMuY2FwYWNpdHlQbGFubmVyLmdldENhcGFjaXR5QWxlcnRzKCk7XG4gICAgICBjb25zdCBjYXBhY2l0eVNjb3JlID0gdGhpcy5jYWxjdWxhdGVDYXBhY2l0eVNjb3JlKGNhcGFjaXR5QWxlcnRzKTtcblxuICAgICAgLy8gR2V0IGFub21hbHkgc3RhdHVzXG4gICAgICBjb25zdCBhbm9tYWx5U3RhdHMgPSB0aGlzLmFub21hbHlEZXRlY3Rvci5nZXREZXRlY3Rpb25TdGF0cygpO1xuICAgICAgY29uc3QgYW5vbWFseVNjb3JlID0gdGhpcy5jYWxjdWxhdGVBbm9tYWx5U2NvcmUoYW5vbWFseVN0YXRzKTtcblxuICAgICAgLy8gR2V0IHByZWRpY3Rpb24gY29uZmlkZW5jZVxuICAgICAgY29uc3QgcHJlZGljdGlvblNjb3JlID0gYXdhaXQgdGhpcy5jYWxjdWxhdGVQcmVkaWN0aW9uU2NvcmUoKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIG92ZXJhbGwgc2NvcmVcbiAgICAgIGNvbnN0IG92ZXJhbGwgPSBNYXRoLnJvdW5kKFxuICAgICAgICAocGVyZm9ybWFuY2VTY29yZSAqIDAuMyArIFxuICAgICAgICAgY2FwYWNpdHlTY29yZSAqIDAuMyArIFxuICAgICAgICAgYW5vbWFseVNjb3JlICogMC4yICsgXG4gICAgICAgICBwcmVkaWN0aW9uU2NvcmUgKiAwLjIpXG4gICAgICApO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdHJlbmRzXG4gICAgICBjb25zdCB0cmVuZHMgPSBhd2FpdCB0aGlzLmFuYWx5emVUcmVuZHMoKTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIHJpc2sgbGV2ZWxcbiAgICAgIGNvbnN0IHJpc2tMZXZlbCA9IHRoaXMuZGV0ZXJtaW5lUmlza0xldmVsKG92ZXJhbGwsIGFub21hbHlTdGF0cywgY2FwYWNpdHlBbGVydHMpO1xuXG4gICAgICAvLyBHZW5lcmF0ZSByZWNvbW1lbmRhdGlvbnNcbiAgICAgIGNvbnN0IHJlY29tbWVuZGF0aW9ucyA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVIZWFsdGhSZWNvbW1lbmRhdGlvbnMoXG4gICAgICAgIG92ZXJhbGwsXG4gICAgICAgIHBlcmZvcm1hbmNlU3RhdHMsXG4gICAgICAgIGNhcGFjaXR5QWxlcnRzLFxuICAgICAgICBhbm9tYWx5U3RhdHNcbiAgICAgICk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG92ZXJhbGwsXG4gICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICBwZXJmb3JtYW5jZTogcGVyZm9ybWFuY2VTY29yZSxcbiAgICAgICAgICBjYXBhY2l0eTogY2FwYWNpdHlTY29yZSxcbiAgICAgICAgICBhbm9tYWxpZXM6IGFub21hbHlTY29yZSxcbiAgICAgICAgICBwcmVkaWN0aW9uczogcHJlZGljdGlvblNjb3JlXG4gICAgICAgIH0sXG4gICAgICAgIHRyZW5kcyxcbiAgICAgICAgcmlza0xldmVsLFxuICAgICAgICByZWNvbW1lbmRhdGlvbnNcbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsY3VsYXRpbmcgc3lzdGVtIGhlYWx0aCBzY29yZTonLCBlcnJvcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvdmVyYWxsOiA1MCxcbiAgICAgICAgY29tcG9uZW50czogeyBwZXJmb3JtYW5jZTogNTAsIGNhcGFjaXR5OiA1MCwgYW5vbWFsaWVzOiA1MCwgcHJlZGljdGlvbnM6IDUwIH0sXG4gICAgICAgIHRyZW5kczogeyBpbXByb3Zpbmc6IGZhbHNlLCBzdGFibGU6IHRydWUsIGRlZ3JhZGluZzogZmFsc2UgfSxcbiAgICAgICAgcmlza0xldmVsOiAnbWVkaXVtJyxcbiAgICAgICAgcmVjb21tZW5kYXRpb25zOiBbJ1VuYWJsZSB0byBjYWxjdWxhdGUgc3lzdGVtIGhlYWx0aCAtIGNoZWNrIE1MIGFuYWx5dGljcyBzZXJ2aWNlcyddXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgTUwgYW5hbHl0aWNzIHN1bW1hcnlcbiAgICovXG4gIHB1YmxpYyBhc3luYyBnZXRBbmFseXRpY3NTdW1tYXJ5KCk6IFByb21pc2U8TUxBbmFseXRpY3NTdW1tYXJ5PiB7XG4gICAgY29uc3Qgc3lzdGVtSGVhbHRoID0gYXdhaXQgdGhpcy5nZXRTeXN0ZW1IZWFsdGhTY29yZSgpO1xuICAgIGNvbnN0IGFub21hbHlTdGF0cyA9IHRoaXMuYW5vbWFseURldGVjdG9yLmdldERldGVjdGlvblN0YXRzKCk7XG4gICAgY29uc3QgY2FwYWNpdHlBbGVydHMgPSB0aGlzLmNhcGFjaXR5UGxhbm5lci5nZXRDYXBhY2l0eUFsZXJ0cygpO1xuICAgIGNvbnN0IHBlcmZvcm1hbmNlU3RhdHMgPSB0aGlzLnBlcmZvcm1hbmNlTW9uaXRvci5nZXRQZXJmb3JtYW5jZVN1bW1hcnkoKTtcblxuICAgIC8vIEdldCBpbnNpZ2h0c1xuICAgIGNvbnN0IGluc2lnaHRzID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUluc2lnaHRzKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLFxuICAgICAgc3lzdGVtSGVhbHRoLFxuICAgICAgYWN0aXZlUHJlZGljdGlvbnM6IDAsIC8vIFdvdWxkIHRyYWNrIGFjdGl2ZSBwcmVkaWN0aW9uc1xuICAgICAgYWN0aXZlQW5vbWFsaWVzOiBhbm9tYWx5U3RhdHMuYWN0aXZlQWxlcnRzLFxuICAgICAgY2FwYWNpdHlBbGVydHM6IGNhcGFjaXR5QWxlcnRzLmxlbmd0aCxcbiAgICAgIG1vZGVsc1RyYWluaW5nOiAwLCAvLyBXb3VsZCB0cmFjayB0cmFpbmluZyBzdGF0dXNcbiAgICAgIHVwdGltZTogRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lLmdldFRpbWUoKSxcbiAgICAgIHBlcmZvcm1hbmNlTWV0cmljczoge1xuICAgICAgICBhdmdSZXNwb25zZVRpbWU6IDAsIC8vIFdvdWxkIGdldCBmcm9tIHBlcmZvcm1hbmNlIG1vbml0b3JcbiAgICAgICAgZXJyb3JSYXRlOiAwLFxuICAgICAgICB0aHJvdWdocHV0OiAwLFxuICAgICAgICByZXNvdXJjZVV0aWxpemF0aW9uOiAwXG4gICAgICB9LFxuICAgICAgaW5zaWdodHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBjb29yZGluYXRvciBjb25maWd1cmF0aW9uXG4gICAqL1xuICBwdWJsaWMgdXBkYXRlQ29uZmlnKG5ld0NvbmZpZzogUGFydGlhbDxNTEFuYWx5dGljc0NvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLm5ld0NvbmZpZyB9O1xuICAgIGNvbnNvbGUubG9nKCdNTCBBbmFseXRpY3MgQ29vcmRpbmF0b3IgY29uZmlndXJhdGlvbiB1cGRhdGVkJyk7XG4gICAgdGhpcy5lbWl0KCdjb25maWdfdXBkYXRlZCcsIHRoaXMuY29uZmlnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgY3VycmVudCBjb25maWd1cmF0aW9uXG4gICAqL1xuICBwdWJsaWMgZ2V0Q29uZmlnKCk6IE1MQW5hbHl0aWNzQ29uZmlnIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmNvbmZpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBzZXJ2aWNlIHN0YXR1c1xuICAgKi9cbiAgcHVibGljIGdldFN0YXR1cygpOiB7XG4gICAgaXNJbml0aWFsaXplZDogYm9vbGVhbjtcbiAgICBpc1J1bm5pbmc6IGJvb2xlYW47XG4gICAgdXB0aW1lOiBudW1iZXI7XG4gICAgc2VydmljZXM6IHtcbiAgICAgIHByZWRpY3RpdmVBbmFseXRpY3M6IGJvb2xlYW47XG4gICAgICBhbm9tYWx5RGV0ZWN0aW9uOiBib29sZWFuO1xuICAgICAgY2FwYWNpdHlQbGFubmluZzogYm9vbGVhbjtcbiAgICAgIHBlcmZvcm1hbmNlTW9uaXRvcmluZzogYm9vbGVhbjtcbiAgICB9O1xuICB9IHtcbiAgICByZXR1cm4ge1xuICAgICAgaXNJbml0aWFsaXplZDogdGhpcy5pc0luaXRpYWxpemVkLFxuICAgICAgaXNSdW5uaW5nOiB0aGlzLmlzUnVubmluZyxcbiAgICAgIHVwdGltZTogRGF0ZS5ub3coKSAtIHRoaXMuc3RhcnRUaW1lLmdldFRpbWUoKSxcbiAgICAgIHNlcnZpY2VzOiB7XG4gICAgICAgIHByZWRpY3RpdmVBbmFseXRpY3M6IHRoaXMuY29uZmlnLmVuYWJsZVByZWRpY3RpdmVBbmFseXRpY3MsXG4gICAgICAgIGFub21hbHlEZXRlY3Rpb246IHRoaXMuY29uZmlnLmVuYWJsZUFub21hbHlEZXRlY3Rpb24gJiYgdGhpcy5hbm9tYWx5RGV0ZWN0b3JbJ2lzUnVubmluZyddLFxuICAgICAgICBjYXBhY2l0eVBsYW5uaW5nOiB0aGlzLmNvbmZpZy5lbmFibGVDYXBhY2l0eVBsYW5uaW5nICYmIHRoaXMuY2FwYWNpdHlQbGFubmVyWydpc01vbml0b3JpbmcnXSxcbiAgICAgICAgcGVyZm9ybWFuY2VNb25pdG9yaW5nOiB0aGlzLnBlcmZvcm1hbmNlTW9uaXRvclsnaXNNb25pdG9yaW5nJ11cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFBlcmZvcm0gY29tcHJlaGVuc2l2ZSBzeXN0ZW0gYW5hbHlzaXNcbiAgICovXG4gIHB1YmxpYyBhc3luYyBwZXJmb3JtU3lzdGVtQW5hbHlzaXMoKTogUHJvbWlzZTx7XG4gICAgaGVhbHRoU2NvcmU6IFN5c3RlbUhlYWx0aFNjb3JlO1xuICAgIHByZWRpY3Rpb25zOiBhbnlbXTtcbiAgICBhbm9tYWxpZXM6IGFueVtdO1xuICAgIGNhcGFjaXR5Rm9yZWNhc3RzOiBhbnlbXTtcbiAgICBvcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbnM6IGFueVtdO1xuICAgIGFjdGlvblBsYW46IHN0cmluZ1tdO1xuICB9PiB7XG4gICAgY29uc29sZS5sb2coJ1BlcmZvcm1pbmcgY29tcHJlaGVuc2l2ZSBzeXN0ZW0gYW5hbHlzaXMuLi4nKTtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBbXG4gICAgICAgIGhlYWx0aFNjb3JlLFxuICAgICAgICBwcmVkaWN0aW9ucyxcbiAgICAgICAgYW5vbWFsaWVzLFxuICAgICAgICBjYXBhY2l0eUZvcmVjYXN0cyxcbiAgICAgICAgb3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25zXG4gICAgICBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICB0aGlzLmdldFN5c3RlbUhlYWx0aFNjb3JlKCksXG4gICAgICAgIHRoaXMuZ2V0UHJlZGljdGlvbnMoKSxcbiAgICAgICAgdGhpcy5nZXRBbm9tYWxpZXMoKSxcbiAgICAgICAgdGhpcy5nZXRDYXBhY2l0eUZvcmVjYXN0cygpLFxuICAgICAgICB0aGlzLmdldE9wdGltaXphdGlvblJlY29tbWVuZGF0aW9ucygpXG4gICAgICBdKTtcblxuICAgICAgLy8gR2VuZXJhdGUgYWN0aW9uIHBsYW5cbiAgICAgIGNvbnN0IGFjdGlvblBsYW4gPSB0aGlzLmdlbmVyYXRlQWN0aW9uUGxhbihcbiAgICAgICAgaGVhbHRoU2NvcmUsXG4gICAgICAgIGFub21hbGllcyxcbiAgICAgICAgY2FwYWNpdHlGb3JlY2FzdHMsXG4gICAgICAgIG9wdGltaXphdGlvblJlY29tbWVuZGF0aW9uc1xuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGVhbHRoU2NvcmUsXG4gICAgICAgIHByZWRpY3Rpb25zLFxuICAgICAgICBhbm9tYWxpZXMsXG4gICAgICAgIGNhcGFjaXR5Rm9yZWNhc3RzLFxuICAgICAgICBvcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbnMsXG4gICAgICAgIGFjdGlvblBsYW5cbiAgICAgIH07XG5cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGVyZm9ybWluZyBzeXN0ZW0gYW5hbHlzaXM6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZSBtZXRob2RzXG5cbiAgcHJpdmF0ZSBpbml0aWFsaXplU2VydmljZXMoKTogdm9pZCB7XG4gICAgdGhpcy5wcmVkaWN0aXZlQW5hbHl0aWNzID0gbmV3IFByZWRpY3RpdmVBbmFseXRpY3MoKTtcbiAgICB0aGlzLmFub21hbHlEZXRlY3RvciA9IGFub21hbHlEZXRlY3RvcjtcbiAgICB0aGlzLmNhcGFjaXR5UGxhbm5lciA9IGNhcGFjaXR5UGxhbm5lcjtcbiAgICB0aGlzLmFuYWx5dGljc0VuZ2luZSA9IEFuYWx5dGljc0VuZ2luZS5nZXRJbnN0YW5jZSgpO1xuICAgIHRoaXMucGVyZm9ybWFuY2VNb25pdG9yID0gbmV3IFBlcmZvcm1hbmNlTW9uaXRvcigpO1xuXG4gICAgLy8gU2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgIHRoaXMuc2V0dXBFdmVudExpc3RlbmVycygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cEV2ZW50TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIC8vIEFub21hbHkgZGV0ZWN0aW9uIGV2ZW50c1xuICAgIHRoaXMuYW5vbWFseURldGVjdG9yLm9uKCdhbm9tYWx5X2RldGVjdGVkJywgKGFub21hbHkpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlQW5vbWFseURldGVjdGVkKGFub21hbHkpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hbm9tYWx5RGV0ZWN0b3Iub24oJ2FsZXJ0X3Jlc29sdmVkJywgKGFsZXJ0KSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZUFsZXJ0UmVzb2x2ZWQoYWxlcnQpO1xuICAgIH0pO1xuXG4gICAgLy8gUGVyZm9ybWFuY2UgbW9uaXRvcmluZyBldmVudHNcbiAgICB0aGlzLnBlcmZvcm1hbmNlTW9uaXRvci5vbignYWxlcnQnLCAoYWxlcnQpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlUGVyZm9ybWFuY2VBbGVydChhbGVydCk7XG4gICAgfSk7XG5cbiAgICAvLyBDYXBhY2l0eSBwbGFubmluZyBldmVudHMgKHdvdWxkIG5lZWQgdG8gYmUgaW1wbGVtZW50ZWQgaW4gQ2FwYWNpdHlQbGFubmVyKVxuICAgIC8vIHRoaXMuY2FwYWNpdHlQbGFubmVyLm9uKCdjYXBhY2l0eV9hbGVydCcsIChhbGVydCkgPT4ge1xuICAgIC8vICAgdGhpcy5oYW5kbGVDYXBhY2l0eUFsZXJ0KGFsZXJ0KTtcbiAgICAvLyB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUFub21hbHlEZXRlY3Rpb24oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBhbm9tYWx5IGRldGVjdGlvbi4uLicpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBUcmFpbiBpbml0aWFsIG1vZGVscyBpZiBuZWVkZWRcbiAgICAgIGNvbnN0IGtleU1ldHJpY3MgPSBbJ2NwdV91c2FnZScsICdtZW1vcnlfdXNhZ2UnLCAnYXBwX3Jlc3BvbnNlX3RpbWUnLCAnYXBwX2Vycm9yX3JhdGUnXTtcbiAgICAgIGF3YWl0IHRoaXMuYW5vbWFseURldGVjdG9yLnRyYWluQXV0b2VuY29kZXJNb2RlbChrZXlNZXRyaWNzLCA3KTtcbiAgICAgIFxuICAgICAgLy8gVXBkYXRlIHN0YXRpc3RpY2FsIHRocmVzaG9sZHNcbiAgICAgIGZvciAoY29uc3QgbWV0cmljIG9mIGtleU1ldHJpY3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhd2FpdCB0aGlzLmFub21hbHlEZXRlY3Rvci51cGRhdGVTdGF0aXN0aWNhbFRocmVzaG9sZHMobWV0cmljLCA3KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byB1cGRhdGUgdGhyZXNob2xkcyBmb3IgJHttZXRyaWN9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdBbm9tYWx5IGRldGVjdGlvbiBpbml0aWFsaXplZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBmdWxseSBpbml0aWFsaXplIGFub21hbHkgZGV0ZWN0aW9uOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdGlhbGl6ZUNhcGFjaXR5UGxhbm5pbmcoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBjYXBhY2l0eSBwbGFubmluZy4uLicpO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICAvLyBDYXBhY2l0eSBwbGFubmVyIGluaXRpYWxpemVzIGl0c2VsZlxuICAgICAgY29uc29sZS5sb2coJ0NhcGFjaXR5IHBsYW5uaW5nIGluaXRpYWxpemVkJyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGluaXRpYWxpemUgY2FwYWNpdHkgcGxhbm5pbmc6JywgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbml0aWFsaXplUHJlZGljdGl2ZUFuYWx5dGljcygpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zb2xlLmxvZygnSW5pdGlhbGl6aW5nIHByZWRpY3RpdmUgYW5hbHl0aWNzLi4uJyk7XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyYWluIGluaXRpYWwgbW9kZWxzIGlmIG5lZWRlZFxuICAgICAgY29uc3Qga2V5TWV0cmljcyA9IFsnY3B1X3VzYWdlJywgJ21lbW9yeV91c2FnZScsICdhcHBfcmVzcG9uc2VfdGltZSddO1xuICAgICAgXG4gICAgICBmb3IgKGNvbnN0IG1ldHJpYyBvZiBrZXlNZXRyaWNzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5wcmVkaWN0aXZlQW5hbHl0aWNzLnRyYWluQ2FwYWNpdHlNb2RlbChtZXRyaWMsIDMwKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byB0cmFpbiBjYXBhY2l0eSBtb2RlbCBmb3IgJHttZXRyaWN9OmAsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCdQcmVkaWN0aXZlIGFuYWx5dGljcyBpbml0aWFsaXplZCcpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBmdWxseSBpbml0aWFsaXplIHByZWRpY3RpdmUgYW5hbHl0aWNzOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRBdXRvVHJhaW5pbmcoKTogdm9pZCB7XG4gICAgY29uc3QgaW50ZXJ2YWxNcyA9IHRoaXMuY29uZmlnLmF1dG9UcmFpbmluZy5pbnRlcnZhbCAqIDYwICogNjAgKiAxMDAwOyAvLyBDb252ZXJ0IGhvdXJzIHRvIG1zXG4gICAgXG4gICAgdGhpcy5hdXRvVHJhaW5pbmdJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBhdXRvLXRyYWluaW5nIGN5Y2xlLi4uJyk7XG4gICAgICAgIGF3YWl0IHRoaXMucHJlZGljdGl2ZUFuYWx5dGljcy5hdXRvUmV0cmFpbk1vZGVscygpO1xuICAgICAgICBjb25zb2xlLmxvZygnQXV0by10cmFpbmluZyBjeWNsZSBjb21wbGV0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGR1cmluZyBhdXRvLXRyYWluaW5nOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9LCBpbnRlcnZhbE1zKTtcblxuICAgIGNvbnNvbGUubG9nKGBBdXRvLXRyYWluaW5nIHNjaGVkdWxlZCBldmVyeSAke3RoaXMuY29uZmlnLmF1dG9UcmFpbmluZy5pbnRlcnZhbH0gaG91cnNgKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRIZWFsdGhNb25pdG9yaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuaGVhbHRoQ2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGhlYWx0aFNjb3JlID0gYXdhaXQgdGhpcy5nZXRTeXN0ZW1IZWFsdGhTY29yZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gRW1pdCBoZWFsdGggdXBkYXRlXG4gICAgICAgIHRoaXMuZW1pdCgnaGVhbHRoX3VwZGF0ZScsIGhlYWx0aFNjb3JlKTtcbiAgICAgICAgXG4gICAgICAgIC8vIENoZWNrIGZvciBjcml0aWNhbCBpc3N1ZXNcbiAgICAgICAgaWYgKGhlYWx0aFNjb3JlLnJpc2tMZXZlbCA9PT0gJ2NyaXRpY2FsJykge1xuICAgICAgICAgIHRoaXMuZW1pdCgnY3JpdGljYWxfaGVhbHRoX2FsZXJ0JywgaGVhbHRoU2NvcmUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkdXJpbmcgaGVhbHRoIGNoZWNrOicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9LCA2MDAwMCk7IC8vIEV2ZXJ5IG1pbnV0ZVxuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVQZXJmb3JtYW5jZVNjb3JlKHN0YXRzOiBhbnkpOiBudW1iZXIge1xuICAgIGlmIChzdGF0cy5zeXN0ZW1IZWFsdGggPT09ICdnb29kJykgcmV0dXJuIDkwO1xuICAgIGlmIChzdGF0cy5zeXN0ZW1IZWFsdGggPT09ICd3YXJuaW5nJykgcmV0dXJuIDYwO1xuICAgIGlmIChzdGF0cy5zeXN0ZW1IZWFsdGggPT09ICdjcml0aWNhbCcpIHJldHVybiAyMDtcbiAgICByZXR1cm4gNTA7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUNhcGFjaXR5U2NvcmUoYWxlcnRzOiBhbnlbXSk6IG51bWJlciB7XG4gICAgY29uc3QgY3JpdGljYWxBbGVydHMgPSBhbGVydHMuZmlsdGVyKGEgPT4gYS5zZXZlcml0eSA9PT0gJ2NyaXRpY2FsJykubGVuZ3RoO1xuICAgIGNvbnN0IHdhcm5pbmdBbGVydHMgPSBhbGVydHMuZmlsdGVyKGEgPT4gYS5zZXZlcml0eSA9PT0gJ3dhcm5pbmcnKS5sZW5ndGg7XG4gICAgXG4gICAgaWYgKGNyaXRpY2FsQWxlcnRzID4gMCkgcmV0dXJuIDIwO1xuICAgIGlmICh3YXJuaW5nQWxlcnRzID4gMikgcmV0dXJuIDUwO1xuICAgIGlmICh3YXJuaW5nQWxlcnRzID4gMCkgcmV0dXJuIDcwO1xuICAgIHJldHVybiA5MDtcbiAgfVxuXG4gIHByaXZhdGUgY2FsY3VsYXRlQW5vbWFseVNjb3JlKHN0YXRzOiBhbnkpOiBudW1iZXIge1xuICAgIGNvbnN0IHsgYWN0aXZlQWxlcnRzLCBkZXRlY3Rpb25BY2N1cmFjeSwgZmFsc2VQb3NpdGl2ZVJhdGUgfSA9IHN0YXRzO1xuICAgIFxuICAgIGxldCBzY29yZSA9IDkwO1xuICAgIFxuICAgIC8vIFBlbmFsaXplIGFjdGl2ZSBhbGVydHNcbiAgICBzY29yZSAtPSBNYXRoLm1pbihhY3RpdmVBbGVydHMgKiAxMCwgNTApO1xuICAgIFxuICAgIC8vIEFkanVzdCBmb3IgYWNjdXJhY3lcbiAgICBzY29yZSA9IHNjb3JlICogZGV0ZWN0aW9uQWNjdXJhY3k7XG4gICAgXG4gICAgLy8gUGVuYWxpemUgZmFsc2UgcG9zaXRpdmVzXG4gICAgc2NvcmUgLT0gZmFsc2VQb3NpdGl2ZVJhdGUgKiAyMDtcbiAgICBcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5yb3VuZChzY29yZSksIDApO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhdGVQcmVkaWN0aW9uU2NvcmUoKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBTaW1wbGlmaWVkIHByZWRpY3Rpb24gc2NvcmUgLSB3b3VsZCBjYWxjdWxhdGUgYmFzZWQgb24gbW9kZWwgY29uZmlkZW5jZVxuICAgIHJldHVybiA3NTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgYW5hbHl6ZVRyZW5kcygpOiBQcm9taXNlPHsgaW1wcm92aW5nOiBib29sZWFuOyBzdGFibGU6IGJvb2xlYW47IGRlZ3JhZGluZzogYm9vbGVhbiB9PiB7XG4gICAgLy8gU2ltcGxpZmllZCB0cmVuZCBhbmFseXNpcyAtIHdvdWxkIGFuYWx5emUgaGlzdG9yaWNhbCBoZWFsdGggc2NvcmVzXG4gICAgcmV0dXJuIHsgaW1wcm92aW5nOiBmYWxzZSwgc3RhYmxlOiB0cnVlLCBkZWdyYWRpbmc6IGZhbHNlIH07XG4gIH1cblxuICBwcml2YXRlIGRldGVybWluZVJpc2tMZXZlbChcbiAgICBvdmVyYWxsOiBudW1iZXIsXG4gICAgYW5vbWFseVN0YXRzOiBhbnksXG4gICAgY2FwYWNpdHlBbGVydHM6IGFueVtdXG4gICk6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgfCAnY3JpdGljYWwnIHtcbiAgICBpZiAob3ZlcmFsbCA8IDMwIHx8IGNhcGFjaXR5QWxlcnRzLnNvbWUoYSA9PiBhLnNldmVyaXR5ID09PSAnY3JpdGljYWwnKSkge1xuICAgICAgcmV0dXJuICdjcml0aWNhbCc7XG4gICAgfVxuICAgIGlmIChvdmVyYWxsIDwgNTAgfHwgYW5vbWFseVN0YXRzLmFjdGl2ZUFsZXJ0cyA+IDMpIHtcbiAgICAgIHJldHVybiAnaGlnaCc7XG4gICAgfVxuICAgIGlmIChvdmVyYWxsIDwgNzAgfHwgYW5vbWFseVN0YXRzLmFjdGl2ZUFsZXJ0cyA+IDEpIHtcbiAgICAgIHJldHVybiAnbWVkaXVtJztcbiAgICB9XG4gICAgcmV0dXJuICdsb3cnO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUhlYWx0aFJlY29tbWVuZGF0aW9ucyhcbiAgICBvdmVyYWxsOiBudW1iZXIsXG4gICAgcGVyZm9ybWFuY2VTdGF0czogYW55LFxuICAgIGNhcGFjaXR5QWxlcnRzOiBhbnlbXSxcbiAgICBhbm9tYWx5U3RhdHM6IGFueVxuICApOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgcmVjb21tZW5kYXRpb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGlmIChvdmVyYWxsIDwgNTApIHtcbiAgICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKCdTeXN0ZW0gaGVhbHRoIGlzIHBvb3IgLSBpbW1lZGlhdGUgYWN0aW9uIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChjYXBhY2l0eUFsZXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnQWRkcmVzcyBjYXBhY2l0eSBhbGVydHMgdG8gcHJldmVudCByZXNvdXJjZSBleGhhdXN0aW9uJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChhbm9tYWx5U3RhdHMuYWN0aXZlQWxlcnRzID4gMikge1xuICAgICAgcmVjb21tZW5kYXRpb25zLnB1c2goJ0ludmVzdGlnYXRlIG11bHRpcGxlIGFjdGl2ZSBhbm9tYWxpZXMnKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKHBlcmZvcm1hbmNlU3RhdHMuc3lzdGVtSGVhbHRoID09PSAnY3JpdGljYWwnKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnUGVyZm9ybWFuY2UgaXMgY3JpdGljYWwgLSBjaGVjayBzeXN0ZW0gcmVzb3VyY2VzJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChyZWNvbW1lbmRhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZWNvbW1lbmRhdGlvbnMucHVzaCgnU3lzdGVtIGhlYWx0aCBpcyBnb29kIC0gY29udGludWUgbW9uaXRvcmluZycpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBnZW5lcmF0ZUluc2lnaHRzKCk6IFByb21pc2U8e1xuICAgIHRvcFJpc2tzOiBzdHJpbmdbXTtcbiAgICBvcHRpbWl6YXRpb25PcHBvcnR1bml0aWVzOiBzdHJpbmdbXTtcbiAgICB0cmVuZGluZ01ldHJpY3M6IHN0cmluZ1tdO1xuICB9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcFJpc2tzOiBbJ0hpZ2ggbWVtb3J5IHV0aWxpemF0aW9uJywgJ0luY3JlYXNpbmcgcmVzcG9uc2UgdGltZXMnXSxcbiAgICAgIG9wdGltaXphdGlvbk9wcG9ydHVuaXRpZXM6IFsnQ1BVIG9wdGltaXphdGlvbiBwb3NzaWJsZScsICdDYWNoZSBoaXQgcmF0ZSBpbXByb3ZlbWVudHMnXSxcbiAgICAgIHRyZW5kaW5nTWV0cmljczogWydjcHVfdXNhZ2UnLCAnbWVtb3J5X3VzYWdlJywgJ3Jlc3BvbnNlX3RpbWUnXVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGdlbmVyYXRlQWN0aW9uUGxhbihcbiAgICBoZWFsdGhTY29yZTogYW55LFxuICAgIGFub21hbGllczogYW55W10sXG4gICAgY2FwYWNpdHlGb3JlY2FzdHM6IGFueVtdLFxuICAgIG9wdGltaXphdGlvbnM6IGFueVtdXG4gICk6IHN0cmluZ1tdIHtcbiAgICBjb25zdCBhY3Rpb25zOiBzdHJpbmdbXSA9IFtdO1xuICAgIFxuICAgIGlmIChoZWFsdGhTY29yZS5yaXNrTGV2ZWwgPT09ICdjcml0aWNhbCcpIHtcbiAgICAgIGFjdGlvbnMucHVzaCgnVVJHRU5UOiBBZGRyZXNzIGNyaXRpY2FsIHN5c3RlbSBoZWFsdGggaXNzdWVzJyk7XG4gICAgfVxuICAgIFxuICAgIGlmIChhbm9tYWxpZXMubGVuZ3RoID4gMCkge1xuICAgICAgYWN0aW9ucy5wdXNoKGBJbnZlc3RpZ2F0ZSAke2Fub21hbGllcy5sZW5ndGh9IGFjdGl2ZSBhbm9tYWxpZXNgKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKG9wdGltaXphdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgYWN0aW9ucy5wdXNoKCdJbXBsZW1lbnQgaWRlbnRpZmllZCBvcHRpbWl6YXRpb24gb3Bwb3J0dW5pdGllcycpO1xuICAgIH1cbiAgICBcbiAgICBhY3Rpb25zLnB1c2goJ0NvbnRpbnVlIG1vbml0b3Jpbmcgc3lzdGVtIGhlYWx0aCB0cmVuZHMnKTtcbiAgICBcbiAgICByZXR1cm4gYWN0aW9ucztcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQW5vbWFseURldGVjdGVkKGFub21hbHk6IGFueSk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKGBBbm9tYWx5IGRldGVjdGVkOiAke2Fub21hbHkuZGVzY3JpcHRpb259YCk7XG4gICAgdGhpcy5lbWl0KCdhbm9tYWx5JywgYW5vbWFseSk7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUFsZXJ0UmVzb2x2ZWQoYWxlcnQ6IGFueSk6IHZvaWQge1xuICAgIGNvbnNvbGUubG9nKGBBbGVydCByZXNvbHZlZDogJHthbGVydC5hbGVydC5pZH1gKTtcbiAgICB0aGlzLmVtaXQoJ2FsZXJ0X3Jlc29sdmVkJywgYWxlcnQpO1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVQZXJmb3JtYW5jZUFsZXJ0KGFsZXJ0OiBhbnkpOiB2b2lkIHtcbiAgICBjb25zb2xlLmxvZyhgUGVyZm9ybWFuY2UgYWxlcnQ6ICR7YWxlcnQubWVzc2FnZX1gKTtcbiAgICB0aGlzLmVtaXQoJ3BlcmZvcm1hbmNlX2FsZXJ0JywgYWxlcnQpO1xuICB9XG5cbiAgLy8gU2ltcGxpZmllZCBkYXRhIGdldHRlcnMgKHdvdWxkIGJlIG1vcmUgY29tcHJlaGVuc2l2ZSBpbiByZWFsIGltcGxlbWVudGF0aW9uKVxuICBwcml2YXRlIGFzeW5jIGdldFByZWRpY3Rpb25zKCk6IFByb21pc2U8YW55W10+IHsgcmV0dXJuIFtdOyB9XG4gIHByaXZhdGUgYXN5bmMgZ2V0QW5vbWFsaWVzKCk6IFByb21pc2U8YW55W10+IHsgXG4gICAgcmV0dXJuIHRoaXMuYW5vbWFseURldGVjdG9yLmdldEFjdGl2ZUFsZXJ0cygpOyBcbiAgfVxuICBwcml2YXRlIGFzeW5jIGdldENhcGFjaXR5Rm9yZWNhc3RzKCk6IFByb21pc2U8YW55W10+IHsgXG4gICAgY29uc3QgZm9yZWNhc3RzID0gYXdhaXQgdGhpcy5jYXBhY2l0eVBsYW5uZXIuZ2VuZXJhdGVDYXBhY2l0eUZvcmVjYXN0KCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZm9yZWNhc3RzLnZhbHVlcygpKS5mbGF0KCk7XG4gIH1cbiAgcHJpdmF0ZSBhc3luYyBnZXRPcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbnMoKTogUHJvbWlzZTxhbnlbXT4geyBcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhhd2FpdCB0aGlzLmNhcGFjaXR5UGxhbm5lci5nZW5lcmF0ZU9wdGltaXphdGlvblJlY29tbWVuZGF0aW9ucygpKS5mbGF0KCk7XG4gIH1cbn1cblxuLy8gRXhwb3J0IHNpbmdsZXRvbiBpbnN0YW5jZVxuZXhwb3J0IGNvbnN0IG1sQW5hbHl0aWNzQ29vcmRpbmF0b3IgPSBuZXcgTUxBbmFseXRpY3NDb29yZGluYXRvcigpOyJdLCJuYW1lcyI6WyJNTEFuYWx5dGljc0Nvb3JkaW5hdG9yIiwibWxBbmFseXRpY3NDb29yZGluYXRvciIsIkV2ZW50RW1pdHRlciIsImluaXRpYWxpemUiLCJpc0luaXRpYWxpemVkIiwiY29uc29sZSIsImxvZyIsInBlcmZvcm1hbmNlTW9uaXRvciIsInN0YXJ0TW9uaXRvcmluZyIsImNvbmZpZyIsIm1vbml0b3JpbmciLCJwZXJmb3JtYW5jZUludGVydmFsIiwiZW5hYmxlQW5vbWFseURldGVjdGlvbiIsImluaXRpYWxpemVBbm9tYWx5RGV0ZWN0aW9uIiwiZW5hYmxlQ2FwYWNpdHlQbGFubmluZyIsImluaXRpYWxpemVDYXBhY2l0eVBsYW5uaW5nIiwiZW5hYmxlUHJlZGljdGl2ZUFuYWx5dGljcyIsImluaXRpYWxpemVQcmVkaWN0aXZlQW5hbHl0aWNzIiwiYXV0b1RyYWluaW5nIiwiZW5hYmxlZCIsInN0YXJ0QXV0b1RyYWluaW5nIiwic3RhcnRIZWFsdGhNb25pdG9yaW5nIiwiaXNSdW5uaW5nIiwiZW1pdCIsImVycm9yIiwic3RhcnQiLCJhbm9tYWx5RGV0ZWN0b3IiLCJzdGFydERldGVjdGlvbiIsImFub21hbHlEZXRlY3Rpb25JbnRlcnZhbCIsImNhcGFjaXR5UGxhbm5lciIsImNhcGFjaXR5UGxhbm5pbmdJbnRlcnZhbCIsInN0b3AiLCJhdXRvVHJhaW5pbmdJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJoZWFsdGhDaGVja0ludGVydmFsIiwic3RvcERldGVjdGlvbiIsInN0b3BNb25pdG9yaW5nIiwiZ2V0U3lzdGVtSGVhbHRoU2NvcmUiLCJwZXJmb3JtYW5jZVN0YXRzIiwiZ2V0UGVyZm9ybWFuY2VTdW1tYXJ5IiwicGVyZm9ybWFuY2VTY29yZSIsImNhbGN1bGF0ZVBlcmZvcm1hbmNlU2NvcmUiLCJjYXBhY2l0eUFsZXJ0cyIsImdldENhcGFjaXR5QWxlcnRzIiwiY2FwYWNpdHlTY29yZSIsImNhbGN1bGF0ZUNhcGFjaXR5U2NvcmUiLCJhbm9tYWx5U3RhdHMiLCJnZXREZXRlY3Rpb25TdGF0cyIsImFub21hbHlTY29yZSIsImNhbGN1bGF0ZUFub21hbHlTY29yZSIsInByZWRpY3Rpb25TY29yZSIsImNhbGN1bGF0ZVByZWRpY3Rpb25TY29yZSIsIm92ZXJhbGwiLCJNYXRoIiwicm91bmQiLCJ0cmVuZHMiLCJhbmFseXplVHJlbmRzIiwicmlza0xldmVsIiwiZGV0ZXJtaW5lUmlza0xldmVsIiwicmVjb21tZW5kYXRpb25zIiwiZ2VuZXJhdGVIZWFsdGhSZWNvbW1lbmRhdGlvbnMiLCJjb21wb25lbnRzIiwicGVyZm9ybWFuY2UiLCJjYXBhY2l0eSIsImFub21hbGllcyIsInByZWRpY3Rpb25zIiwiaW1wcm92aW5nIiwic3RhYmxlIiwiZGVncmFkaW5nIiwiZ2V0QW5hbHl0aWNzU3VtbWFyeSIsInN5c3RlbUhlYWx0aCIsImluc2lnaHRzIiwiZ2VuZXJhdGVJbnNpZ2h0cyIsInRpbWVzdGFtcCIsIkRhdGUiLCJhY3RpdmVQcmVkaWN0aW9ucyIsImFjdGl2ZUFub21hbGllcyIsImFjdGl2ZUFsZXJ0cyIsImxlbmd0aCIsIm1vZGVsc1RyYWluaW5nIiwidXB0aW1lIiwibm93Iiwic3RhcnRUaW1lIiwiZ2V0VGltZSIsInBlcmZvcm1hbmNlTWV0cmljcyIsImF2Z1Jlc3BvbnNlVGltZSIsImVycm9yUmF0ZSIsInRocm91Z2hwdXQiLCJyZXNvdXJjZVV0aWxpemF0aW9uIiwidXBkYXRlQ29uZmlnIiwibmV3Q29uZmlnIiwiZ2V0Q29uZmlnIiwiZ2V0U3RhdHVzIiwic2VydmljZXMiLCJwcmVkaWN0aXZlQW5hbHl0aWNzIiwiYW5vbWFseURldGVjdGlvbiIsImNhcGFjaXR5UGxhbm5pbmciLCJwZXJmb3JtYW5jZU1vbml0b3JpbmciLCJwZXJmb3JtU3lzdGVtQW5hbHlzaXMiLCJoZWFsdGhTY29yZSIsImNhcGFjaXR5Rm9yZWNhc3RzIiwib3B0aW1pemF0aW9uUmVjb21tZW5kYXRpb25zIiwiUHJvbWlzZSIsImFsbCIsImdldFByZWRpY3Rpb25zIiwiZ2V0QW5vbWFsaWVzIiwiZ2V0Q2FwYWNpdHlGb3JlY2FzdHMiLCJnZXRPcHRpbWl6YXRpb25SZWNvbW1lbmRhdGlvbnMiLCJhY3Rpb25QbGFuIiwiZ2VuZXJhdGVBY3Rpb25QbGFuIiwiaW5pdGlhbGl6ZVNlcnZpY2VzIiwiUHJlZGljdGl2ZUFuYWx5dGljcyIsImFuYWx5dGljc0VuZ2luZSIsIkFuYWx5dGljc0VuZ2luZSIsImdldEluc3RhbmNlIiwiUGVyZm9ybWFuY2VNb25pdG9yIiwic2V0dXBFdmVudExpc3RlbmVycyIsIm9uIiwiYW5vbWFseSIsImhhbmRsZUFub21hbHlEZXRlY3RlZCIsImFsZXJ0IiwiaGFuZGxlQWxlcnRSZXNvbHZlZCIsImhhbmRsZVBlcmZvcm1hbmNlQWxlcnQiLCJrZXlNZXRyaWNzIiwidHJhaW5BdXRvZW5jb2Rlck1vZGVsIiwibWV0cmljIiwidXBkYXRlU3RhdGlzdGljYWxUaHJlc2hvbGRzIiwid2FybiIsIm1lc3NhZ2UiLCJ0cmFpbkNhcGFjaXR5TW9kZWwiLCJpbnRlcnZhbE1zIiwiaW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImF1dG9SZXRyYWluTW9kZWxzIiwic3RhdHMiLCJhbGVydHMiLCJjcml0aWNhbEFsZXJ0cyIsImZpbHRlciIsImEiLCJzZXZlcml0eSIsIndhcm5pbmdBbGVydHMiLCJkZXRlY3Rpb25BY2N1cmFjeSIsImZhbHNlUG9zaXRpdmVSYXRlIiwic2NvcmUiLCJtaW4iLCJtYXgiLCJzb21lIiwicHVzaCIsInRvcFJpc2tzIiwib3B0aW1pemF0aW9uT3Bwb3J0dW5pdGllcyIsInRyZW5kaW5nTWV0cmljcyIsIm9wdGltaXphdGlvbnMiLCJhY3Rpb25zIiwiZGVzY3JpcHRpb24iLCJpZCIsImdldEFjdGl2ZUFsZXJ0cyIsImZvcmVjYXN0cyIsImdlbmVyYXRlQ2FwYWNpdHlGb3JlY2FzdCIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsImZsYXQiLCJPYmplY3QiLCJnZW5lcmF0ZU9wdGltaXphdGlvblJlY29tbWVuZGF0aW9ucyIsInRyYWluaW5nRGF0YSIsInRpbWVmcmFtZURheXMiLCJtaW5TYW1wbGVzIiwiYWxlcnRpbmciLCJlbmFibGVTbGFja0ludGVncmF0aW9uIiwiZW5hYmxlRW1haWxBbGVydHMiLCJzZXZlcml0eVRocmVzaG9sZHMiLCJjcml0aWNhbCIsImhpZ2giLCJtZWRpdW0iLCJtb2RlbHMiLCJyZXRlbnRpb25EYXlzIiwibWF4TW9kZWxzUGVyVHlwZSIsImF1dG9DbGVhbnVwIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztRQThFYUE7ZUFBQUE7O1FBd3BCQUM7ZUFBQUE7Ozt3QkF0dUJnQjtxQ0FDTztpQ0FDYTtpQ0FDQTtpQ0FDakI7b0NBQ0c7Ozs7Ozs7Ozs7Ozs7O0FBeUU1QixNQUFNRCwrQkFBK0JFLG9CQUFZO0lBd0R0RDs7R0FFQyxHQUNELE1BQWFDLGFBQTRCO1FBQ3ZDLElBQUksSUFBSSxDQUFDQyxhQUFhLEVBQUU7WUFDdEJDLFFBQVFDLEdBQUcsQ0FBQztZQUNaO1FBQ0Y7UUFFQSxJQUFJO1lBQ0ZELFFBQVFDLEdBQUcsQ0FBQztZQUVaLDBDQUEwQztZQUMxQyxJQUFJLENBQUNDLGtCQUFrQixDQUFDQyxlQUFlLENBQUMsSUFBSSxDQUFDQyxNQUFNLENBQUNDLFVBQVUsQ0FBQ0MsbUJBQW1CO1lBRWxGLDBDQUEwQztZQUMxQyxJQUFJLElBQUksQ0FBQ0YsTUFBTSxDQUFDRyxzQkFBc0IsRUFBRTtnQkFDdEMsTUFBTSxJQUFJLENBQUNDLDBCQUEwQjtZQUN2QztZQUVBLDBDQUEwQztZQUMxQyxJQUFJLElBQUksQ0FBQ0osTUFBTSxDQUFDSyxzQkFBc0IsRUFBRTtnQkFDdEMsTUFBTSxJQUFJLENBQUNDLDBCQUEwQjtZQUN2QztZQUVBLDZDQUE2QztZQUM3QyxJQUFJLElBQUksQ0FBQ04sTUFBTSxDQUFDTyx5QkFBeUIsRUFBRTtnQkFDekMsTUFBTSxJQUFJLENBQUNDLDZCQUE2QjtZQUMxQztZQUVBLGlDQUFpQztZQUNqQyxJQUFJ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