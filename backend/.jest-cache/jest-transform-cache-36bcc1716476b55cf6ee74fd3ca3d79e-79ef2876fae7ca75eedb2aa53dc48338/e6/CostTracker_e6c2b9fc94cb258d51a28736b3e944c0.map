{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/CostTracker.ts"],"sourcesContent":["import { db } from '../database/connection';\nimport {\n  CostData,\n  ModelPricing,\n  CostSummary,\n  CostOptimizationRecommendation,\n  BudgetAlert,\n  CostPrediction,\n  UsageAnalytics,\n  CostOptimizationSettings,\n  ROICalculation\n} from '../types/costTracking';\n\n/**\n * Comprehensive Cost Tracking Service\n * Tracks token usage, calculates costs, provides optimization recommendations\n */\nexport class CostTracker {\n  private modelPricing: Map<string, ModelPricing> = new Map();\n  private optimizationSettings: CostOptimizationSettings;\n\n  constructor() {\n    this.optimizationSettings = {\n      enableAutoOptimization: true,\n      costThreshold: 10.0, // $10 threshold\n      tokenThreshold: 100000, // 100k tokens\n      modelPreferences: ['gpt-3.5-turbo', 'llama3'], // Preferred models for cost optimization\n      promptOptimization: true,\n      batchingEnabled: true,\n      cachingEnabled: true\n    };\n    \n    this.initializePricing();\n    this.initializeDatabase();\n  }\n\n  /**\n   * Initialize database tables for cost tracking\n   */\n  private initializeDatabase(): void {\n    console.log('Initializing cost tracking database...');\n    \n    // Cost tracking data table\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS cost_tracking (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        execution_id TEXT NOT NULL,\n        model TEXT NOT NULL,\n        prompt_tokens INTEGER NOT NULL DEFAULT 0,\n        completion_tokens INTEGER NOT NULL DEFAULT 0,\n        total_tokens INTEGER NOT NULL DEFAULT 0,\n        cost_usd REAL NOT NULL DEFAULT 0,\n        execution_time_ms INTEGER NOT NULL DEFAULT 0,\n        test_case_id INTEGER,\n        prompt_card_id INTEGER,\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (test_case_id) REFERENCES test_cases(id) ON DELETE CASCADE,\n        FOREIGN KEY (prompt_card_id) REFERENCES prompt_cards(id) ON DELETE CASCADE\n      )\n    `);\n\n    // Model pricing table\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS model_pricing (\n        model TEXT PRIMARY KEY,\n        prompt_token_cost REAL NOT NULL,\n        completion_token_cost REAL NOT NULL,\n        context_window INTEGER NOT NULL,\n        last_updated DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Budget alerts table\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS budget_alerts (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        name TEXT NOT NULL,\n        type TEXT NOT NULL CHECK (type IN ('daily', 'weekly', 'monthly', 'total')),\n        threshold REAL NOT NULL,\n        current_amount REAL DEFAULT 0,\n        percentage_used REAL DEFAULT 0,\n        status TEXT DEFAULT 'active' CHECK (status IN ('active', 'triggered', 'exceeded')),\n        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,\n        triggered_at DATETIME\n      )\n    `);\n\n    // Cost optimization settings table\n    db.exec(`\n      CREATE TABLE IF NOT EXISTS cost_optimization_settings (\n        id INTEGER PRIMARY KEY CHECK (id = 1),\n        enable_auto_optimization BOOLEAN DEFAULT 1,\n        cost_threshold REAL DEFAULT 10.0,\n        token_threshold INTEGER DEFAULT 100000,\n        model_preferences TEXT DEFAULT '[]',\n        prompt_optimization BOOLEAN DEFAULT 1,\n        batching_enabled BOOLEAN DEFAULT 1,\n        caching_enabled BOOLEAN DEFAULT 1,\n        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP\n      )\n    `);\n\n    // Create indexes for better performance\n    db.exec(`\n      CREATE INDEX IF NOT EXISTS idx_cost_tracking_execution_id ON cost_tracking(execution_id);\n      CREATE INDEX IF NOT EXISTS idx_cost_tracking_model ON cost_tracking(model);\n      CREATE INDEX IF NOT EXISTS idx_cost_tracking_created_at ON cost_tracking(created_at);\n      CREATE INDEX IF NOT EXISTS idx_cost_tracking_prompt_card_id ON cost_tracking(prompt_card_id);\n    `);\n\n    console.log('Cost tracking database initialized successfully');\n  }\n\n  /**\n   * Initialize model pricing data\n   */\n  private initializePricing(): void {\n    const defaultPricing: ModelPricing[] = [\n      {\n        model: 'gpt-4',\n        prompt_token_cost: 0.03, // $0.03 per 1k tokens\n        completion_token_cost: 0.06, // $0.06 per 1k tokens\n        context_window: 8192,\n        last_updated: new Date().toISOString()\n      },\n      {\n        model: 'gpt-4-turbo',\n        prompt_token_cost: 0.01, // $0.01 per 1k tokens\n        completion_token_cost: 0.03, // $0.03 per 1k tokens\n        context_window: 128000,\n        last_updated: new Date().toISOString()\n      },\n      {\n        model: 'gpt-3.5-turbo',\n        prompt_token_cost: 0.0015, // $0.0015 per 1k tokens\n        completion_token_cost: 0.002, // $0.002 per 1k tokens\n        context_window: 16385,\n        last_updated: new Date().toISOString()\n      },\n      {\n        model: 'llama3',\n        prompt_token_cost: 0.0, // Open source - no cost\n        completion_token_cost: 0.0,\n        context_window: 8192,\n        last_updated: new Date().toISOString()\n      },\n      {\n        model: 'claude-3-sonnet',\n        prompt_token_cost: 0.003, // $0.003 per 1k tokens\n        completion_token_cost: 0.015, // $0.015 per 1k tokens\n        context_window: 200000,\n        last_updated: new Date().toISOString()\n      }\n    ];\n\n    // Insert default pricing into database\n    const insertPricing = db.prepare(`\n      INSERT OR REPLACE INTO model_pricing \n      (model, prompt_token_cost, completion_token_cost, context_window, last_updated)\n      VALUES (?, ?, ?, ?, ?)\n    `);\n\n    for (const pricing of defaultPricing) {\n      insertPricing.run(\n        pricing.model,\n        pricing.prompt_token_cost,\n        pricing.completion_token_cost,\n        pricing.context_window,\n        pricing.last_updated\n      );\n      this.modelPricing.set(pricing.model, pricing);\n    }\n\n    console.log('Model pricing initialized');\n  }\n\n  /**\n   * Track token usage and calculate cost for an execution\n   */\n  public async trackUsage(\n    executionId: string,\n    model: string,\n    promptTokens: number,\n    completionTokens: number,\n    executionTimeMs: number,\n    testCaseId?: number,\n    promptCardId?: number\n  ): Promise<CostData> {\n    const totalTokens = promptTokens + completionTokens;\n    const cost = this.calculateCost(model, promptTokens, completionTokens);\n\n    const insertCost = db.prepare(`\n      INSERT INTO cost_tracking \n      (execution_id, model, prompt_tokens, completion_tokens, total_tokens, cost_usd, execution_time_ms, test_case_id, prompt_card_id)\n      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `);\n\n    const result = insertCost.run(\n      executionId,\n      model,\n      promptTokens,\n      completionTokens,\n      totalTokens,\n      cost,\n      executionTimeMs,\n      testCaseId,\n      promptCardId\n    );\n\n    const costData: CostData = {\n      id: result.lastInsertRowid as number,\n      execution_id: executionId,\n      model,\n      prompt_tokens: promptTokens,\n      completion_tokens: completionTokens,\n      total_tokens: totalTokens,\n      cost_usd: cost,\n      execution_time_ms: executionTimeMs,\n      test_case_id: testCaseId,\n      prompt_card_id: promptCardId,\n      created_at: new Date().toISOString()\n    };\n\n    // Check budget alerts\n    await this.checkBudgetAlerts();\n\n    return costData;\n  }\n\n  /**\n   * Calculate cost for given token usage\n   */\n  private calculateCost(model: string, promptTokens: number, completionTokens: number): number {\n    const pricing = this.modelPricing.get(model);\n    if (!pricing) {\n      console.warn(`No pricing found for model: ${model}, assuming zero cost`);\n      return 0;\n    }\n\n    const promptCost = (promptTokens / 1000) * pricing.prompt_token_cost;\n    const completionCost = (completionTokens / 1000) * pricing.completion_token_cost;\n    return promptCost + completionCost;\n  }\n\n  /**\n   * Get cost summary for a given time period\n   */\n  public async getCostSummary(\n    startDate?: string,\n    endDate?: string,\n    promptCardId?: number\n  ): Promise<CostSummary> {\n    let query = `\n      SELECT \n        model,\n        SUM(cost_usd) as total_cost,\n        SUM(total_tokens) as total_tokens,\n        SUM(prompt_tokens) as total_prompt_tokens,\n        SUM(completion_tokens) as total_completion_tokens,\n        COUNT(*) as total_executions\n      FROM cost_tracking\n      WHERE 1=1\n    `;\n\n    const params: any[] = [];\n\n    if (startDate) {\n      query += ` AND created_at >= ?`;\n      params.push(startDate);\n    }\n\n    if (endDate) {\n      query += ` AND created_at <= ?`;\n      params.push(endDate);\n    }\n\n    if (promptCardId) {\n      query += ` AND prompt_card_id = ?`;\n      params.push(promptCardId);\n    }\n\n    query += ` GROUP BY model`;\n\n    const results = db.prepare(query).all(...params);\n\n    const costByModel: Record<string, number> = {};\n    const tokensByModel: Record<string, number> = {};\n    const executionsByModel: Record<string, number> = {};\n\n    let totalCost = 0;\n    let totalTokens = 0;\n    let totalPromptTokens = 0;\n    let totalCompletionTokens = 0;\n    let totalExecutions = 0;\n\n    for (const result of results) {\n      const model = result.model;\n      const cost = result.total_cost;\n      const tokens = result.total_tokens;\n      const executions = result.total_executions;\n\n      costByModel[model] = cost;\n      tokensByModel[model] = tokens;\n      executionsByModel[model] = executions;\n\n      totalCost += cost;\n      totalTokens += tokens;\n      totalPromptTokens += result.total_prompt_tokens;\n      totalCompletionTokens += result.total_completion_tokens;\n      totalExecutions += executions;\n    }\n\n    return {\n      totalCost,\n      totalTokens,\n      totalPromptTokens,\n      totalCompletionTokens,\n      totalExecutions,\n      averageCostPerExecution: totalExecutions > 0 ? totalCost / totalExecutions : 0,\n      averageTokensPerExecution: totalExecutions > 0 ? totalTokens / totalExecutions : 0,\n      costByModel,\n      tokensByModel,\n      executionsByModel\n    };\n  }\n\n  /**\n   * Generate cost optimization recommendations\n   */\n  public async generateOptimizationRecommendations(\n    startDate?: string,\n    endDate?: string\n  ): Promise<CostOptimizationRecommendation[]> {\n    const recommendations: CostOptimizationRecommendation[] = [];\n    const summary = await this.getCostSummary(startDate, endDate);\n\n    // Model optimization recommendations\n    const sortedModels = Object.entries(summary.costByModel)\n      .sort(([,a], [,b]) => b - a);\n\n    if (sortedModels.length > 1) {\n      const mostExpensiveModel = sortedModels[0][0];\n      const mostExpensiveCost = sortedModels[0][1];\n      const cheapestModel = sortedModels[sortedModels.length - 1][0];\n      const cheapestCost = sortedModels[sortedModels.length - 1][1];\n\n      if (mostExpensiveCost > cheapestCost * 2) {\n        recommendations.push({\n          type: 'model_suggestion',\n          title: `Consider switching from ${mostExpensiveModel} to ${cheapestModel}`,\n          description: `${mostExpensiveModel} accounts for $${mostExpensiveCost.toFixed(2)} of your costs. Consider using ${cheapestModel} for appropriate tasks.`,\n          estimatedSavings: mostExpensiveCost - cheapestCost,\n          estimatedSavingsPercentage: ((mostExpensiveCost - cheapestCost) / mostExpensiveCost) * 100,\n          priority: 'high',\n          actionRequired: `Review test cases using ${mostExpensiveModel} and evaluate if ${cheapestModel} would be sufficient.`,\n          metadata: {\n            currentModel: mostExpensiveModel,\n            suggestedModel: cheapestModel,\n            currentCost: mostExpensiveCost,\n            suggestedCost: cheapestCost\n          }\n        });\n      }\n    }\n\n    // High token usage recommendations\n    if (summary.averageTokensPerExecution > 2000) {\n      recommendations.push({\n        type: 'token_reduction',\n        title: 'High token usage detected',\n        description: `Average token usage is ${summary.averageTokensPerExecution.toFixed(0)} tokens per execution. Consider optimizing prompts.`,\n        estimatedSavings: summary.totalCost * 0.3, // Estimate 30% savings\n        estimatedSavingsPercentage: 30,\n        priority: 'medium',\n        actionRequired: 'Review and optimize prompt templates to reduce token usage.',\n        metadata: {\n          averageTokens: summary.averageTokensPerExecution,\n          totalTokens: summary.totalTokens\n        }\n      });\n    }\n\n    // Execution frequency recommendations\n    if (summary.totalExecutions > 1000) {\n      recommendations.push({\n        type: 'execution_reduction',\n        title: 'High execution frequency',\n        description: `${summary.totalExecutions} executions recorded. Consider implementing caching or batching.`,\n        estimatedSavings: summary.totalCost * 0.2, // Estimate 20% savings\n        estimatedSavingsPercentage: 20,\n        priority: 'low',\n        actionRequired: 'Implement result caching and batch processing for similar test cases.',\n        metadata: {\n          totalExecutions: summary.totalExecutions,\n          avgCostPerExecution: summary.averageCostPerExecution\n        }\n      });\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Create or update budget alert\n   */\n  public async createBudgetAlert(\n    name: string,\n    type: 'daily' | 'weekly' | 'monthly' | 'total',\n    threshold: number\n  ): Promise<BudgetAlert> {\n    const insertAlert = db.prepare(`\n      INSERT INTO budget_alerts (name, type, threshold)\n      VALUES (?, ?, ?)\n    `);\n\n    const result = insertAlert.run(name, type, threshold);\n    \n    return {\n      id: result.lastInsertRowid as number,\n      name,\n      type,\n      threshold,\n      current_amount: 0,\n      percentage_used: 0,\n      status: 'active',\n      created_at: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Check budget alerts and update their status\n   */\n  public async checkBudgetAlerts(): Promise<BudgetAlert[]> {\n    const alerts = db.prepare(`\n      SELECT * FROM budget_alerts WHERE status IN ('active', 'triggered')\n    `).all();\n\n    const triggeredAlerts: BudgetAlert[] = [];\n\n    for (const alert of alerts) {\n      const currentAmount = await this.getCurrentSpendingForAlert(alert.type);\n      const percentageUsed = (currentAmount / alert.threshold) * 100;\n\n      let newStatus = alert.status;\n      if (percentageUsed >= 100) {\n        newStatus = 'exceeded';\n      } else if (percentageUsed >= 80) {\n        newStatus = 'triggered';\n      }\n\n      // Update alert with current amounts\n      db.prepare(`\n        UPDATE budget_alerts \n        SET current_amount = ?, percentage_used = ?, status = ?\n        WHERE id = ?\n      `).run(currentAmount, percentageUsed, newStatus, alert.id);\n\n      if (newStatus !== alert.status) {\n        triggeredAlerts.push({\n          ...alert,\n          current_amount: currentAmount,\n          percentage_used: percentageUsed,\n          status: newStatus as any\n        });\n      }\n    }\n\n    return triggeredAlerts;\n  }\n\n  /**\n   * Get current spending for alert period\n   */\n  private async getCurrentSpendingForAlert(type: string): Promise<number> {\n    let startDate: string;\n    const now = new Date();\n\n    switch (type) {\n      case 'daily':\n        startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();\n        break;\n      case 'weekly':\n        const weekStart = new Date(now);\n        weekStart.setDate(now.getDate() - now.getDay());\n        startDate = weekStart.toISOString();\n        break;\n      case 'monthly':\n        startDate = new Date(now.getFullYear(), now.getMonth(), 1).toISOString();\n        break;\n      case 'total':\n        startDate = '1970-01-01T00:00:00.000Z';\n        break;\n      default:\n        return 0;\n    }\n\n    const result = db.prepare(`\n      SELECT SUM(cost_usd) as total_cost \n      FROM cost_tracking \n      WHERE created_at >= ?\n    `).get(startDate);\n\n    return result?.total_cost || 0;\n  }\n\n  /**\n   * Generate cost predictions based on historical data\n   */\n  public async generateCostPrediction(\n    period: 'daily' | 'weekly' | 'monthly'\n  ): Promise<CostPrediction> {\n    const days = period === 'daily' ? 7 : period === 'weekly' ? 28 : 90;\n    const startDate = new Date();\n    startDate.setDate(startDate.getDate() - days);\n\n    const historicalData = db.prepare(`\n      SELECT \n        DATE(created_at) as date,\n        SUM(cost_usd) as daily_cost,\n        SUM(total_tokens) as daily_tokens,\n        COUNT(*) as daily_executions\n      FROM cost_tracking\n      WHERE created_at >= ?\n      GROUP BY DATE(created_at)\n      ORDER BY date\n    `).all(startDate.toISOString());\n\n    if (historicalData.length < 3) {\n      return {\n        period,\n        predictedCost: 0,\n        confidence: 0,\n        basedOnDays: historicalData.length,\n        trend: 'stable',\n        factors: ['Insufficient historical data']\n      };\n    }\n\n    const costs = historicalData.map(d => d.daily_cost);\n    const avgDailyCost = costs.reduce((a, b) => a + b, 0) / costs.length;\n    \n    // Simple trend analysis\n    const recentCosts = costs.slice(-7);\n    const earlierCosts = costs.slice(0, 7);\n    const recentAvg = recentCosts.reduce((a, b) => a + b, 0) / recentCosts.length;\n    const earlierAvg = earlierCosts.reduce((a, b) => a + b, 0) / earlierCosts.length;\n\n    let trend: 'increasing' | 'decreasing' | 'stable' = 'stable';\n    if (recentAvg > earlierAvg * 1.1) {\n      trend = 'increasing';\n    } else if (recentAvg < earlierAvg * 0.9) {\n      trend = 'decreasing';\n    }\n\n    const multiplier = period === 'daily' ? 1 : period === 'weekly' ? 7 : 30;\n    const predictedCost = avgDailyCost * multiplier;\n\n    return {\n      period,\n      predictedCost,\n      confidence: Math.min(historicalData.length / 30, 1), // Higher confidence with more data\n      basedOnDays: historicalData.length,\n      trend,\n      factors: [\n        `Based on ${historicalData.length} days of historical data`,\n        `Average daily cost: $${avgDailyCost.toFixed(2)}`,\n        `Trend: ${trend}`\n      ]\n    };\n  }\n\n  /**\n   * Get usage analytics for a time period\n   */\n  public async getUsageAnalytics(\n    startDate: string,\n    endDate: string\n  ): Promise<UsageAnalytics> {\n    const summary = await this.getCostSummary(startDate, endDate);\n    \n    // Get daily trend data\n    const trendData = db.prepare(`\n      SELECT \n        DATE(created_at) as date,\n        SUM(cost_usd) as cost,\n        SUM(total_tokens) as tokens,\n        COUNT(*) as executions\n      FROM cost_tracking\n      WHERE created_at >= ? AND created_at <= ?\n      GROUP BY DATE(created_at)\n      ORDER BY date\n    `).all(startDate, endDate);\n\n    const dayCount = Math.max(1, Math.ceil((new Date(endDate).getTime() - new Date(startDate).getTime()) / (24 * 60 * 60 * 1000)));\n    \n    // Find peak usage day\n    const peakDay = trendData.reduce((max, day) => \n      day.cost > max.cost ? day : max, \n      trendData[0] || { date: startDate, cost: 0, tokens: 0, executions: 0 }\n    );\n\n    // Model usage breakdown\n    const modelUsage = Object.entries(summary.costByModel).map(([model, cost]) => ({\n      model,\n      cost,\n      tokens: summary.tokensByModel[model] || 0,\n      executions: summary.executionsByModel[model] || 0,\n      percentage: (cost / summary.totalCost) * 100\n    })).sort((a, b) => b.cost - a.cost);\n\n    return {\n      period: {\n        start: startDate,\n        end: endDate\n      },\n      totalCost: summary.totalCost,\n      totalTokens: summary.totalTokens,\n      totalExecutions: summary.totalExecutions,\n      averageCostPerDay: summary.totalCost / dayCount,\n      averageTokensPerDay: summary.totalTokens / dayCount,\n      averageExecutionsPerDay: summary.totalExecutions / dayCount,\n      peakUsageDay: peakDay.date,\n      peakUsageCost: peakDay.cost,\n      costTrend: trendData.map(d => ({\n        date: d.date,\n        cost: d.cost,\n        tokens: d.tokens,\n        executions: d.executions\n      })),\n      modelUsage\n    };\n  }\n\n  /**\n   * Calculate ROI for test executions\n   */\n  public async calculateROI(\n    startDate?: string,\n    endDate?: string,\n    promptCardId?: number\n  ): Promise<ROICalculation> {\n    const summary = await this.getCostSummary(startDate, endDate, promptCardId);\n    \n    // Get success/failure statistics\n    let query = `\n      SELECT \n        COUNT(*) as total_executions,\n        SUM(CASE WHEN passed = 1 THEN 1 ELSE 0 END) as successful_executions,\n        SUM(CASE WHEN passed = 0 THEN 1 ELSE 0 END) as failed_executions\n      FROM test_results tr\n      JOIN cost_tracking ct ON tr.execution_id = ct.execution_id\n      WHERE 1=1\n    `;\n\n    const params: any[] = [];\n\n    if (startDate) {\n      query += ` AND ct.created_at >= ?`;\n      params.push(startDate);\n    }\n\n    if (endDate) {\n      query += ` AND ct.created_at <= ?`;\n      params.push(endDate);\n    }\n\n    if (promptCardId) {\n      query += ` AND ct.prompt_card_id = ?`;\n      params.push(promptCardId);\n    }\n\n    const result = db.prepare(query).get(...params);\n    \n    const totalExecutions = result?.total_executions || 0;\n    const successfulExecutions = result?.successful_executions || 0;\n    const failedExecutions = result?.failed_executions || 0;\n    const successRate = totalExecutions > 0 ? (successfulExecutions / totalExecutions) * 100 : 0;\n    const averageCostPerSuccess = successfulExecutions > 0 ? summary.totalCost / successfulExecutions : 0;\n    const costEfficiency = summary.totalCost > 0 ? (successfulExecutions / summary.totalCost) * 100 : 0;\n\n    const recommendations = await this.generateOptimizationRecommendations(startDate, endDate);\n\n    return {\n      totalCost: summary.totalCost,\n      totalExecutions,\n      successfulExecutions,\n      failedExecutions,\n      averageCostPerSuccess,\n      successRate,\n      costEfficiency,\n      recommendations\n    };\n  }\n\n  /**\n   * Get all budget alerts\n   */\n  public async getBudgetAlerts(): Promise<BudgetAlert[]> {\n    return db.prepare(`\n      SELECT * FROM budget_alerts ORDER BY created_at DESC\n    `).all();\n  }\n\n  /**\n   * Update optimization settings\n   */\n  public async updateOptimizationSettings(settings: Partial<CostOptimizationSettings>): Promise<void> {\n    this.optimizationSettings = { ...this.optimizationSettings, ...settings };\n    \n    db.prepare(`\n      INSERT OR REPLACE INTO cost_optimization_settings \n      (id, enable_auto_optimization, cost_threshold, token_threshold, model_preferences, \n       prompt_optimization, batching_enabled, caching_enabled, updated_at)\n      VALUES (1, ?, ?, ?, ?, ?, ?, ?, CURRENT_TIMESTAMP)\n    `).run(\n      settings.enableAutoOptimization ?? this.optimizationSettings.enableAutoOptimization,\n      settings.costThreshold ?? this.optimizationSettings.costThreshold,\n      settings.tokenThreshold ?? this.optimizationSettings.tokenThreshold,\n      JSON.stringify(settings.modelPreferences ?? this.optimizationSettings.modelPreferences),\n      settings.promptOptimization ?? this.optimizationSettings.promptOptimization,\n      settings.batchingEnabled ?? this.optimizationSettings.batchingEnabled,\n      settings.cachingEnabled ?? this.optimizationSettings.cachingEnabled\n    );\n  }\n\n  /**\n   * Get optimization settings\n   */\n  public getOptimizationSettings(): CostOptimizationSettings {\n    return this.optimizationSettings;\n  }\n}\n\nexport const costTracker = new CostTracker();"],"names":["CostTracker","costTracker","initializeDatabase","console","log","db","exec","initializePricing","defaultPricing","model","prompt_token_cost","completion_token_cost","context_window","last_updated","Date","toISOString","insertPricing","prepare","pricing","run","modelPricing","set","trackUsage","executionId","promptTokens","completionTokens","executionTimeMs","testCaseId","promptCardId","totalTokens","cost","calculateCost","insertCost","result","costData","id","lastInsertRowid","execution_id","prompt_tokens","completion_tokens","total_tokens","cost_usd","execution_time_ms","test_case_id","prompt_card_id","created_at","checkBudgetAlerts","get","warn","promptCost","completionCost","getCostSummary","startDate","endDate","query","params","push","results","all","costByModel","tokensByModel","executionsByModel","totalCost","totalPromptTokens","totalCompletionTokens","totalExecutions","total_cost","tokens","executions","total_executions","total_prompt_tokens","total_completion_tokens","averageCostPerExecution","averageTokensPerExecution","generateOptimizationRecommendations","recommendations","summary","sortedModels","Object","entries","sort","a","b","length","mostExpensiveModel","mostExpensiveCost","cheapestModel","cheapestCost","type","title","description","toFixed","estimatedSavings","estimatedSavingsPercentage","priority","actionRequired","metadata","currentModel","suggestedModel","currentCost","suggestedCost","averageTokens","avgCostPerExecution","createBudgetAlert","name","threshold","insertAlert","current_amount","percentage_used","status","alerts","triggeredAlerts","alert","currentAmount","getCurrentSpendingForAlert","percentageUsed","newStatus","now","getFullYear","getMonth","getDate","weekStart","setDate","getDay","generateCostPrediction","period","days","historicalData","predictedCost","confidence","basedOnDays","trend","factors","costs","map","d","daily_cost","avgDailyCost","reduce","recentCosts","slice","earlierCosts","recentAvg","earlierAvg","multiplier","Math","min","getUsageAnalytics","trendData","dayCount","max","ceil","getTime","peakDay","day","date","modelUsage","percentage","start","end","averageCostPerDay","averageTokensPerDay","averageExecutionsPerDay","peakUsageDay","peakUsageCost","costTrend","calculateROI","successfulExecutions","successful_executions","failedExecutions","failed_executions","successRate","averageCostPerSuccess","costEfficiency","getBudgetAlerts","updateOptimizationSettings","settings","optimizationSettings","enableAutoOptimization","costThreshold","tokenThreshold","JSON","stringify","modelPreferences","promptOptimization","batchingEnabled","cachingEnabled","getOptimizationSettings","Map"],"mappings":"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"}