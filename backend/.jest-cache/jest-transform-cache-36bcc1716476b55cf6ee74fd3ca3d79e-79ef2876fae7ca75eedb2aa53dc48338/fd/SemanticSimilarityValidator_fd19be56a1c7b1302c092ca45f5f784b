bbbd4a1003284fd81cec2bdc562dbdae
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SemanticSimilarityValidator", {
    enumerable: true,
    get: function() {
        return SemanticSimilarityValidator;
    }
});
const _tfjsnode = /*#__PURE__*/ _interop_require_wildcard(require("@tensorflow/tfjs-node"));
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class SemanticSimilarityValidator {
    /**
   * Initialize the semantic similarity validator
   */ async initialize() {
        try {
            console.log('Initializing SemanticSimilarityValidator...');
            // For now, we'll use a simple fallback implementation
            // In a production environment, you'd load actual transformer models
            this.initialized = true;
            console.log('✅ SemanticSimilarityValidator initialized with fallback implementation');
        } catch (error) {
            console.error('❌ Failed to initialize SemanticSimilarityValidator:', error);
            throw error;
        }
    }
    /**
   * Compute semantic similarity between two texts
   */ async computeSimilarity(text1, text2) {
        if (!this.initialized) {
            throw new Error('SemanticSimilarityValidator not initialized');
        }
        try {
            // Fallback implementation using simple text similarity
            // In production, this would use sentence embeddings
            const similarity = await this.computeTextSimilarity(text1, text2);
            return similarity;
        } catch (error) {
            console.error('Error computing similarity:', error);
            throw error;
        }
    }
    /**
   * Analyze sentiment of text
   */ async analyzeSentiment(text) {
        if (!this.initialized) {
            throw new Error('SemanticSimilarityValidator not initialized');
        }
        try {
            // Simple sentiment analysis based on keywords
            const sentiment = this.analyzeSentimentSimple(text);
            return sentiment;
        } catch (error) {
            console.error('Error analyzing sentiment:', error);
            throw error;
        }
    }
    /**
   * Detect language of text
   */ async detectLanguage(text) {
        if (!this.initialized) {
            throw new Error('SemanticSimilarityValidator not initialized');
        }
        try {
            // Simple language detection based on common words
            const language = this.detectLanguageSimple(text);
            return language;
        } catch (error) {
            console.error('Error detecting language:', error);
            throw error;
        }
    }
    /**
   * Detect toxicity in text
   */ async detectToxicity(text) {
        if (!this.initialized) {
            throw new Error('SemanticSimilarityValidator not initialized');
        }
        try {
            // Simple toxicity detection based on keyword matching
            const toxicity = this.detectToxicitySimple(text);
            return toxicity;
        } catch (error) {
            console.error('Error detecting toxicity:', error);
            throw error;
        }
    }
    /**
   * Get the model name being used
   */ getModelName() {
        return this.modelName;
    }
    /**
   * Fallback text similarity using cosine similarity of TF-IDF vectors
   */ async computeTextSimilarity(text1, text2) {
        // Normalize and tokenize texts
        const tokens1 = this.tokenize(text1.toLowerCase());
        const tokens2 = this.tokenize(text2.toLowerCase());
        // Create vocabulary
        const vocabulary = Array.from(new Set([
            ...tokens1,
            ...tokens2
        ]));
        // Create TF-IDF vectors
        const vector1 = this.createTFIDFVector(tokens1, vocabulary);
        const vector2 = this.createTFIDFVector(tokens2, vocabulary);
        // Compute cosine similarity
        const similarity = this.cosineSimilarity(vector1, vector2);
        return Math.max(0, Math.min(1, similarity));
    }
    /**
   * Simple tokenization
   */ tokenize(text) {
        return text.replace(/[^\w\s]/g, ' ').split(/\s+/).filter((token)=>token.length > 0);
    }
    /**
   * Create TF-IDF vector for tokens
   */ createTFIDFVector(tokens, vocabulary) {
        const vector = new Array(vocabulary.length).fill(0);
        const tokenCounts = new Map();
        // Count token frequencies
        tokens.forEach((token)=>{
            tokenCounts.set(token, (tokenCounts.get(token) || 0) + 1);
        });
        // Calculate TF-IDF
        vocabulary.forEach((word, index)=>{
            const tf = (tokenCounts.get(word) || 0) / tokens.length;
            // Simplified IDF (in production, use proper corpus-based IDF)
            const idf = Math.log(vocabulary.length / (1 + (tokenCounts.has(word) ? 1 : 0)));
            vector[index] = tf * idf;
        });
        return vector;
    }
    /**
   * Compute cosine similarity between two vectors
   */ cosineSimilarity(vector1, vector2) {
        if (vector1.length !== vector2.length) {
            throw new Error('Vectors must have the same length');
        }
        let dotProduct = 0;
        let norm1 = 0;
        let norm2 = 0;
        for(let i = 0; i < vector1.length; i++){
            dotProduct += vector1[i] * vector2[i];
            norm1 += vector1[i] * vector1[i];
            norm2 += vector2[i] * vector2[i];
        }
        const magnitude1 = Math.sqrt(norm1);
        const magnitude2 = Math.sqrt(norm2);
        if (magnitude1 === 0 || magnitude2 === 0) {
            return 0;
        }
        return dotProduct / (magnitude1 * magnitude2);
    }
    /**
   * Simple sentiment analysis using keyword matching
   */ analyzeSentimentSimple(text) {
        const positiveWords = [
            'good',
            'great',
            'excellent',
            'amazing',
            'wonderful',
            'fantastic',
            'awesome',
            'love',
            'like',
            'enjoy',
            'happy',
            'pleased',
            'satisfied',
            'perfect',
            'best',
            'better',
            'brilliant',
            'outstanding',
            'superb',
            'magnificent',
            'yes',
            'correct',
            'right',
            'accurate',
            'successful',
            'win',
            'victory'
        ];
        const negativeWords = [
            'bad',
            'terrible',
            'awful',
            'horrible',
            'disgusting',
            'hate',
            'dislike',
            'angry',
            'sad',
            'disappointed',
            'frustrated',
            'annoyed',
            'upset',
            'wrong',
            'incorrect',
            'error',
            'fail',
            'failure',
            'loss',
            'defeat',
            'no',
            'not',
            'never',
            'nothing',
            'none',
            'worst',
            'worse'
        ];
        const words = this.tokenize(text.toLowerCase());
        let positiveScore = 0;
        let negativeScore = 0;
        words.forEach((word)=>{
            if (positiveWords.includes(word)) {
                positiveScore++;
            } else if (negativeWords.includes(word)) {
                negativeScore++;
            }
        });
        const totalWords = words.length;
        const netScore = (positiveScore - negativeScore) / Math.max(1, totalWords);
        let label;
        let score;
        if (netScore > 0.1) {
            label = 'positive';
            score = Math.min(1, netScore * 5);
        } else if (netScore < -0.1) {
            label = 'negative';
            score = Math.min(1, Math.abs(netScore) * 5);
        } else {
            label = 'neutral';
            score = 0.5;
        }
        return {
            label,
            score,
            details: {
                positive: positiveScore,
                negative: negativeScore,
                neutral: totalWords - positiveScore - negativeScore,
                netScore
            }
        };
    }
    /**
   * Simple language detection using common words
   */ detectLanguageSimple(text) {
        const languageKeywords = {
            'en': [
                'the',
                'and',
                'is',
                'in',
                'to',
                'of',
                'a',
                'that',
                'it',
                'with',
                'for',
                'as',
                'was',
                'on',
                'are'
            ],
            'es': [
                'el',
                'la',
                'de',
                'que',
                'y',
                'es',
                'en',
                'un',
                'se',
                'no',
                'te',
                'lo',
                'le',
                'da',
                'su'
            ],
            'fr': [
                'le',
                'de',
                'et',
                'à',
                'un',
                'il',
                'être',
                'et',
                'en',
                'avoir',
                'que',
                'pour',
                'dans',
                'ce',
                'son'
            ],
            'de': [
                'der',
                'die',
                'und',
                'in',
                'den',
                'von',
                'zu',
                'das',
                'mit',
                'sich',
                'des',
                'auf',
                'für',
                'ist',
                'im'
            ],
            'it': [
                'il',
                'di',
                'che',
                'e',
                'la',
                'per',
                'un',
                'in',
                'con',
                'del',
                'da',
                'a',
                'al',
                'le',
                'si'
            ],
            'pt': [
                'o',
                'de',
                'que',
                'e',
                'do',
                'da',
                'em',
                'um',
                'para',
                'é',
                'com',
                'não',
                'uma',
                'os',
                'no'
            ],
            'ru': [
                'в',
                'и',
                'не',
                'на',
                'я',
                'быть',
                'то',
                'он',
                'оно',
                'как',
                'с',
                'а',
                'но',
                'за',
                'по'
            ],
            'zh': [
                '的',
                '是',
                '在',
                '了',
                '和',
                '有',
                '一',
                '我',
                '不',
                '你',
                '他',
                '这',
                '个',
                '人',
                '来'
            ]
        };
        const words = this.tokenize(text.toLowerCase());
        const scores = {};
        // Calculate scores for each language
        Object.entries(languageKeywords).forEach(([lang, keywords])=>{
            let score = 0;
            words.forEach((word)=>{
                if (keywords.includes(word)) {
                    score++;
                }
            });
            scores[lang] = score / Math.max(1, words.length);
        });
        // Find the language with highest score
        const sortedLanguages = Object.entries(scores).sort(([, a], [, b])=>b - a);
        const [topLanguage, topScore] = sortedLanguages[0];
        return {
            language: topLanguage,
            confidence: Math.min(1, topScore * 10),
            alternatives: sortedLanguages.slice(1, 4).map(([lang, score])=>({
                    language: lang,
                    confidence: Math.min(1, score * 10)
                }))
        };
    }
    /**
   * Simple toxicity detection using keyword matching
   */ detectToxicitySimple(text) {
        const toxicKeywords = {
            profanity: [
                'damn',
                'hell',
                'crap',
                'stupid',
                'idiot',
                'moron',
                'dumb'
            ],
            harassment: [
                'hate',
                'kill',
                'die',
                'destroy',
                'hurt',
                'harm',
                'attack'
            ],
            threats: [
                'threat',
                'threaten',
                'violence',
                'violent',
                'dangerous',
                'weapon'
            ],
            discrimination: [
                'racist',
                'sexist',
                'bigot',
                'discrimination',
                'prejudice'
            ],
            spam: [
                'spam',
                'advertisement',
                'promotion',
                'click',
                'buy',
                'sale',
                'offer'
            ]
        };
        const words = this.tokenize(text.toLowerCase());
        const categoryScores = {};
        // Calculate scores for each toxicity category
        Object.entries(toxicKeywords).forEach(([category, keywords])=>{
            let score = 0;
            words.forEach((word)=>{
                if (keywords.includes(word)) {
                    score++;
                }
            });
            categoryScores[category] = score / Math.max(1, words.length);
        });
        // Calculate overall toxicity score
        const overallScore = Object.values(categoryScores).reduce((sum, score)=>sum + score, 0);
        return {
            score: Math.min(1, overallScore * 2),
            categories: categoryScores,
            threshold: 0.3
        };
    }
    /**
   * Clean up resources
   */ async cleanup() {
        if (this.model) {
            this.model.dispose();
            this.model = null;
        }
        this.initialized = false;
    }
    constructor(){
        _define_property(this, "model", null);
        _define_property(this, "modelName", 'universal-sentence-encoder');
        _define_property(this, "initialized", false);
        // Initialize TensorFlow.js backend
        _tfjsnode.setBackend('cpu');
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi93b3Jrc3BhY2VzL3Byb21wdC1jYXJkLXN5c3RlbS9iYWNrZW5kL3NyYy9zZXJ2aWNlcy9hc3NlcnRpb25zL1NlbWFudGljU2ltaWxhcml0eVZhbGlkYXRvci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB0ZiBmcm9tICdAdGVuc29yZmxvdy90ZmpzLW5vZGUnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNpbWlsYXJpdHlSZXN1bHQge1xuICBzaW1pbGFyaXR5OiBudW1iZXI7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgbWV0aG9kOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VudGltZW50UmVzdWx0IHtcbiAgbGFiZWw6ICdwb3NpdGl2ZScgfCAnbmVnYXRpdmUnIHwgJ25ldXRyYWwnO1xuICBzY29yZTogbnVtYmVyO1xuICBkZXRhaWxzPzogUmVjb3JkPHN0cmluZywgbnVtYmVyPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMYW5ndWFnZVJlc3VsdCB7XG4gIGxhbmd1YWdlOiBzdHJpbmc7XG4gIGNvbmZpZGVuY2U6IG51bWJlcjtcbiAgYWx0ZXJuYXRpdmVzPzogQXJyYXk8eyBsYW5ndWFnZTogc3RyaW5nOyBjb25maWRlbmNlOiBudW1iZXIgfT47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG94aWNpdHlSZXN1bHQge1xuICBzY29yZTogbnVtYmVyO1xuICBjYXRlZ29yaWVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuICB0aHJlc2hvbGQ6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFNlbWFudGljU2ltaWxhcml0eVZhbGlkYXRvciB7XG4gIHByaXZhdGUgbW9kZWw6IGFueSA9IG51bGw7XG4gIHByaXZhdGUgbW9kZWxOYW1lOiBzdHJpbmcgPSAndW5pdmVyc2FsLXNlbnRlbmNlLWVuY29kZXInO1xuICBwcml2YXRlIGluaXRpYWxpemVkOiBib29sZWFuID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBUZW5zb3JGbG93LmpzIGJhY2tlbmRcbiAgICB0Zi5zZXRCYWNrZW5kKCdjcHUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIHRoZSBzZW1hbnRpYyBzaW1pbGFyaXR5IHZhbGlkYXRvclxuICAgKi9cbiAgYXN5bmMgaW5pdGlhbGl6ZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ0luaXRpYWxpemluZyBTZW1hbnRpY1NpbWlsYXJpdHlWYWxpZGF0b3IuLi4nKTtcbiAgICAgIFxuICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdXNlIGEgc2ltcGxlIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBJbiBhIHByb2R1Y3Rpb24gZW52aXJvbm1lbnQsIHlvdSdkIGxvYWQgYWN0dWFsIHRyYW5zZm9ybWVyIG1vZGVsc1xuICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKCfinIUgU2VtYW50aWNTaW1pbGFyaXR5VmFsaWRhdG9yIGluaXRpYWxpemVkIHdpdGggZmFsbGJhY2sgaW1wbGVtZW50YXRpb24nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZhaWxlZCB0byBpbml0aWFsaXplIFNlbWFudGljU2ltaWxhcml0eVZhbGlkYXRvcjonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZSBzZW1hbnRpYyBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIHRleHRzXG4gICAqL1xuICBhc3luYyBjb21wdXRlU2ltaWxhcml0eSh0ZXh0MTogc3RyaW5nLCB0ZXh0Mjogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2VtYW50aWNTaW1pbGFyaXR5VmFsaWRhdG9yIG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBGYWxsYmFjayBpbXBsZW1lbnRhdGlvbiB1c2luZyBzaW1wbGUgdGV4dCBzaW1pbGFyaXR5XG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIHVzZSBzZW50ZW5jZSBlbWJlZGRpbmdzXG4gICAgICBjb25zdCBzaW1pbGFyaXR5ID0gYXdhaXQgdGhpcy5jb21wdXRlVGV4dFNpbWlsYXJpdHkodGV4dDEsIHRleHQyKTtcbiAgICAgIHJldHVybiBzaW1pbGFyaXR5O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb21wdXRpbmcgc2ltaWxhcml0eTonLCBlcnJvcik7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQW5hbHl6ZSBzZW50aW1lbnQgb2YgdGV4dFxuICAgKi9cbiAgYXN5bmMgYW5hbHl6ZVNlbnRpbWVudCh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPFNlbnRpbWVudFJlc3VsdD4ge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZW1hbnRpY1NpbWlsYXJpdHlWYWxpZGF0b3Igbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNpbXBsZSBzZW50aW1lbnQgYW5hbHlzaXMgYmFzZWQgb24ga2V5d29yZHNcbiAgICAgIGNvbnN0IHNlbnRpbWVudCA9IHRoaXMuYW5hbHl6ZVNlbnRpbWVudFNpbXBsZSh0ZXh0KTtcbiAgICAgIHJldHVybiBzZW50aW1lbnQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFuYWx5emluZyBzZW50aW1lbnQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVjdCBsYW5ndWFnZSBvZiB0ZXh0XG4gICAqL1xuICBhc3luYyBkZXRlY3RMYW5ndWFnZSh0ZXh0OiBzdHJpbmcpOiBQcm9taXNlPExhbmd1YWdlUmVzdWx0PiB7XG4gICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlbWFudGljU2ltaWxhcml0eVZhbGlkYXRvciBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gU2ltcGxlIGxhbmd1YWdlIGRldGVjdGlvbiBiYXNlZCBvbiBjb21tb24gd29yZHNcbiAgICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5kZXRlY3RMYW5ndWFnZVNpbXBsZSh0ZXh0KTtcbiAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGV0ZWN0aW5nIGxhbmd1YWdlOicsIGVycm9yKTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgdG94aWNpdHkgaW4gdGV4dFxuICAgKi9cbiAgYXN5bmMgZGV0ZWN0VG94aWNpdHkodGV4dDogc3RyaW5nKTogUHJvbWlzZTxUb3hpY2l0eVJlc3VsdD4ge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZW1hbnRpY1NpbWlsYXJpdHlWYWxpZGF0b3Igbm90IGluaXRpYWxpemVkJyk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFNpbXBsZSB0b3hpY2l0eSBkZXRlY3Rpb24gYmFzZWQgb24ga2V5d29yZCBtYXRjaGluZ1xuICAgICAgY29uc3QgdG94aWNpdHkgPSB0aGlzLmRldGVjdFRveGljaXR5U2ltcGxlKHRleHQpO1xuICAgICAgcmV0dXJuIHRveGljaXR5O1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRlY3RpbmcgdG94aWNpdHk6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbW9kZWwgbmFtZSBiZWluZyB1c2VkXG4gICAqL1xuICBnZXRNb2RlbE5hbWUoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5tb2RlbE5hbWU7XG4gIH1cblxuICAvKipcbiAgICogRmFsbGJhY2sgdGV4dCBzaW1pbGFyaXR5IHVzaW5nIGNvc2luZSBzaW1pbGFyaXR5IG9mIFRGLUlERiB2ZWN0b3JzXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGNvbXB1dGVUZXh0U2ltaWxhcml0eSh0ZXh0MTogc3RyaW5nLCB0ZXh0Mjogc3RyaW5nKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICAvLyBOb3JtYWxpemUgYW5kIHRva2VuaXplIHRleHRzXG4gICAgY29uc3QgdG9rZW5zMSA9IHRoaXMudG9rZW5pemUodGV4dDEudG9Mb3dlckNhc2UoKSk7XG4gICAgY29uc3QgdG9rZW5zMiA9IHRoaXMudG9rZW5pemUodGV4dDIudG9Mb3dlckNhc2UoKSk7XG4gICAgXG4gICAgLy8gQ3JlYXRlIHZvY2FidWxhcnlcbiAgICBjb25zdCB2b2NhYnVsYXJ5ID0gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi50b2tlbnMxLCAuLi50b2tlbnMyXSkpO1xuICAgIFxuICAgIC8vIENyZWF0ZSBURi1JREYgdmVjdG9yc1xuICAgIGNvbnN0IHZlY3RvcjEgPSB0aGlzLmNyZWF0ZVRGSURGVmVjdG9yKHRva2VuczEsIHZvY2FidWxhcnkpO1xuICAgIGNvbnN0IHZlY3RvcjIgPSB0aGlzLmNyZWF0ZVRGSURGVmVjdG9yKHRva2VuczIsIHZvY2FidWxhcnkpO1xuICAgIFxuICAgIC8vIENvbXB1dGUgY29zaW5lIHNpbWlsYXJpdHlcbiAgICBjb25zdCBzaW1pbGFyaXR5ID0gdGhpcy5jb3NpbmVTaW1pbGFyaXR5KHZlY3RvcjEsIHZlY3RvcjIpO1xuICAgIFxuICAgIHJldHVybiBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBzaW1pbGFyaXR5KSk7XG4gIH1cblxuICAvKipcbiAgICogU2ltcGxlIHRva2VuaXphdGlvblxuICAgKi9cbiAgcHJpdmF0ZSB0b2tlbml6ZSh0ZXh0OiBzdHJpbmcpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIHRleHRcbiAgICAgIC5yZXBsYWNlKC9bXlxcd1xcc10vZywgJyAnKVxuICAgICAgLnNwbGl0KC9cXHMrLylcbiAgICAgIC5maWx0ZXIodG9rZW4gPT4gdG9rZW4ubGVuZ3RoID4gMCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIFRGLUlERiB2ZWN0b3IgZm9yIHRva2Vuc1xuICAgKi9cbiAgcHJpdmF0ZSBjcmVhdGVURklERlZlY3Rvcih0b2tlbnM6IHN0cmluZ1tdLCB2b2NhYnVsYXJ5OiBzdHJpbmdbXSk6IG51bWJlcltdIHtcbiAgICBjb25zdCB2ZWN0b3IgPSBuZXcgQXJyYXkodm9jYWJ1bGFyeS5sZW5ndGgpLmZpbGwoMCk7XG4gICAgY29uc3QgdG9rZW5Db3VudHMgPSBuZXcgTWFwPHN0cmluZywgbnVtYmVyPigpO1xuICAgIFxuICAgIC8vIENvdW50IHRva2VuIGZyZXF1ZW5jaWVzXG4gICAgdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgdG9rZW5Db3VudHMuc2V0KHRva2VuLCAodG9rZW5Db3VudHMuZ2V0KHRva2VuKSB8fCAwKSArIDEpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBURi1JREZcbiAgICB2b2NhYnVsYXJ5LmZvckVhY2goKHdvcmQsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB0ZiA9ICh0b2tlbkNvdW50cy5nZXQod29yZCkgfHwgMCkgLyB0b2tlbnMubGVuZ3RoO1xuICAgICAgLy8gU2ltcGxpZmllZCBJREYgKGluIHByb2R1Y3Rpb24sIHVzZSBwcm9wZXIgY29ycHVzLWJhc2VkIElERilcbiAgICAgIGNvbnN0IGlkZiA9IE1hdGgubG9nKHZvY2FidWxhcnkubGVuZ3RoIC8gKDEgKyAodG9rZW5Db3VudHMuaGFzKHdvcmQpID8gMSA6IDApKSk7XG4gICAgICB2ZWN0b3JbaW5kZXhdID0gdGYgKiBpZGY7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHZlY3RvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlIGNvc2luZSBzaW1pbGFyaXR5IGJldHdlZW4gdHdvIHZlY3RvcnNcbiAgICovXG4gIHByaXZhdGUgY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxOiBudW1iZXJbXSwgdmVjdG9yMjogbnVtYmVyW10pOiBudW1iZXIge1xuICAgIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuICAgIFxuICAgIGxldCBkb3RQcm9kdWN0ID0gMDtcbiAgICBsZXQgbm9ybTEgPSAwO1xuICAgIGxldCBub3JtMiA9IDA7XG4gICAgXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWN0b3IxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkb3RQcm9kdWN0ICs9IHZlY3RvcjFbaV0gKiB2ZWN0b3IyW2ldO1xuICAgICAgbm9ybTEgKz0gdmVjdG9yMVtpXSAqIHZlY3RvcjFbaV07XG4gICAgICBub3JtMiArPSB2ZWN0b3IyW2ldICogdmVjdG9yMltpXTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgbWFnbml0dWRlMSA9IE1hdGguc3FydChub3JtMSk7XG4gICAgY29uc3QgbWFnbml0dWRlMiA9IE1hdGguc3FydChub3JtMik7XG4gICAgXG4gICAgaWYgKG1hZ25pdHVkZTEgPT09IDAgfHwgbWFnbml0dWRlMiA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBkb3RQcm9kdWN0IC8gKG1hZ25pdHVkZTEgKiBtYWduaXR1ZGUyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1wbGUgc2VudGltZW50IGFuYWx5c2lzIHVzaW5nIGtleXdvcmQgbWF0Y2hpbmdcbiAgICovXG4gIHByaXZhdGUgYW5hbHl6ZVNlbnRpbWVudFNpbXBsZSh0ZXh0OiBzdHJpbmcpOiBTZW50aW1lbnRSZXN1bHQge1xuICAgIGNvbnN0IHBvc2l0aXZlV29yZHMgPSBbXG4gICAgICAnZ29vZCcsICdncmVhdCcsICdleGNlbGxlbnQnLCAnYW1hemluZycsICd3b25kZXJmdWwnLCAnZmFudGFzdGljJywgJ2F3ZXNvbWUnLFxuICAgICAgJ2xvdmUnLCAnbGlrZScsICdlbmpveScsICdoYXBweScsICdwbGVhc2VkJywgJ3NhdGlzZmllZCcsICdwZXJmZWN0JyxcbiAgICAgICdiZXN0JywgJ2JldHRlcicsICdicmlsbGlhbnQnLCAnb3V0c3RhbmRpbmcnLCAnc3VwZXJiJywgJ21hZ25pZmljZW50JyxcbiAgICAgICd5ZXMnLCAnY29ycmVjdCcsICdyaWdodCcsICdhY2N1cmF0ZScsICdzdWNjZXNzZnVsJywgJ3dpbicsICd2aWN0b3J5J1xuICAgIF07XG4gICAgXG4gICAgY29uc3QgbmVnYXRpdmVXb3JkcyA9IFtcbiAgICAgICdiYWQnLCAndGVycmlibGUnLCAnYXdmdWwnLCAnaG9ycmlibGUnLCAnZGlzZ3VzdGluZycsICdoYXRlJywgJ2Rpc2xpa2UnLFxuICAgICAgJ2FuZ3J5JywgJ3NhZCcsICdkaXNhcHBvaW50ZWQnLCAnZnJ1c3RyYXRlZCcsICdhbm5veWVkJywgJ3Vwc2V0JyxcbiAgICAgICd3cm9uZycsICdpbmNvcnJlY3QnLCAnZXJyb3InLCAnZmFpbCcsICdmYWlsdXJlJywgJ2xvc3MnLCAnZGVmZWF0JyxcbiAgICAgICdubycsICdub3QnLCAnbmV2ZXInLCAnbm90aGluZycsICdub25lJywgJ3dvcnN0JywgJ3dvcnNlJ1xuICAgIF07XG4gICAgXG4gICAgY29uc3Qgd29yZHMgPSB0aGlzLnRva2VuaXplKHRleHQudG9Mb3dlckNhc2UoKSk7XG4gICAgXG4gICAgbGV0IHBvc2l0aXZlU2NvcmUgPSAwO1xuICAgIGxldCBuZWdhdGl2ZVNjb3JlID0gMDtcbiAgICBcbiAgICB3b3Jkcy5mb3JFYWNoKHdvcmQgPT4ge1xuICAgICAgaWYgKHBvc2l0aXZlV29yZHMuaW5jbHVkZXMod29yZCkpIHtcbiAgICAgICAgcG9zaXRpdmVTY29yZSsrO1xuICAgICAgfSBlbHNlIGlmIChuZWdhdGl2ZVdvcmRzLmluY2x1ZGVzKHdvcmQpKSB7XG4gICAgICAgIG5lZ2F0aXZlU2NvcmUrKztcbiAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBjb25zdCB0b3RhbFdvcmRzID0gd29yZHMubGVuZ3RoO1xuICAgIGNvbnN0IG5ldFNjb3JlID0gKHBvc2l0aXZlU2NvcmUgLSBuZWdhdGl2ZVNjb3JlKSAvIE1hdGgubWF4KDEsIHRvdGFsV29yZHMpO1xuICAgIFxuICAgIGxldCBsYWJlbDogJ3Bvc2l0aXZlJyB8ICduZWdhdGl2ZScgfCAnbmV1dHJhbCc7XG4gICAgbGV0IHNjb3JlOiBudW1iZXI7XG4gICAgXG4gICAgaWYgKG5ldFNjb3JlID4gMC4xKSB7XG4gICAgICBsYWJlbCA9ICdwb3NpdGl2ZSc7XG4gICAgICBzY29yZSA9IE1hdGgubWluKDEsIG5ldFNjb3JlICogNSk7XG4gICAgfSBlbHNlIGlmIChuZXRTY29yZSA8IC0wLjEpIHtcbiAgICAgIGxhYmVsID0gJ25lZ2F0aXZlJztcbiAgICAgIHNjb3JlID0gTWF0aC5taW4oMSwgTWF0aC5hYnMobmV0U2NvcmUpICogNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhYmVsID0gJ25ldXRyYWwnO1xuICAgICAgc2NvcmUgPSAwLjU7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB7XG4gICAgICBsYWJlbCxcbiAgICAgIHNjb3JlLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICBwb3NpdGl2ZTogcG9zaXRpdmVTY29yZSxcbiAgICAgICAgbmVnYXRpdmU6IG5lZ2F0aXZlU2NvcmUsXG4gICAgICAgIG5ldXRyYWw6IHRvdGFsV29yZHMgLSBwb3NpdGl2ZVNjb3JlIC0gbmVnYXRpdmVTY29yZSxcbiAgICAgICAgbmV0U2NvcmVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbXBsZSBsYW5ndWFnZSBkZXRlY3Rpb24gdXNpbmcgY29tbW9uIHdvcmRzXG4gICAqL1xuICBwcml2YXRlIGRldGVjdExhbmd1YWdlU2ltcGxlKHRleHQ6IHN0cmluZyk6IExhbmd1YWdlUmVzdWx0IHtcbiAgICBjb25zdCBsYW5ndWFnZUtleXdvcmRzID0ge1xuICAgICAgJ2VuJzogWyd0aGUnLCAnYW5kJywgJ2lzJywgJ2luJywgJ3RvJywgJ29mJywgJ2EnLCAndGhhdCcsICdpdCcsICd3aXRoJywgJ2ZvcicsICdhcycsICd3YXMnLCAnb24nLCAnYXJlJ10sXG4gICAgICAnZXMnOiBbJ2VsJywgJ2xhJywgJ2RlJywgJ3F1ZScsICd5JywgJ2VzJywgJ2VuJywgJ3VuJywgJ3NlJywgJ25vJywgJ3RlJywgJ2xvJywgJ2xlJywgJ2RhJywgJ3N1J10sXG4gICAgICAnZnInOiBbJ2xlJywgJ2RlJywgJ2V0JywgJ8OgJywgJ3VuJywgJ2lsJywgJ8OqdHJlJywgJ2V0JywgJ2VuJywgJ2F2b2lyJywgJ3F1ZScsICdwb3VyJywgJ2RhbnMnLCAnY2UnLCAnc29uJ10sXG4gICAgICAnZGUnOiBbJ2RlcicsICdkaWUnLCAndW5kJywgJ2luJywgJ2RlbicsICd2b24nLCAnenUnLCAnZGFzJywgJ21pdCcsICdzaWNoJywgJ2RlcycsICdhdWYnLCAnZsO8cicsICdpc3QnLCAnaW0nXSxcbiAgICAgICdpdCc6IFsnaWwnLCAnZGknLCAnY2hlJywgJ2UnLCAnbGEnLCAncGVyJywgJ3VuJywgJ2luJywgJ2NvbicsICdkZWwnLCAnZGEnLCAnYScsICdhbCcsICdsZScsICdzaSddLFxuICAgICAgJ3B0JzogWydvJywgJ2RlJywgJ3F1ZScsICdlJywgJ2RvJywgJ2RhJywgJ2VtJywgJ3VtJywgJ3BhcmEnLCAnw6knLCAnY29tJywgJ27Do28nLCAndW1hJywgJ29zJywgJ25vJ10sXG4gICAgICAncnUnOiBbJ9CyJywgJ9C4JywgJ9C90LUnLCAn0L3QsCcsICfRjycsICfQsdGL0YLRjCcsICfRgtC+JywgJ9C+0L0nLCAn0L7QvdC+JywgJ9C60LDQuicsICfRgScsICfQsCcsICfQvdC+JywgJ9C30LAnLCAn0L/QviddLFxuICAgICAgJ3poJzogWyfnmoQnLCAn5pivJywgJ+WcqCcsICfkuoYnLCAn5ZKMJywgJ+aciScsICfkuIAnLCAn5oiRJywgJ+S4jScsICfkvaAnLCAn5LuWJywgJ+i/mScsICfkuKonLCAn5Lq6JywgJ+adpSddXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCB3b3JkcyA9IHRoaXMudG9rZW5pemUodGV4dC50b0xvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCBzY29yZXM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBcbiAgICAvLyBDYWxjdWxhdGUgc2NvcmVzIGZvciBlYWNoIGxhbmd1YWdlXG4gICAgT2JqZWN0LmVudHJpZXMobGFuZ3VhZ2VLZXl3b3JkcykuZm9yRWFjaCgoW2xhbmcsIGtleXdvcmRzXSkgPT4ge1xuICAgICAgbGV0IHNjb3JlID0gMDtcbiAgICAgIHdvcmRzLmZvckVhY2god29yZCA9PiB7XG4gICAgICAgIGlmIChrZXl3b3Jkcy5pbmNsdWRlcyh3b3JkKSkge1xuICAgICAgICAgIHNjb3JlKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2NvcmVzW2xhbmddID0gc2NvcmUgLyBNYXRoLm1heCgxLCB3b3Jkcy5sZW5ndGgpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIEZpbmQgdGhlIGxhbmd1YWdlIHdpdGggaGlnaGVzdCBzY29yZVxuICAgIGNvbnN0IHNvcnRlZExhbmd1YWdlcyA9IE9iamVjdC5lbnRyaWVzKHNjb3JlcylcbiAgICAgIC5zb3J0KChbLCBhXSwgWywgYl0pID0+IGIgLSBhKTtcbiAgICBcbiAgICBjb25zdCBbdG9wTGFuZ3VhZ2UsIHRvcFNjb3JlXSA9IHNvcnRlZExhbmd1YWdlc1swXTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgbGFuZ3VhZ2U6IHRvcExhbmd1YWdlLFxuICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oMSwgdG9wU2NvcmUgKiAxMCksXG4gICAgICBhbHRlcm5hdGl2ZXM6IHNvcnRlZExhbmd1YWdlcy5zbGljZSgxLCA0KS5tYXAoKFtsYW5nLCBzY29yZV0pID0+ICh7XG4gICAgICAgIGxhbmd1YWdlOiBsYW5nLFxuICAgICAgICBjb25maWRlbmNlOiBNYXRoLm1pbigxLCBzY29yZSAqIDEwKVxuICAgICAgfSkpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTaW1wbGUgdG94aWNpdHkgZGV0ZWN0aW9uIHVzaW5nIGtleXdvcmQgbWF0Y2hpbmdcbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0VG94aWNpdHlTaW1wbGUodGV4dDogc3RyaW5nKTogVG94aWNpdHlSZXN1bHQge1xuICAgIGNvbnN0IHRveGljS2V5d29yZHMgPSB7XG4gICAgICBwcm9mYW5pdHk6IFsnZGFtbicsICdoZWxsJywgJ2NyYXAnLCAnc3R1cGlkJywgJ2lkaW90JywgJ21vcm9uJywgJ2R1bWInXSxcbiAgICAgIGhhcmFzc21lbnQ6IFsnaGF0ZScsICdraWxsJywgJ2RpZScsICdkZXN0cm95JywgJ2h1cnQnLCAnaGFybScsICdhdHRhY2snXSxcbiAgICAgIHRocmVhdHM6IFsndGhyZWF0JywgJ3RocmVhdGVuJywgJ3Zpb2xlbmNlJywgJ3Zpb2xlbnQnLCAnZGFuZ2Vyb3VzJywgJ3dlYXBvbiddLFxuICAgICAgZGlzY3JpbWluYXRpb246IFsncmFjaXN0JywgJ3NleGlzdCcsICdiaWdvdCcsICdkaXNjcmltaW5hdGlvbicsICdwcmVqdWRpY2UnXSxcbiAgICAgIHNwYW06IFsnc3BhbScsICdhZHZlcnRpc2VtZW50JywgJ3Byb21vdGlvbicsICdjbGljaycsICdidXknLCAnc2FsZScsICdvZmZlciddXG4gICAgfTtcbiAgICBcbiAgICBjb25zdCB3b3JkcyA9IHRoaXMudG9rZW5pemUodGV4dC50b0xvd2VyQ2FzZSgpKTtcbiAgICBjb25zdCBjYXRlZ29yeVNjb3JlczogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBzY29yZXMgZm9yIGVhY2ggdG94aWNpdHkgY2F0ZWdvcnlcbiAgICBPYmplY3QuZW50cmllcyh0b3hpY0tleXdvcmRzKS5mb3JFYWNoKChbY2F0ZWdvcnksIGtleXdvcmRzXSkgPT4ge1xuICAgICAgbGV0IHNjb3JlID0gMDtcbiAgICAgIHdvcmRzLmZvckVhY2god29yZCA9PiB7XG4gICAgICAgIGlmIChrZXl3b3Jkcy5pbmNsdWRlcyh3b3JkKSkge1xuICAgICAgICAgIHNjb3JlKys7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY2F0ZWdvcnlTY29yZXNbY2F0ZWdvcnldID0gc2NvcmUgLyBNYXRoLm1heCgxLCB3b3Jkcy5sZW5ndGgpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vIENhbGN1bGF0ZSBvdmVyYWxsIHRveGljaXR5IHNjb3JlXG4gICAgY29uc3Qgb3ZlcmFsbFNjb3JlID0gT2JqZWN0LnZhbHVlcyhjYXRlZ29yeVNjb3JlcykucmVkdWNlKChzdW0sIHNjb3JlKSA9PiBzdW0gKyBzY29yZSwgMCk7XG4gICAgXG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3JlOiBNYXRoLm1pbigxLCBvdmVyYWxsU2NvcmUgKiAyKSxcbiAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3J5U2NvcmVzLFxuICAgICAgdGhyZXNob2xkOiAwLjNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFuIHVwIHJlc291cmNlc1xuICAgKi9cbiAgYXN5bmMgY2xlYW51cCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgdGhpcy5tb2RlbC5kaXNwb3NlKCk7XG4gICAgICB0aGlzLm1vZGVsID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xuICB9XG59Il0sIm5hbWVzIjpbIlNlbWFudGljU2ltaWxhcml0eVZhbGlkYXRvciIsImluaXRpYWxpemUiLCJjb25zb2xlIiwibG9nIiwiaW5pdGlhbGl6ZWQiLCJlcnJvciIsImNvbXB1dGVTaW1pbGFyaXR5IiwidGV4dDEiLCJ0ZXh0MiIsIkVycm9yIiwic2ltaWxhcml0eSIsImNvbXB1dGVUZXh0U2ltaWxhcml0eSIsImFuYWx5emVTZW50aW1lbnQiLCJ0ZXh0Iiwic2VudGltZW50IiwiYW5hbHl6ZVNlbnRpbWVudFNpbXBsZSIsImRldGVjdExhbmd1YWdlIiwibGFuZ3VhZ2UiLCJkZXRlY3RMYW5ndWFnZVNpbXBsZSIsImRldGVjdFRveGljaXR5IiwidG94aWNpdHkiLCJkZXRlY3RUb3hpY2l0eVNpbXBsZSIsImdldE1vZGVsTmFtZSIsIm1vZGVsTmFtZSIsInRva2VuczEiLCJ0b2tlbml6ZSIsInRvTG93ZXJDYXNlIiwidG9rZW5zMiIsInZvY2FidWxhcnkiLCJBcnJheSIsImZyb20iLCJTZXQiLCJ2ZWN0b3IxIiwiY3JlYXRlVEZJREZWZWN0b3IiLCJ2ZWN0b3IyIiwiY29zaW5lU2ltaWxhcml0eSIsIk1hdGgiLCJtYXgiLCJtaW4iLCJyZXBsYWNlIiwic3BsaXQiLCJmaWx0ZXIiLCJ0b2tlbiIsImxlbmd0aCIsInRva2VucyIsInZlY3RvciIsImZpbGwiLCJ0b2tlbkNvdW50cyIsIk1hcCIsImZvckVhY2giLCJzZXQiLCJnZXQiLCJ3b3JkIiwiaW5kZXgiLCJ0ZiIsImlkZiIsImhhcyIsImRvdFByb2R1Y3QiLCJub3JtMSIsIm5vcm0yIiwiaSIsIm1hZ25pdHVkZTEiLCJzcXJ0IiwibWFnbml0dWRlMiIsInBvc2l0aXZlV29yZHMiLCJuZWdhdGl2ZVdvcmRzIiwid29yZHMiLCJwb3NpdGl2ZVNjb3JlIiwibmVnYXRpdmVTY29yZSIsImluY2x1ZGVzIiwidG90YWxXb3JkcyIsIm5ldFNjb3JlIiwibGFiZWwiLCJzY29yZSIsImFicyIsImRldGFpbHMiLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwibmV1dHJhbCIsImxhbmd1YWdlS2V5d29yZHMiLCJzY29yZXMiLCJPYmplY3QiLCJlbnRyaWVzIiwibGFuZyIsImtleXdvcmRzIiwic29ydGVkTGFuZ3VhZ2VzIiwic29ydCIsImEiLCJiIiwidG9wTGFuZ3VhZ2UiLCJ0b3BTY29yZSIsImNvbmZpZGVuY2UiLCJhbHRlcm5hdGl2ZXMiLCJzbGljZSIsIm1hcCIsInRveGljS2V5d29yZHMiLCJwcm9mYW5pdHkiLCJoYXJhc3NtZW50IiwidGhyZWF0cyIsImRpc2NyaW1pbmF0aW9uIiwic3BhbSIsImNhdGVnb3J5U2NvcmVzIiwiY2F0ZWdvcnkiLCJvdmVyYWxsU2NvcmUiLCJ2YWx1ZXMiLCJyZWR1Y2UiLCJzdW0iLCJjYXRlZ29yaWVzIiwidGhyZXNob2xkIiwiY2xlYW51cCIsIm1vZGVsIiwiZGlzcG9zZSIsInNldEJhY2tlbmQiXSwibWFwcGluZ3MiOiI7Ozs7K0JBMEJhQTs7O2VBQUFBOzs7a0VBMUJPOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMEJiLE1BQU1BO0lBVVg7O0dBRUMsR0FDRCxNQUFNQyxhQUE0QjtRQUNoQyxJQUFJO1lBQ0ZDLFFBQVFDLEdBQUcsQ0FBQztZQUVaLHNEQUFzRDtZQUN0RCxvRUFBb0U7WUFDcEUsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFFbkJGLFFBQVFDLEdBQUcsQ0FBQztRQUNkLEVBQUUsT0FBT0UsT0FBTztZQUNkSCxRQUFRRyxLQUFLLENBQUMsdURBQXVEQTtZQUNyRSxNQUFNQTtRQUNSO0lBQ0Y7SUFFQTs7R0FFQyxHQUNELE1BQU1DLGtCQUFrQkMsS0FBYSxFQUFFQyxLQUFhLEVBQW1CO1FBQ3JFLElBQUksQ0FBQyxJQUFJLENBQUNKLFdBQVcsRUFBRTtZQUNyQixNQUFNLElBQUlLLE1BQU07UUFDbEI7UUFFQSxJQUFJO1lBQ0YsdURBQXVEO1lBQ3ZELG9EQUFvRDtZQUNwRCxNQUFNQyxhQUFhLE1BQU0sSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0osT0FBT0M7WUFDM0QsT0FBT0U7UUFDVCxFQUFFLE9BQU9MLE9BQU87WUFDZEgsUUFBUUcsS0FBSyxDQUFDLCtCQUErQkE7WUFD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