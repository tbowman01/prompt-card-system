{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/tests/integration/websocket-integration.test.ts"],"sourcesContent":["import request from 'supertest';\nimport assert from 'assert';\nimport { io as Client, Socket } from 'socket.io-client';\nimport app from '../../server';\nimport { ProgressService } from '../../services/websocket/ProgressService';\nimport http from 'http';\n\ndescribe('WebSocket Integration Tests', () => {\n  let server: http.Server;\n  let clientSocket: Socket;\n  let progressService: ProgressService;\n  const testCardId = 'test-websocket-card-123';\n  const testSessionId = 'test-websocket-session-456';\n\n  beforeEach(async () => {\n    // Start server\n    server = http.createServer(app);\n    await new Promise<void>((resolve) => {\n      server.listen(0, () => {\n        resolve();\n      });\n    });\n\n    const port = (server.address() as any).port;\n    \n    // Create client socket\n    clientSocket = Client(`http://localhost:${port}`, {\n      autoConnect: false,\n      transports: ['websocket']\n    });\n\n    // Create mock Socket.IO server\n    const { Server } = require('socket.io');\n    const io = new Server(server);\n    progressService = new ProgressService(io);\n    \n    // Connect client\n    return new Promise<void>((resolve) => {\n      clientSocket.on('connect', () => {\n        resolve();\n      });\n      clientSocket.connect();\n    });\n  });\n\n  afterEach(async () => {\n    if (clientSocket) {\n      clientSocket.disconnect();\n    }\n    if (server) {\n      await new Promise<void>((resolve) => {\n        server.close(() => resolve());\n      });\n    }\n  });\n\n  describe('Real-time Progress Updates', () => {\n    it('should receive test execution progress updates', async () => {\n      const progressUpdates: any[] = [];\n      \n      // Listen for progress updates\n      clientSocket.on('test_progress', (data) => {\n        progressUpdates.push(data);\n      });\n\n      // Join the test session room\n      clientSocket.emit('join_session', {\n        sessionId: testSessionId,\n        cardId: testCardId\n      });\n\n      // Wait for join confirmation\n      await new Promise<void>((resolve) => {\n        clientSocket.on('session_joined', () => {\n          resolve();\n        });\n      });\n\n      // Start a test execution\n      const response = await request(app)\n        .post('/api/test-execution/run')\n        .send({\n          cardId: testCardId,\n          sessionId: testSessionId,\n          testCases: [\n            {\n              id: 'progress-test-1',\n              input: 'Test input 1',\n              expectedOutput: 'Expected output 1'\n            },\n            {\n              id: 'progress-test-2',\n              input: 'Test input 2',\n              expectedOutput: 'Expected output 2'\n            }\n          ],\n          model: 'gpt-3.5-turbo',\n          enableRealTimeUpdates: true\n        })\n        .expect(200);\n\n      // Wait for progress updates\n      await new Promise<void>((resolve) => {\n        setTimeout(() => resolve(), 5000); // Wait 5 seconds\n      });\n\n      // Should have received progress updates\n      expect(progressUpdates.length).toBeGreaterThan(0);\n      \n      // Check progress update structure\n      const firstUpdate = progressUpdates[0];\n      expect(firstUpdate).toHaveProperty('sessionId', testSessionId);\n      expect(firstUpdate).toHaveProperty('cardId', testCardId);\n      expect(firstUpdate).toHaveProperty('progress');\n      expect(firstUpdate).toHaveProperty('currentTest');\n      expect(firstUpdate).toHaveProperty('timestamp');\n    });\n\n    it('should receive analytics updates in real-time', async () => {\n      const analyticsUpdates: any[] = [];\n      \n      // Listen for analytics updates\n      clientSocket.on('analytics_update', (data) => {\n        analyticsUpdates.push(data);\n      });\n\n      // Subscribe to analytics updates\n      clientSocket.emit('subscribe_analytics', {\n        cardId: testCardId\n      });\n\n      // Wait for subscription confirmation\n      await new Promise<void>((resolve) => {\n        clientSocket.on('analytics_subscribed', () => {\n          resolve();\n        });\n      });\n\n      // Trigger analytics update through test execution\n      await request(app)\n        .post('/api/test-execution/run')\n        .send({\n          cardId: testCardId,\n          testCases: [\n            {\n              id: 'analytics-test',\n              input: 'Analytics test input',\n              expectedOutput: 'Expected output'\n            }\n          ],\n          model: 'gpt-3.5-turbo',\n          enableAnalytics: true\n        })\n        .expect(200);\n\n      // Wait for analytics updates\n      await new Promise<void>((resolve) => {\n        setTimeout(() => resolve(), 3000);\n      });\n\n      // Should have received analytics updates\n      expect(analyticsUpdates.length).toBeGreaterThan(0);\n      \n      const firstUpdate = analyticsUpdates[0];\n      expect(firstUpdate).toHaveProperty('cardId', testCardId);\n      expect(firstUpdate).toHaveProperty('metrics');\n      expect(firstUpdate.metrics).toHaveProperty('totalTests');\n      expect(firstUpdate.metrics).toHaveProperty('successRate');\n    });\n\n    it('should handle cost tracking updates', async () => {\n      const costUpdates: any[] = [];\n      \n      // Listen for cost updates\n      clientSocket.on('cost_update', (data) => {\n        costUpdates.push(data);\n      });\n\n      // Subscribe to cost updates\n      clientSocket.emit('subscribe_costs', {\n        cardId: testCardId\n      });\n\n      // Trigger cost tracking through test execution\n      await request(app)\n        .post('/api/test-execution/run')\n        .send({\n          cardId: testCardId,\n          testCases: [\n            {\n              id: 'cost-test',\n              input: 'Cost tracking test',\n              expectedOutput: 'Expected output'\n            }\n          ],\n          model: 'gpt-4', // More expensive model\n          enableCostTracking: true\n        })\n        .expect(200);\n\n      // Wait for cost updates\n      await new Promise<void>((resolve) => {\n        setTimeout(() => resolve(), 3000);\n      });\n\n      // Should have received cost updates\n      expect(costUpdates.length).toBeGreaterThan(0);\n      \n      const firstUpdate = costUpdates[0];\n      expect(firstUpdate).toHaveProperty('cardId', testCardId);\n      expect(firstUpdate).toHaveProperty('totalCost');\n      expect(firstUpdate).toHaveProperty('costPerTest');\n      expect(firstUpdate).toHaveProperty('tokenUsage');\n    });\n  });\n\n  describe('Multi-Agent Coordination', () => {\n    it('should coordinate multiple agents via WebSocket', async () => {\n      const agentUpdates: any[] = [];\n      \n      // Listen for agent coordination messages\n      clientSocket.on('agent_coordination', (data) => {\n        agentUpdates.push(data);\n      });\n\n      // Join agent coordination room\n      clientSocket.emit('join_agent_coordination', {\n        agentId: 'test-agent-1',\n        capabilities: ['testing', 'analysis']\n      });\n\n      // Simulate multi-agent test execution\n      await request(app)\n        .post('/api/test-execution/multi-agent')\n        .send({\n          cardId: testCardId,\n          agents: [\n            {\n              id: 'agent-1',\n              role: 'executor',\n              capabilities: ['testing']\n            },\n            {\n              id: 'agent-2',\n              role: 'analyzer',\n              capabilities: ['analysis']\n            }\n          ],\n          testCases: [\n            {\n              id: 'multi-agent-test',\n              input: 'Multi-agent test input',\n              expectedOutput: 'Expected output'\n            }\n          ],\n          coordinationEnabled: true\n        })\n        .expect(200);\n\n      // Wait for agent coordination\n      await new Promise<void>((resolve) => {\n        setTimeout(() => resolve(), 4000);\n      });\n\n      // Should have received coordination messages\n      expect(agentUpdates.length).toBeGreaterThan(0);\n      \n      const firstUpdate = agentUpdates[0];\n      expect(firstUpdate).toHaveProperty('type');\n      expect(firstUpdate).toHaveProperty('fromAgent');\n      expect(firstUpdate).toHaveProperty('message');\n    });\n  });\n\n  describe('Queue Status Updates', () => {\n    it('should receive queue status updates', async () => {\n      const queueUpdates: any[] = [];\n      \n      // Listen for queue updates\n      clientSocket.on('queue_status', (data) => {\n        queueUpdates.push(data);\n      });\n\n      // Subscribe to queue updates\n      clientSocket.emit('subscribe_queue', {\n        queueName: 'test-queue'\n      });\n\n      // Submit multiple tests to create queue activity\n      const testPromises = [];\n      for (let i = 0; i < 5; i++) {\n        testPromises.push(\n          request(app)\n            .post('/api/test-execution/parallel')\n            .send({\n              cardId: testCardId,\n              testCases: [\n                {\n                  id: `queue-test-${i}`,\n                  input: `Queue test ${i}`,\n                  expectedOutput: `Expected ${i}`\n                }\n              ],\n              model: 'gpt-3.5-turbo'\n            })\n        );\n      }\n\n      await Promise.all(testPromises);\n\n      // Wait for queue updates\n      await new Promise<void>((resolve) => {\n        setTimeout(() => resolve(), 3000);\n      });\n\n      // Should have received queue updates\n      expect(queueUpdates.length).toBeGreaterThan(0);\n      \n      const firstUpdate = queueUpdates[0];\n      expect(firstUpdate).toHaveProperty('queueLength');\n      expect(firstUpdate).toHaveProperty('processing');\n      expect(firstUpdate).toHaveProperty('completed');\n    });\n  });\n\n  describe('Resource Monitoring', () => {\n    it('should broadcast resource usage updates', async () => {\n      const resourceUpdates: any[] = [];\n      \n      // Listen for resource updates\n      clientSocket.on('resource_update', (data) => {\n        resourceUpdates.push(data);\n      });\n\n      // Subscribe to resource monitoring\n      clientSocket.emit('subscribe_resources', {\n        interval: 1000 // 1 second intervals\n      });\n\n      // Start resource-intensive operation\n      await request(app)\n        .post('/api/test-execution/resource-intensive')\n        .send({\n          cardId: testCardId,\n          testCases: Array.from({ length: 10 }, (_, i) => ({\n            id: `resource-test-${i}`,\n            input: `Resource test ${i}`,\n            expectedOutput: `Expected ${i}`\n          })),\n          model: 'gpt-4'\n        })\n        .expect(200);\n\n      // Wait for resource updates\n      await new Promise<void>((resolve) => {\n        setTimeout(() => resolve(), 5000);\n      });\n\n      // Should have received resource updates\n      expect(resourceUpdates.length).toBeGreaterThan(0);\n      \n      const firstUpdate = resourceUpdates[0];\n      expect(firstUpdate).toHaveProperty('cpu');\n      expect(firstUpdate).toHaveProperty('memory');\n      expect(firstUpdate).toHaveProperty('activeConnections');\n      expect(firstUpdate).toHaveProperty('timestamp');\n    });\n  });\n\n  describe('Error Handling', () => {\n    it('should handle WebSocket connection errors gracefully', async () => {\n      const errorEvents: any[] = [];\n      \n      // Listen for error events\n      clientSocket.on('error', (error) => {\n        errorEvents.push(error);\n      });\n\n      // Try to join invalid session\n      clientSocket.emit('join_session', {\n        sessionId: 'invalid-session-id',\n        cardId: 'invalid-card-id'\n      });\n\n      // Wait for error response\n      await new Promise<void>((resolve) => {\n        clientSocket.on('session_error', (error) => {\n          expect(error).toHaveProperty('message');\n          expect(error.message).toContain('Invalid session');\n          resolve();\n        });\n      });\n    });\n\n    it('should handle disconnection and reconnection', async () => {\n      let reconnected = false;\n      \n      // Listen for reconnection\n      clientSocket.on('reconnect', () => {\n        reconnected = true;\n      });\n\n      // Disconnect\n      clientSocket.disconnect();\n      \n      // Wait a moment\n      await new Promise<void>((resolve) => {\n        setTimeout(resolve, 1000);\n      });\n\n      // Reconnect\n      clientSocket.connect();\n      \n      // Wait for reconnection\n      await new Promise<void>((resolve) => {\n        setTimeout(resolve, 2000);\n      });\n\n      expect(clientSocket.connected).toBe(true);\n    });\n  });\n\n  describe('Performance and Scalability', () => {\n    it('should handle multiple concurrent WebSocket connections', async () => {\n      const clients: Socket[] = [];\n      const connections = 10;\n      \n      // Create multiple connections\n      for (let i = 0; i < connections; i++) {\n        const client = Client(`http://localhost:${(server.address() as any).port}`, {\n          autoConnect: false,\n          transports: ['websocket']\n        });\n        \n        clients.push(client);\n        \n        await new Promise<void>((resolve) => {\n          client.on('connect', () => {\n            resolve();\n          });\n          client.connect();\n        });\n      }\n\n      // All clients should be connected\n      expect(clients.length).toBe(connections);\n      for (const client of clients) {\n        expect(client.connected).toBe(true);\n      }\n\n      // Broadcast message to all clients\n      const messagesReceived: any[] = [];\n      \n      clients.forEach((client, index) => {\n        client.on('broadcast_message', (data) => {\n          messagesReceived.push({ clientIndex: index, data });\n        });\n      });\n\n      // Trigger broadcast\n      await request(app)\n        .post('/api/websocket/broadcast')\n        .send({\n          event: 'broadcast_message',\n          data: { message: 'Test broadcast', timestamp: Date.now() }\n        })\n        .expect(200);\n\n      // Wait for messages\n      await new Promise<void>((resolve) => {\n        setTimeout(resolve, 2000);\n      });\n\n      // All clients should have received the message\n      expect(messagesReceived.length).toBe(connections);\n\n      // Clean up\n      clients.forEach(client => client.disconnect());\n    });\n  });\n\n  describe('Security', () => {\n    it('should validate WebSocket authentication', async () => {\n      const unauthenticatedClient = Client(`http://localhost:${(server.address() as any).port}`, {\n        autoConnect: false,\n        transports: ['websocket'],\n        auth: {\n          token: 'invalid-token'\n        }\n      });\n\n      let authError = false;\n      \n      unauthenticatedClient.on('connect_error', (error) => {\n        authError = true;\n        expect(error.message).toContain('authentication');\n      });\n\n      unauthenticatedClient.connect();\n      \n      // Wait for connection attempt\n      await new Promise<void>((resolve) => {\n        setTimeout(resolve, 2000);\n      });\n\n      expect(authError).toBe(true);\n      expect(unauthenticatedClient.connected).toBe(false);\n      \n      unauthenticatedClient.disconnect();\n    });\n\n    it('should prevent unauthorized access to sensitive events', async () => {\n      let unauthorizedAccess = false;\n      \n      // Try to access admin-only events\n      clientSocket.emit('admin_command', {\n        command: 'shutdown_system'\n      });\n\n      clientSocket.on('unauthorized', (error) => {\n        unauthorizedAccess = true;\n        expect(error.message).toContain('unauthorized');\n      });\n\n      // Wait for response\n      await new Promise<void>((resolve) => {\n        setTimeout(resolve, 1000);\n      });\n\n      expect(unauthorizedAccess).toBe(true);\n    });\n  });\n});"],"names":["describe","server","clientSocket","progressService","testCardId","testSessionId","beforeEach","http","createServer","app","Promise","resolve","listen","port","address","Client","autoConnect","transports","Server","require","io","ProgressService","on","connect","afterEach","disconnect","close","it","progressUpdates","data","push","emit","sessionId","cardId","response","request","post","send","testCases","id","input","expectedOutput","model","enableRealTimeUpdates","expect","setTimeout","length","toBeGreaterThan","firstUpdate","toHaveProperty","analyticsUpdates","enableAnalytics","metrics","costUpdates","enableCostTracking","agentUpdates","agentId","capabilities","agents","role","coordinationEnabled","queueUpdates","queueName","testPromises","i","all","resourceUpdates","interval","Array","from","_","errorEvents","error","message","toContain","reconnected","connected","toBe","clients","connections","client","messagesReceived","forEach","index","clientIndex","event","timestamp","Date","now","unauthenticatedClient","auth","token","authError","unauthorizedAccess","command"],"mappings":"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"}