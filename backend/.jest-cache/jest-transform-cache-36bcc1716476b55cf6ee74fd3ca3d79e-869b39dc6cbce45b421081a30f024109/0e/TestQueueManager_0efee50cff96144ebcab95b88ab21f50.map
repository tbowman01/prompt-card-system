{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/testing/TestQueueManager.ts"],"sourcesContent":["import Bull from 'bull';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EventEmitter } from 'events';\nimport { llmService } from '../llmService';\nimport { db } from '../../database/connection';\nimport { Semaphore } from './Semaphore';\nimport { ResourceManager, ResourceRequirement } from './ResourceManager';\nimport { performance } from 'perf_hooks';\nimport { Worker } from 'worker_threads';\nimport { LRUCache } from 'lru-cache';\nimport { promisify } from 'util';\nimport { setTimeout } from 'timers/promises';\n\nexport interface TestJob {\n  test_execution_id: string;\n  prompt_card_id: number;\n  test_case_ids: number[];\n  model: string;\n  configuration: TestConfiguration;\n  priority: number;\n  user_id?: string;\n  created_at: Date;\n}\n\nexport interface TestConfiguration {\n  max_concurrent_tests: number;\n  timeout_per_test: number;\n  retry_failed_tests: boolean;\n  max_retries: number;\n  stop_on_first_failure: boolean;\n  resource_limits: {\n    memory_mb: number;\n    cpu_percent: number;\n  };\n  cache_enabled: boolean;\n  progress_updates: boolean;\n}\n\nexport interface TestCase {\n  id: number;\n  name: string;\n  prompt_card_id: number;\n  input_variables: string; // JSON\n  assertions: string; // JSON\n  expected_output?: string;\n  prompt_template: string;\n}\n\nexport interface TestExecutionResult {\n  execution_id: string;\n  test_case_id: number;\n  passed: boolean;\n  llm_output: string;\n  assertion_results: Array<{\n    assertion: any;\n    passed: boolean;\n    error?: string;\n  }>;\n  execution_time_ms: number;\n  model: string;\n  prompt_used: string;\n  created_at: Date;\n  metadata?: Record<string, any>;\n}\n\nexport interface ExecutionProgress {\n  job_id: string;\n  percent: number;\n  message: string;\n  current_test: number;\n  total_tests: number;\n  completed_tests: number;\n  failed_tests: number;\n  updated_at: Date;\n}\n\nexport class TestQueueManager extends EventEmitter {\n  private testQueue: Bull.Queue<TestJob>;\n  private resourceManager: ResourceManager;\n  private defaultConfiguration: TestConfiguration;\n  private activeJobs: Map<string, ExecutionProgress> = new Map();\n  private testCaseCache: LRUCache<string, TestCase[]>;\n  private performanceMetrics: Map<string, number[]>;\n  private connectionPool: any[];\n  private maxConnections: number;\n  private batchProcessor: any;\n  private workerPool: Worker[];\n\n  constructor(redisConfig?: Bull.QueueOptions['redis']) {\n    super();\n    \n    this.defaultConfiguration = {\n      max_concurrent_tests: Math.min(8, require('os').cpus().length * 2), // Dynamic based on CPU cores\n      timeout_per_test: 30000, // 30 seconds\n      retry_failed_tests: true,\n      max_retries: 2,\n      stop_on_first_failure: false,\n      resource_limits: {\n        memory_mb: 512,\n        cpu_percent: 20\n      },\n      cache_enabled: true,\n      progress_updates: true\n    };\n\n    // Initialize caching\n    this.testCaseCache = new LRUCache({\n      max: 1000,\n      ttl: 1000 * 60 * 10 // 10 minutes\n    });\n    \n    this.performanceMetrics = new Map();\n    this.maxConnections = Math.min(10, require('os').cpus().length * 2);\n    this.connectionPool = [];\n    this.workerPool = [];\n\n    // Initialize Redis queue with optimized settings\n    this.testQueue = new Bull('test-execution', {\n      redis: redisConfig || {\n        host: process.env.REDIS_HOST || 'localhost',\n        port: parseInt(process.env.REDIS_PORT || '6379'),\n        maxRetriesPerRequest: 3,\n        retryDelayOnFailover: 100,\n        enableReadyCheck: false,\n        maxLoadingTimeout: 1000\n      },\n      defaultJobOptions: {\n        removeOnComplete: 100,\n        removeOnFail: 50,\n        attempts: 3,\n        backoff: {\n          type: 'exponential',\n          delay: 2000\n        }\n      },\n      settings: {\n        stalledInterval: 30000,\n        maxStalledCount: 1\n      }\n    });\n\n    // Initialize resource manager with better defaults\n    this.resourceManager = new ResourceManager({\n      max_concurrent_tests: parseInt(process.env.MAX_CONCURRENT_TESTS || '20'),\n      max_cpu_percent: parseInt(process.env.MAX_CPU_PERCENT || '80'),\n      max_memory_mb: parseInt(process.env.MAX_MEMORY_MB || '4096')\n    });\n\n    this.setupJobProcessors();\n    this.setupEventHandlers();\n    this.initializeOptimizations();\n  }\n\n  /**\n   * Queue a test execution job\n   */\n  async queueTestExecution(\n    promptCardId: number,\n    testCaseIds: number[],\n    model: string,\n    configuration?: Partial<TestConfiguration>,\n    priority: number = 0\n  ): Promise<string> {\n    const executionId = uuidv4();\n    const config = { ...this.defaultConfiguration, ...configuration };\n\n    // Check resource availability\n    const resourceReq: ResourceRequirement = {\n      cpu_percent: config.resource_limits.cpu_percent,\n      memory_mb: config.resource_limits.memory_mb,\n      concurrent_tests: config.max_concurrent_tests,\n      priority: priority > 5 ? 'high' : priority < -5 ? 'low' : 'medium'\n    };\n\n    const hasResources = await this.resourceManager.checkResourceAvailability(resourceReq);\n    if (!hasResources) {\n      throw new Error('Insufficient system resources for test execution');\n    }\n\n    const job: TestJob = {\n      test_execution_id: executionId,\n      prompt_card_id: promptCardId,\n      test_case_ids: testCaseIds,\n      model,\n      configuration: config,\n      priority,\n      created_at: new Date()\n    };\n\n    // Add to queue\n    const queueJob = await this.testQueue.add('execute-tests', job, {\n      priority: priority,\n      delay: 0,\n      jobId: executionId\n    });\n\n    this.emit('jobQueued', { executionId, jobId: queueJob.id });\n    return executionId;\n  }\n\n  /**\n   * Get execution progress\n   */\n  getExecutionProgress(executionId: string): ExecutionProgress | null {\n    return this.activeJobs.get(executionId) || null;\n  }\n\n  /**\n   * Get all active executions\n   */\n  getActiveExecutions(): ExecutionProgress[] {\n    return Array.from(this.activeJobs.values());\n  }\n\n  /**\n   * Cancel a test execution\n   */\n  async cancelExecution(executionId: string): Promise<boolean> {\n    const job = await this.testQueue.getJob(executionId);\n    if (job) {\n      await job.remove();\n      this.activeJobs.delete(executionId);\n      \n      // Release resources\n      await this.resourceManager.releaseResources(executionId);\n      \n      this.emit('jobCancelled', { executionId });\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get queue statistics\n   */\n  async getQueueStats(): Promise<{\n    waiting: number;\n    active: number;\n    completed: number;\n    failed: number;\n    delayed: number;\n  }> {\n    const waiting = await this.testQueue.getWaiting();\n    const active = await this.testQueue.getActive();\n    const completed = await this.testQueue.getCompleted();\n    const failed = await this.testQueue.getFailed();\n    const delayed = await this.testQueue.getDelayed();\n\n    return {\n      waiting: waiting.length,\n      active: active.length,\n      completed: completed.length,\n      failed: failed.length,\n      delayed: delayed.length\n    };\n  }\n\n  /**\n   * Setup job processors with optimized concurrency\n   */\n  private setupJobProcessors(): void {\n    // Main test execution processor with dynamic concurrency\n    const concurrency = Math.min(5, require('os').cpus().length);\n    \n    this.testQueue.process('execute-tests', concurrency, async (job: Bull.Job<TestJob>) => {\n      const { data } = job;\n      const startTime = performance.now();\n      \n      try {\n        // Reserve resources with priority handling\n        await this.resourceManager.reserveResources(data.test_execution_id, {\n          cpu_percent: data.configuration.resource_limits.cpu_percent,\n          memory_mb: data.configuration.resource_limits.memory_mb,\n          concurrent_tests: data.configuration.max_concurrent_tests,\n          priority: data.priority > 5 ? 'high' : data.priority < -5 ? 'low' : 'medium'\n        });\n\n        // Initialize progress tracking\n        this.updateProgress(data.test_execution_id, 0, 'Starting test execution...', 0, data.test_case_ids.length);\n\n        // Execute tests with optimized parallel processing\n        const results = await this.executeTestsParallelOptimized(data, (progress) => {\n          this.updateProgress(\n            data.test_execution_id,\n            progress.percent,\n            progress.message,\n            progress.current_test,\n            progress.total_tests,\n            progress.completed_tests,\n            progress.failed_tests\n          );\n        });\n\n        // Update final progress\n        this.updateProgress(data.test_execution_id, 100, 'Test execution completed', data.test_case_ids.length, data.test_case_ids.length);\n\n        // Track performance\n        const executionTime = performance.now() - startTime;\n        this.trackPerformance('executeTests', executionTime);\n\n        this.emit('jobCompleted', { executionId: data.test_execution_id, results });\n        return results;\n\n      } catch (error) {\n        this.updateProgress(data.test_execution_id, -1, `Error: ${error.message}`, 0, data.test_case_ids.length);\n        this.emit('jobFailed', { executionId: data.test_execution_id, error: error.message });\n        throw error;\n      } finally {\n        // Release resources\n        await this.resourceManager.releaseResources(data.test_execution_id);\n        this.activeJobs.delete(data.test_execution_id);\n      }\n    });\n  }\n\n  /**\n   * Execute tests in parallel with resource management\n   */\n  private async executeTestsParallel(\n    job: TestJob,\n    progressCallback: (progress: {\n      percent: number;\n      message: string;\n      current_test: number;\n      total_tests: number;\n      completed_tests?: number;\n      failed_tests?: number;\n    }) => void\n  ): Promise<TestExecutionResult[]> {\n    const { test_case_ids, model, configuration } = job;\n    \n    // Load test cases with prompt template\n    const testCases = await this.loadTestCases(test_case_ids);\n    progressCallback({ percent: 10, message: 'Test cases loaded', current_test: 0, total_tests: testCases.length });\n\n    const results: TestExecutionResult[] = [];\n    const semaphore = new Semaphore(configuration.max_concurrent_tests);\n    let completedTests = 0;\n    let failedTests = 0;\n\n    const executeTest = async (testCase: TestCase, index: number): Promise<void> => {\n      const release = await semaphore.acquire();\n      \n      try {\n        const result = await this.executeSingleTest(testCase, model, configuration, job.test_execution_id);\n        results[index] = result;\n        completedTests++;\n        \n        if (!result.passed) {\n          failedTests++;\n          \n          // Stop on first failure if configured\n          if (configuration.stop_on_first_failure) {\n            throw new Error(`Test failed: ${testCase.name}`);\n          }\n        }\n\n        const progress = ((completedTests) / testCases.length) * 80 + 10;\n        progressCallback({\n          percent: progress,\n          message: `Completed test ${completedTests}/${testCases.length}`,\n          current_test: index + 1,\n          total_tests: testCases.length,\n          completed_tests: completedTests,\n          failed_tests: failedTests\n        });\n\n      } catch (error) {\n        failedTests++;\n        const errorResult: TestExecutionResult = {\n          execution_id: `${job.test_execution_id}-${testCase.id}`,\n          test_case_id: testCase.id,\n          passed: false,\n          llm_output: `ERROR: ${error.message}`,\n          assertion_results: [],\n          execution_time_ms: 0,\n          model,\n          prompt_used: 'Error occurred before prompt execution',\n          created_at: new Date(),\n          metadata: { error: error.message }\n        };\n        results[index] = errorResult;\n        \n        if (configuration.stop_on_first_failure) {\n          throw error;\n        }\n      } finally {\n        release();\n      }\n    };\n\n    // Execute all tests in parallel with concurrency control\n    await Promise.all(\n      testCases.map((testCase, index) => executeTest(testCase, index))\n    );\n\n    progressCallback({ percent: 95, message: 'Storing results...', current_test: testCases.length, total_tests: testCases.length });\n\n    // Store results in database\n    await this.storeResults(job.test_execution_id, results);\n\n    return results;\n  }\n\n  /**\n   * Execute a single test case\n   */\n  private async executeSingleTest(\n    testCase: TestCase,\n    model: string,\n    configuration: TestConfiguration,\n    executionId: string\n  ): Promise<TestExecutionResult> {\n    const startTime = Date.now();\n    const testExecutionId = `${executionId}-${testCase.id}`;\n\n    try {\n      // Parse JSON fields\n      const inputVariables = JSON.parse(testCase.input_variables);\n      const assertions = JSON.parse(testCase.assertions || '[]');\n\n      // Substitute variables in prompt template\n      const prompt = llmService.substituteVariables(testCase.prompt_template, inputVariables);\n\n      // Execute with timeout\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => reject(new Error('Test execution timeout')), configuration.timeout_per_test);\n      });\n\n      const executionPromise = llmService.generate(prompt, model);\n      const llmResponse = await Promise.race([executionPromise, timeoutPromise]);\n      const llmOutput = llmResponse.response;\n\n      // Validate assertions\n      const assertionResults = llmService.validateAssertions(llmOutput, assertions);\n      const allAssertionsPassed = assertionResults.every(result => result.passed);\n\n      const executionTime = Date.now() - startTime;\n\n      const result: TestExecutionResult = {\n        execution_id: testExecutionId,\n        test_case_id: testCase.id,\n        passed: allAssertionsPassed,\n        llm_output: llmOutput,\n        assertion_results: assertionResults,\n        execution_time_ms: executionTime,\n        model: llmResponse.model,\n        prompt_used: prompt,\n        created_at: new Date(),\n        metadata: {\n          total_tokens: llmResponse.eval_count || 0,\n          prompt_tokens: llmResponse.prompt_eval_count || 0,\n          completion_tokens: (llmResponse.eval_count || 0) - (llmResponse.prompt_eval_count || 0)\n        }\n      };\n\n      return result;\n\n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n      return {\n        execution_id: testExecutionId,\n        test_case_id: testCase.id,\n        passed: false,\n        llm_output: `ERROR: ${error.message}`,\n        assertion_results: [],\n        execution_time_ms: executionTime,\n        model,\n        prompt_used: 'Error occurred before prompt execution',\n        created_at: new Date(),\n        metadata: { error: error.message }\n      };\n    }\n  }\n\n  /**\n   * Load test cases from database with caching\n   */\n  private async loadTestCases(testCaseIds: number[]): Promise<TestCase[]> {\n    const cacheKey = testCaseIds.sort().join(',');\n    const cached = this.testCaseCache.get(cacheKey);\n    \n    if (cached) {\n      return cached;\n    }\n    \n    const placeholders = testCaseIds.map(() => '?').join(',');\n    const query = `\n      SELECT \n        tc.*,\n        pc.prompt_template,\n        pc.title as prompt_card_title\n      FROM test_cases tc\n      JOIN prompt_cards pc ON tc.prompt_card_id = pc.id\n      WHERE tc.id IN (${placeholders})\n      ORDER BY tc.id ASC\n    `;\n\n    const testCases = db.prepare(query).all(...testCaseIds) as TestCase[];\n    \n    if (testCases.length !== testCaseIds.length) {\n      throw new Error(`Some test cases not found. Expected ${testCaseIds.length}, got ${testCases.length}`);\n    }\n\n    // Cache the result\n    this.testCaseCache.set(cacheKey, testCases);\n    \n    return testCases;\n  }\n\n  /**\n   * Store test results in database\n   */\n  private async storeResults(executionId: string, results: TestExecutionResult[]): Promise<void> {\n    const transaction = db.transaction((results: TestExecutionResult[]) => {\n      const insertStmt = db.prepare(`\n        INSERT INTO test_results (\n          test_case_id, \n          execution_id, \n          llm_output, \n          passed, \n          assertion_results, \n          execution_time_ms,\n          created_at\n        ) VALUES (?, ?, ?, ?, ?, ?, ?)\n      `);\n\n      for (const result of results) {\n        insertStmt.run(\n          result.test_case_id,\n          result.execution_id,\n          result.llm_output,\n          result.passed ? 1 : 0,\n          JSON.stringify(result.assertion_results),\n          result.execution_time_ms,\n          result.created_at.toISOString()\n        );\n      }\n    });\n\n    transaction(results);\n  }\n\n  /**\n   * Update execution progress\n   */\n  private updateProgress(\n    executionId: string,\n    percent: number,\n    message: string,\n    currentTest: number,\n    totalTests: number,\n    completedTests: number = 0,\n    failedTests: number = 0\n  ): void {\n    const progress: ExecutionProgress = {\n      job_id: executionId,\n      percent,\n      message,\n      current_test: currentTest,\n      total_tests: totalTests,\n      completed_tests: completedTests,\n      failed_tests: failedTests,\n      updated_at: new Date()\n    };\n\n    this.activeJobs.set(executionId, progress);\n    this.emit('progressUpdated', progress);\n  }\n\n  /**\n   * Setup event handlers\n   */\n  private setupEventHandlers(): void {\n    // Handle failed jobs\n    this.testQueue.on('failed', (job: Bull.Job<TestJob>, error: Error) => {\n      console.error(`Job ${job.id} failed:`, error);\n      this.emit('jobFailed', { executionId: job.data.test_execution_id, error: error.message });\n    });\n\n    // Handle stalled jobs\n    this.testQueue.on('stalled', (job: Bull.Job<TestJob>) => {\n      console.warn(`Job ${job.id} stalled`);\n      this.emit('jobStalled', { executionId: job.data.test_execution_id });\n    });\n\n    // Handle resource manager events\n    this.resourceManager.on('systemStress', (usage) => {\n      console.warn('System under stress:', usage);\n      this.emit('systemStress', usage);\n    });\n\n    this.resourceManager.on('emergencyThreshold', (event) => {\n      console.error('Emergency threshold reached:', event);\n      this.emit('emergencyThreshold', event);\n    });\n  }\n\n  /**\n   * Optimized parallel test execution\n   */\n  private async executeTestsParallelOptimized(\n    job: TestJob,\n    progressCallback: (progress: {\n      percent: number;\n      message: string;\n      current_test: number;\n      total_tests: number;\n      completed_tests?: number;\n      failed_tests?: number;\n    }) => void\n  ): Promise<TestExecutionResult[]> {\n    const { test_case_ids, model, configuration } = job;\n    \n    // Load test cases with caching\n    const testCases = await this.loadTestCases(test_case_ids);\n    progressCallback({ percent: 10, message: 'Test cases loaded', current_test: 0, total_tests: testCases.length });\n\n    const results: TestExecutionResult[] = new Array(testCases.length);\n    const semaphore = new Semaphore(configuration.max_concurrent_tests);\n    let completedTests = 0;\n    let failedTests = 0;\n\n    // Process tests in batches for better memory management\n    const batchSize = Math.min(configuration.max_concurrent_tests * 2, 20);\n    const batches = [];\n    \n    for (let i = 0; i < testCases.length; i += batchSize) {\n      batches.push(testCases.slice(i, i + batchSize));\n    }\n\n    for (const batch of batches) {\n      const batchPromises = batch.map(async (testCase, batchIndex) => {\n        const release = await semaphore.acquire();\n        const globalIndex = batches.indexOf(batch) * batchSize + batchIndex;\n        \n        try {\n          const result = await this.executeSingleTestOptimized(testCase, model, configuration, job.test_execution_id);\n          results[globalIndex] = result;\n          completedTests++;\n          \n          if (!result.passed) {\n            failedTests++;\n            \n            // Stop on first failure if configured\n            if (configuration.stop_on_first_failure) {\n              throw new Error(`Test failed: ${testCase.name}`);\n            }\n          }\n\n          const progress = ((completedTests) / testCases.length) * 80 + 10;\n          progressCallback({\n            percent: progress,\n            message: `Completed test ${completedTests}/${testCases.length}`,\n            current_test: globalIndex + 1,\n            total_tests: testCases.length,\n            completed_tests: completedTests,\n            failed_tests: failedTests\n          });\n\n        } catch (error) {\n          failedTests++;\n          const errorResult: TestExecutionResult = {\n            execution_id: `${job.test_execution_id}-${testCase.id}`,\n            test_case_id: testCase.id,\n            passed: false,\n            llm_output: `ERROR: ${error.message}`,\n            assertion_results: [],\n            execution_time_ms: 0,\n            model,\n            prompt_used: 'Error occurred before prompt execution',\n            created_at: new Date(),\n            metadata: { error: error.message }\n          };\n          results[globalIndex] = errorResult;\n          \n          if (configuration.stop_on_first_failure) {\n            throw error;\n          }\n        } finally {\n          release();\n        }\n      });\n\n      await Promise.all(batchPromises);\n      \n      // Small delay between batches to prevent overwhelming the system\n      if (batches.indexOf(batch) < batches.length - 1) {\n        await setTimeout(100);\n      }\n    }\n\n    progressCallback({ percent: 95, message: 'Storing results...', current_test: testCases.length, total_tests: testCases.length });\n\n    // Store results in database using batch insertion\n    await this.storeResultsOptimized(job.test_execution_id, results);\n\n    return results;\n  }\n  \n  /**\n   * Execute a single test case with optimizations\n   */\n  private async executeSingleTestOptimized(\n    testCase: TestCase,\n    model: string,\n    configuration: TestConfiguration,\n    executionId: string\n  ): Promise<TestExecutionResult> {\n    const startTime = performance.now();\n    const testExecutionId = `${executionId}-${testCase.id}`;\n\n    try {\n      // Parse JSON fields with error handling\n      let inputVariables, assertions;\n      try {\n        inputVariables = JSON.parse(testCase.input_variables);\n        assertions = JSON.parse(testCase.assertions || '[]');\n      } catch (parseError) {\n        throw new Error(`Invalid JSON in test case ${testCase.id}: ${parseError.message}`);\n      }\n\n      // Substitute variables in prompt template\n      const prompt = llmService.substituteVariables(testCase.prompt_template, inputVariables);\n\n      // Execute with timeout using Promise.race\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(() => reject(new Error('Test execution timeout')), configuration.timeout_per_test);\n      });\n\n      const executionPromise = llmService.generate(prompt, model);\n      const llmResponse = await Promise.race([executionPromise, timeoutPromise]);\n      const llmOutput = llmResponse.response;\n\n      // Validate assertions\n      const assertionResults = llmService.validateAssertions(llmOutput, assertions);\n      const allAssertionsPassed = assertionResults.every(result => result.passed);\n\n      const executionTime = performance.now() - startTime;\n\n      const result: TestExecutionResult = {\n        execution_id: testExecutionId,\n        test_case_id: testCase.id,\n        passed: allAssertionsPassed,\n        llm_output: llmOutput,\n        assertion_results: assertionResults,\n        execution_time_ms: Math.round(executionTime),\n        model: llmResponse.model,\n        prompt_used: prompt,\n        created_at: new Date(),\n        metadata: {\n          total_tokens: llmResponse.eval_count || 0,\n          prompt_tokens: llmResponse.prompt_eval_count || 0,\n          completion_tokens: (llmResponse.eval_count || 0) - (llmResponse.prompt_eval_count || 0),\n          cache_hit: false // Could be enhanced with actual cache hit detection\n        }\n      };\n\n      return result;\n\n    } catch (error) {\n      const executionTime = performance.now() - startTime;\n      return {\n        execution_id: testExecutionId,\n        test_case_id: testCase.id,\n        passed: false,\n        llm_output: `ERROR: ${error.message}`,\n        assertion_results: [],\n        execution_time_ms: Math.round(executionTime),\n        model,\n        prompt_used: 'Error occurred before prompt execution',\n        created_at: new Date(),\n        metadata: { error: error.message }\n      };\n    }\n  }\n  \n  /**\n   * Store test results with optimized batch insertion\n   */\n  private async storeResultsOptimized(executionId: string, results: TestExecutionResult[]): Promise<void> {\n    const transaction = db.transaction((results: TestExecutionResult[]) => {\n      const insertStmt = db.prepare(`\n        INSERT INTO test_results (\n          test_case_id, \n          execution_id, \n          llm_output, \n          passed, \n          assertion_results, \n          execution_time_ms,\n          model,\n          created_at\n        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?)\n      `);\n\n      for (const result of results) {\n        insertStmt.run(\n          result.test_case_id,\n          result.execution_id,\n          result.llm_output,\n          result.passed ? 1 : 0,\n          JSON.stringify(result.assertion_results),\n          result.execution_time_ms,\n          result.model,\n          result.created_at.toISOString()\n        );\n      }\n    });\n\n    transaction(results);\n  }\n  \n  /**\n   * Initialize performance optimizations\n   */\n  private initializeOptimizations(): void {\n    // Pre-warm database connections\n    this.preWarmConnections();\n    \n    // Set up periodic cache cleanup\n    setInterval(() => {\n      this.cleanupCaches();\n    }, 1000 * 60 * 5); // Every 5 minutes\n    \n    console.log('Test queue optimizations initialized');\n  }\n  \n  /**\n   * Pre-warm database connections\n   */\n  private async preWarmConnections(): Promise<void> {\n    try {\n      // Execute a simple query to warm up the connection\n      db.prepare('SELECT 1').get();\n      console.log('Database connections pre-warmed');\n    } catch (error) {\n      console.warn('Failed to pre-warm database connections:', error.message);\n    }\n  }\n  \n  /**\n   * Clean up caches periodically\n   */\n  private cleanupCaches(): void {\n    // Clean up old performance metrics\n    for (const [key, metrics] of this.performanceMetrics) {\n      if (metrics.length > 1000) {\n        this.performanceMetrics.set(key, metrics.slice(-500));\n      }\n    }\n    \n    // Log cache statistics\n    console.log(`Cache stats - Test cases: ${this.testCaseCache.size}/${this.testCaseCache.max}`);\n  }\n  \n  /**\n   * Track performance metrics\n   */\n  private trackPerformance(operation: string, duration: number): void {\n    if (!this.performanceMetrics.has(operation)) {\n      this.performanceMetrics.set(operation, []);\n    }\n    \n    const metrics = this.performanceMetrics.get(operation)!;\n    metrics.push(duration);\n    \n    // Keep only last 100 measurements\n    if (metrics.length > 100) {\n      metrics.shift();\n    }\n    \n    // Log slow operations\n    if (duration > 60000) { // 1 minute\n      console.warn(`Slow test execution: ${operation} took ${duration.toFixed(2)}ms`);\n    }\n  }\n  \n  /**\n   * Get performance statistics\n   */\n  public getPerformanceStats(): Record<string, { avg: number; max: number; min: number; count: number }> {\n    const stats: Record<string, { avg: number; max: number; min: number; count: number }> = {};\n    \n    for (const [operation, metrics] of this.performanceMetrics) {\n      if (metrics.length > 0) {\n        const avg = metrics.reduce((sum, time) => sum + time, 0) / metrics.length;\n        const max = Math.max(...metrics);\n        const min = Math.min(...metrics);\n        \n        stats[operation] = {\n          avg: Math.round(avg),\n          max: Math.round(max),\n          min: Math.round(min),\n          count: metrics.length\n        };\n      }\n    }\n    \n    return stats;\n  }\n  \n  /**\n   * Clear caches and metrics\n   */\n  public clearCaches(): void {\n    this.testCaseCache.clear();\n    this.performanceMetrics.clear();\n    console.log('Test queue caches cleared');\n  }\n  \n  /**\n   * Initialize the test queue manager\n   */\n  async initialize(): Promise<void> {\n    // Ensure Redis connection and warm up the system\n    await this.preWarmConnections();\n    console.log('TestQueueManager initialized');\n  }\n\n  /**\n   * Cleanup the test queue manager\n   */\n  async cleanup(): Promise<void> {\n    await this.shutdown();\n    console.log('TestQueueManager cleaned up');\n  }\n\n  /**\n   * Set queue limit for concurrent executions\n   */\n  async setQueueLimit(limit: number): Promise<void> {\n    this.defaultConfiguration.max_concurrent_tests = limit;\n    console.log(`Queue limit set to ${limit}`);\n  }\n\n  /**\n   * Graceful shutdown\n   */\n  async shutdown(): Promise<void> {\n    await this.testQueue.close();\n    this.resourceManager.destroy();\n    this.removeAllListeners();\n  }\n}"],"names":["TestQueueManager","EventEmitter","queueTestExecution","promptCardId","testCaseIds","model","configuration","priority","executionId","uuidv4","config","defaultConfiguration","resourceReq","cpu_percent","resource_limits","memory_mb","concurrent_tests","max_concurrent_tests","hasResources","resourceManager","checkResourceAvailability","Error","job","test_execution_id","prompt_card_id","test_case_ids","created_at","Date","queueJob","testQueue","add","delay","jobId","emit","id","getExecutionProgress","activeJobs","get","getActiveExecutions","Array","from","values","cancelExecution","getJob","remove","delete","releaseResources","getQueueStats","waiting","getWaiting","active","getActive","completed","getCompleted","failed","getFailed","delayed","getDelayed","length","setupJobProcessors","concurrency","Math","min","require","cpus","process","data","startTime","performance","now","reserveResources","updateProgress","results","executeTestsParallelOptimized","progress","percent","message","current_test","total_tests","completed_tests","failed_tests","executionTime","trackPerformance","error","executeTestsParallel","progressCallback","testCases","loadTestCases","semaphore","Semaphore","completedTests","failedTests","executeTest","testCase","index","release","acquire","result","executeSingleTest","passed","stop_on_first_failure","name","errorResult","execution_id","test_case_id","llm_output","assertion_results","execution_time_ms","prompt_used","metadata","Promise","all","map","storeResults","testExecutionId","inputVariables","JSON","parse","input_variables","assertions","prompt","llmService","substituteVariables","prompt_template","timeoutPromise","_","reject","setTimeout","timeout_per_test","executionPromise","generate","llmResponse","race","llmOutput","response","assertionResults","validateAssertions","allAssertionsPassed","every","total_tokens","eval_count","prompt_tokens","prompt_eval_count","completion_tokens","cacheKey","sort","join","cached","testCaseCache","placeholders","query","db","prepare","set","transaction","insertStmt","run","stringify","toISOString","currentTest","totalTests","job_id","updated_at","setupEventHandlers","on","console","warn","usage","event","batchSize","batches","i","push","slice","batch","batchPromises","batchIndex","globalIndex","indexOf","executeSingleTestOptimized","storeResultsOptimized","parseError","round","cache_hit","initializeOptimizations","preWarmConnections","setInterval","cleanupCaches","log","key","metrics","performanceMetrics","size","max","operation","duration","has","shift","toFixed","getPerformanceStats","stats","avg","reduce","sum","time","count","clearCaches","clear","initialize","cleanup","shutdown","setQueueLimit","limit","close","destroy","removeAllListeners","redisConfig","Map","connectionPool","maxConnections","batchProcessor","workerPool","retry_failed_tests","max_retries","cache_enabled","progress_updates","LRUCache","ttl","Bull","redis","host","env","REDIS_HOST","port","parseInt","REDIS_PORT","maxRetriesPerRequest","retryDelayOnFailover","enableReadyCheck","maxLoadingTimeout","defaultJobOptions","removeOnComplete","removeOnFail","attempts","backoff","type","settings","stalledInterval","maxStalledCount","ResourceManager","MAX_CONCURRENT_TESTS","max_cpu_percent","MAX_CPU_PERCENT","max_memory_mb","MAX_MEMORY_MB"],"mappings":"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"}