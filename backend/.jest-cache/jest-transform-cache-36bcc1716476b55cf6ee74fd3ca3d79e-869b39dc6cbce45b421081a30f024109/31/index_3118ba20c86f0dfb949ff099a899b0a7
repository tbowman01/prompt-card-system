f3ac50295f9c6dd63ba97531d1ac0b7f
/**
 * Enhanced Assertion System
 * 
 * This module provides a comprehensive assertion system for validating LLM outputs
 * with support for semantic similarity, custom JavaScript code execution, and
 * various other advanced validation techniques.
 */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get AssertionEngine () {
        return _AssertionEngine.AssertionEngine;
    },
    get AssertionTypeRegistry () {
        return _AssertionTypeRegistry.AssertionTypeRegistry;
    },
    get AssertionUtils () {
        return AssertionUtils;
    },
    get CustomAssertionValidator () {
        return _CustomAssertionValidator.CustomAssertionValidator;
    },
    get SemanticSimilarityValidator () {
        return _SemanticSimilarityValidator.SemanticSimilarityValidator;
    },
    get assertionEngine () {
        return assertionEngine;
    },
    get // Export as default
    default () {
        return _default;
    }
});
const _AssertionEngine = require("./AssertionEngine");
const _SemanticSimilarityValidator = require("./SemanticSimilarityValidator");
const _CustomAssertionValidator = require("./CustomAssertionValidator");
const _AssertionTypeRegistry = require("./AssertionTypeRegistry");
class AssertionUtils {
    /**
   * Create a basic contains assertion
   */ static contains(value, description) {
        return {
            type: 'contains',
            value,
            description: description || `Check if output contains "${value}"`
        };
    }
    /**
   * Create a length range assertion
   */ static lengthRange(min, max, description) {
        return {
            type: 'length',
            value: `${min}-${max}`,
            description: description || `Check if output length is between ${min} and ${max} characters`
        };
    }
    /**
   * Create a semantic similarity assertion
   */ static semanticSimilarity(expectedText, threshold = 0.8, description) {
        return {
            type: 'semantic-similarity',
            value: expectedText,
            threshold,
            description: description || `Check semantic similarity to "${expectedText}" (threshold: ${threshold})`
        };
    }
    /**
   * Create a sentiment assertion
   */ static sentiment(expectedSentiment, threshold = 0.6, description) {
        return {
            type: 'sentiment',
            value: expectedSentiment,
            threshold,
            description: description || `Check if sentiment is ${expectedSentiment} (threshold: ${threshold})`
        };
    }
    /**
   * Create a language detection assertion
   */ static language(expectedLanguage, description) {
        return {
            type: 'language',
            value: expectedLanguage,
            description: description || `Check if language is ${expectedLanguage}`
        };
    }
    /**
   * Create a toxicity assertion
   */ static toxicity(maxScore = 0.5, description) {
        return {
            type: 'toxicity',
            value: maxScore,
            description: description || `Check if toxicity score is below ${maxScore}`
        };
    }
    /**
   * Create a custom assertion with helper functions
   */ static custom(code, description) {
        return {
            type: 'custom',
            value: code,
            description: description || 'Custom assertion validation'
        };
    }
    /**
   * Create a JSON schema assertion
   */ static jsonSchema(schema, description) {
        return {
            type: 'json-schema',
            value: schema,
            description: description || 'Validate JSON structure'
        };
    }
    /**
   * Create a regex assertion
   */ static regex(pattern, flags, description) {
        return {
            type: 'regex',
            value: pattern,
            config: flags ? {
                flags
            } : undefined,
            description: description || `Check if output matches pattern: ${pattern}`
        };
    }
    /**
   * Create multiple assertions for comprehensive validation
   */ static comprehensive(expectedText, options = {}) {
        const assertions = [];
        // Semantic similarity
        if (options.semanticThreshold !== undefined) {
            assertions.push(this.semanticSimilarity(expectedText, options.semanticThreshold));
        }
        // Sentiment
        if (options.sentimentExpected) {
            assertions.push(this.sentiment(options.sentimentExpected));
        }
        // Length constraints
        if (options.minLength !== undefined && options.maxLength !== undefined) {
            assertions.push(this.lengthRange(options.minLength, options.maxLength));
        }
        // Language
        if (options.language) {
            assertions.push(this.language(options.language));
        }
        // Toxicity
        if (options.maxToxicity !== undefined) {
            assertions.push(this.toxicity(options.maxToxicity));
        }
        // Custom checks
        if (options.customChecks) {
            options.customChecks.forEach((check)=>{
                assertions.push(this.custom(check));
            });
        }
        return assertions;
    }
}
const assertionEngine = new _AssertionEngine.AssertionEngine();
// Initialize the global assertion engine
assertionEngine.initialize().catch(console.error);
const _default = assertionEngine;
