{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/routes/testExecution.ts"],"sourcesContent":["import { Router } from 'express';\nimport { db } from '../database/connection';\nimport { llmService } from '../services/llmService';\nimport { v4 as uuidv4 } from 'uuid';\nimport { EnhancedAssertionType, EnhancedAssertionResult } from '../services/assertions/AssertionEngine';\n\nconst router = Router();\n\nexport interface TestExecutionResult {\n  execution_id: string;\n  test_case_id: number;\n  passed: boolean;\n  llm_output: string;\n  assertion_results: EnhancedAssertionResult[];\n  execution_time_ms: number;\n  model: string;\n  prompt_used: string;\n}\n\nexport interface BatchExecutionResult {\n  execution_id: string;\n  prompt_card_id: number;\n  total_tests: number;\n  passed_tests: number;\n  failed_tests: number;\n  results: TestExecutionResult[];\n  overall_passed: boolean;\n  execution_time_ms: number;\n}\n\n/**\n * Execute a single test case\n * POST /api/test-cases/:id/execute\n */\nrouter.post('/:id/execute', async (req, res) => {\n  const startTime = Date.now();\n  let executionId = '';\n\n  try {\n    const { id } = req.params;\n    const { model } = req.body; // Optional model override\n    \n    executionId = uuidv4();\n\n    // Get test case with prompt card\n    const testCase = db.prepare(`\n      SELECT \n        tc.*,\n        pc.prompt_template,\n        pc.title as prompt_card_title\n      FROM test_cases tc\n      JOIN prompt_cards pc ON tc.prompt_card_id = pc.id\n      WHERE tc.id = ?\n    `).get(id) as any;\n\n    if (!testCase) {\n      return res.status(404).json({\n        success: false,\n        error: 'Test case not found'\n      });\n    }\n\n    // Parse JSON fields\n    const inputVariables = JSON.parse(testCase.input_variables);\n    const assertions = JSON.parse(testCase.assertions || '[]');\n\n    // Substitute variables in prompt template\n    const prompt = llmService.substituteVariables(testCase.prompt_template, inputVariables);\n\n    // Execute prompt with LLM\n    const llmResponse = await llmService.generate(prompt, model);\n    const llmOutput = llmResponse.response;\n\n    // Validate assertions\n    const assertionResults = await llmService.validateAssertions(llmOutput, assertions, {\n      prompt: prompt,\n      variables: inputVariables,\n      model: model || llmService.defaultModel,\n      executionTime: Date.now() - startTime\n    });\n    const allAssertionsPassed = assertionResults.every(result => result.passed);\n\n    const executionTime = Date.now() - startTime;\n\n    // Store result in database\n    const insertResult = db.prepare(`\n      INSERT INTO test_results (\n        test_case_id, \n        execution_id, \n        llm_output, \n        passed, \n        assertion_results, \n        execution_time_ms\n      ) VALUES (?, ?, ?, ?, ?, ?)\n    `).run(\n      id,\n      executionId,\n      llmOutput,\n      allAssertionsPassed ? 1 : 0,\n      JSON.stringify(assertionResults),\n      executionTime\n    );\n\n    const result: TestExecutionResult = {\n      execution_id: executionId,\n      test_case_id: parseInt(id),\n      passed: allAssertionsPassed,\n      llm_output: llmOutput,\n      assertion_results: assertionResults,\n      execution_time_ms: executionTime,\n      model: llmResponse.model,\n      prompt_used: prompt\n    };\n\n    return res.json({\n      success: true,\n      data: result\n    });\n\n  } catch (error) {\n    // Log error but still try to store failed result\n    try {\n      if (executionId) {\n        db.prepare(`\n          INSERT INTO test_results (\n            test_case_id, \n            execution_id, \n            llm_output, \n            passed, \n            assertion_results, \n            execution_time_ms\n          ) VALUES (?, ?, ?, ?, ?, ?)\n        `).run(\n          req.params.id,\n          executionId,\n          `ERROR: ${error instanceof Error ? error.message : 'Unknown error'}`,\n          0,\n          JSON.stringify([]),\n          Date.now() - startTime\n        );\n      }\n    } catch (dbError) {\n      console.error('Failed to store error result:', dbError);\n    }\n\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Test execution failed',\n      execution_id: executionId\n    });\n  }\n});\n\n/**\n * Execute all test cases for a prompt card\n * POST /api/prompt-cards/:id/execute-all\n */\nrouter.post('/prompt-cards/:id/execute-all', async (req, res) => {\n  const startTime = Date.now();\n  const executionId = uuidv4();\n\n  try {\n    const { id } = req.params;\n    const { model, stopOnFirstFailure = false } = req.body;\n\n    // Get prompt card\n    const promptCard = db.prepare(`\n      SELECT * FROM prompt_cards WHERE id = ?\n    `).get(id) as any;\n\n    if (!promptCard) {\n      return res.status(404).json({\n        success: false,\n        error: 'Prompt card not found'\n      });\n    }\n\n    // Get all test cases for this prompt card\n    const testCases = db.prepare(`\n      SELECT * FROM test_cases WHERE prompt_card_id = ? ORDER BY created_at ASC\n    `).all(id) as any[];\n\n    if (testCases.length === 0) {\n      return res.status(400).json({\n        success: false,\n        error: 'No test cases found for this prompt card'\n      });\n    }\n\n    const results: TestExecutionResult[] = [];\n    let shouldStop = false;\n\n    // Execute each test case\n    for (const testCase of testCases) {\n      if (shouldStop) break;\n\n      const testStartTime = Date.now();\n      const testExecutionId = `${executionId}-${testCase.id}`;\n\n      try {\n        // Parse JSON fields\n        const inputVariables = JSON.parse(testCase.input_variables);\n        const assertions = JSON.parse(testCase.assertions || '[]');\n\n        // Substitute variables in prompt template\n        const prompt = llmService.substituteVariables(promptCard.prompt_template, inputVariables);\n\n        // Execute prompt with LLM\n        const llmResponse = await llmService.generate(prompt, model);\n        const llmOutput = llmResponse.response;\n\n        const testExecutionTime = Date.now() - testStartTime;\n\n        // Validate assertions\n        const assertionResults = await llmService.validateAssertions(llmOutput, assertions, {\n          prompt: prompt,\n          variables: inputVariables,\n          model: model || llmService.defaultModel,\n          executionTime: testExecutionTime\n        });\n        const allAssertionsPassed = assertionResults.every(result => result.passed);\n\n        // Store individual result\n        db.prepare(`\n          INSERT INTO test_results (\n            test_case_id, \n            execution_id, \n            llm_output, \n            passed, \n            assertion_results, \n            execution_time_ms\n          ) VALUES (?, ?, ?, ?, ?, ?)\n        `).run(\n          testCase.id,\n          testExecutionId,\n          llmOutput,\n          allAssertionsPassed ? 1 : 0,\n          JSON.stringify(assertionResults),\n          testExecutionTime\n        );\n\n        const result: TestExecutionResult = {\n          execution_id: testExecutionId,\n          test_case_id: testCase.id,\n          passed: allAssertionsPassed,\n          llm_output: llmOutput,\n          assertion_results: assertionResults,\n          execution_time_ms: testExecutionTime,\n          model: llmResponse.model,\n          prompt_used: prompt\n        };\n\n        results.push(result);\n\n        // Stop on first failure if requested\n        if (stopOnFirstFailure && !allAssertionsPassed) {\n          shouldStop = true;\n        }\n\n      } catch (testError) {\n        // Store failed test result\n        const testExecutionTime = Date.now() - testStartTime;\n        \n        try {\n          db.prepare(`\n            INSERT INTO test_results (\n              test_case_id, \n              execution_id, \n              llm_output, \n              passed, \n              assertion_results, \n              execution_time_ms\n            ) VALUES (?, ?, ?, ?, ?, ?)\n          `).run(\n            testCase.id,\n            testExecutionId,\n            `ERROR: ${testError instanceof Error ? testError.message : 'Unknown error'}`,\n            0,\n            JSON.stringify([]),\n            testExecutionTime\n          );\n        } catch (dbError) {\n          console.error('Failed to store failed test result:', dbError);\n        }\n\n        const errorResult: TestExecutionResult = {\n          execution_id: testExecutionId,\n          test_case_id: testCase.id,\n          passed: false,\n          llm_output: `ERROR: ${testError instanceof Error ? testError.message : 'Unknown error'}`,\n          assertion_results: [],\n          execution_time_ms: testExecutionTime,\n          model: model || 'unknown',\n          prompt_used: 'Error occurred before prompt execution'\n        };\n\n        results.push(errorResult);\n\n        // Stop on first failure if requested\n        if (stopOnFirstFailure) {\n          shouldStop = true;\n        }\n      }\n    }\n\n    const totalExecutionTime = Date.now() - startTime;\n    const passedTests = results.filter(r => r.passed).length;\n    const failedTests = results.length - passedTests;\n    const overallPassed = failedTests === 0;\n\n    const batchResult: BatchExecutionResult = {\n      execution_id: executionId,\n      prompt_card_id: parseInt(id),\n      total_tests: results.length,\n      passed_tests: passedTests,\n      failed_tests: failedTests,\n      results,\n      overall_passed: overallPassed,\n      execution_time_ms: totalExecutionTime\n    };\n\n    return res.json({\n      success: true,\n      data: batchResult\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Batch execution failed',\n      execution_id: executionId\n    });\n  }\n});\n\n/**\n * Get test execution history for a test case\n * GET /api/test-cases/:id/executions\n */\nrouter.get('/:id/executions', (req, res) => {\n  try {\n    const { id } = req.params;\n    const page = parseInt(req.query.page as string) || 1;\n    const limit = parseInt(req.query.limit as string) || 10;\n    const offset = (page - 1) * limit;\n\n    // Verify test case exists\n    const testCase = db.prepare('SELECT id FROM test_cases WHERE id = ?').get(id) as any;\n    if (!testCase) {\n      return res.status(404).json({\n        success: false,\n        error: 'Test case not found'\n      });\n    }\n\n    // Get total count\n    const totalResult = db.prepare(`\n      SELECT COUNT(*) as total FROM test_results WHERE test_case_id = ?\n    `).get(id) as { total: number };\n\n    // Get paginated results\n    const results = db.prepare(`\n      SELECT * FROM test_results \n      WHERE test_case_id = ? \n      ORDER BY created_at DESC \n      LIMIT ? OFFSET ?\n    `).all(id, limit, offset) as any[];\n\n    const totalPages = Math.ceil(totalResult.total / limit);\n\n    return res.json({\n      success: true,\n      data: results.map(result => ({\n        ...result,\n        assertion_results: JSON.parse(result.assertion_results || '[]'),\n        passed: Boolean(result.passed)\n      })),\n      pagination: {\n        page,\n        limit,\n        total: totalResult.total,\n        totalPages,\n        hasNext: page < totalPages,\n        hasPrev: page > 1\n      }\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to fetch execution history'\n    });\n  }\n});\n\n/**\n * Get specific test execution result\n * GET /api/test-executions/:executionId\n */\nrouter.get('/executions/:executionId', (req, res) => {\n  try {\n    const { executionId } = req.params;\n\n    const result = db.prepare(`\n      SELECT \n        tr.*,\n        tc.name as test_case_name,\n        pc.title as prompt_card_title\n      FROM test_results tr\n      JOIN test_cases tc ON tr.test_case_id = tc.id\n      JOIN prompt_cards pc ON tc.prompt_card_id = pc.id\n      WHERE tr.execution_id = ?\n    `).get(executionId) as any;\n\n    if (!result) {\n      return res.status(404).json({\n        success: false,\n        error: 'Execution result not found'\n      });\n    }\n\n    return res.json({\n      success: true,\n      data: {\n        ...result,\n        assertion_results: JSON.parse(result.assertion_results || '[]'),\n        passed: Boolean(result.passed)\n      }\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to fetch execution result'\n    });\n  }\n});\n\n/**\n * Execute tests in parallel with queue management\n * POST /api/test-cases/execute-parallel\n */\nrouter.post('/execute-parallel', async (req, res) => {\n  try {\n    const { \n      prompt_card_id, \n      test_case_ids, \n      model, \n      configuration = {\n        max_concurrent_tests: 3,\n        timeout_per_test: 30000,\n        retry_failed_tests: false,\n        max_retries: 1,\n        resource_limits: {\n          memory_mb: 1024,\n          cpu_percent: 50\n        }\n      },\n      priority = 0\n    } = req.body;\n\n    // Validate required fields\n    if (!prompt_card_id || !test_case_ids || !Array.isArray(test_case_ids) || test_case_ids.length === 0) {\n      return res.status(400).json({\n        success: false,\n        error: 'prompt_card_id and test_case_ids are required'\n      });\n    }\n\n    // Verify prompt card exists\n    const promptCard = db.prepare('SELECT id FROM prompt_cards WHERE id = ?').get(prompt_card_id);\n    if (!promptCard) {\n      return res.status(404).json({\n        success: false,\n        error: 'Prompt card not found'\n      });\n    }\n\n    // Verify test cases exist\n    const placeholders = test_case_ids.map(() => '?').join(',');\n    const testCases = db.prepare(`\n      SELECT id FROM test_cases WHERE id IN (${placeholders}) AND prompt_card_id = ?\n    `).all(...test_case_ids, prompt_card_id);\n\n    if (testCases.length !== test_case_ids.length) {\n      return res.status(400).json({\n        success: false,\n        error: 'Some test cases not found or do not belong to the specified prompt card'\n      });\n    }\n\n    // Queue the execution\n    const queueManager = req.app.locals.queueManager;\n    const executionId = await queueManager.queueTestExecution({\n      prompt_card_id,\n      test_case_ids,\n      model: model || 'llama3.1',\n      configuration,\n      priority\n    });\n\n    return res.json({\n      success: true,\n      data: {\n        execution_id: executionId,\n        status: 'queued',\n        message: 'Test execution queued successfully'\n      }\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to queue test execution'\n    });\n  }\n});\n\n/**\n * Get progress for a test execution\n * GET /api/test-cases/executions/:executionId/progress\n */\nrouter.get('/executions/:executionId/progress', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const progressService = req.app.locals.progressService;\n    \n    const progress = await progressService.getProgress(executionId);\n    \n    if (!progress) {\n      return res.status(404).json({\n        success: false,\n        error: 'Execution progress not found'\n      });\n    }\n\n    return res.json({\n      success: true,\n      data: progress\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to fetch execution progress'\n    });\n  }\n});\n\n/**\n * Cancel a test execution\n * POST /api/test-cases/executions/:executionId/cancel\n */\nrouter.post('/executions/:executionId/cancel', async (req, res) => {\n  try {\n    const { executionId } = req.params;\n    const { reason = 'User requested cancellation' } = req.body;\n    \n    const queueManager = req.app.locals.queueManager;\n    await queueManager.cancelTestExecution(executionId, reason);\n\n    return res.json({\n      success: true,\n      data: {\n        execution_id: executionId,\n        status: 'cancelled',\n        message: 'Test execution cancelled successfully'\n      }\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to cancel test execution'\n    });\n  }\n});\n\n/**\n * Get queue statistics\n * GET /api/test-cases/queue/stats\n */\nrouter.get('/queue/stats', async (req, res) => {\n  try {\n    const queueManager = req.app.locals.queueManager;\n    const stats = await queueManager.getQueueStats();\n\n    return res.json({\n      success: true,\n      data: stats\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to fetch queue statistics'\n    });\n  }\n});\n\n/**\n * Get active test executions\n * GET /api/test-cases/executions/active\n */\nrouter.get('/executions/active', async (req, res) => {\n  try {\n    const progressService = req.app.locals.progressService;\n    const activeExecutions = await progressService.getActiveExecutions();\n\n    return res.json({\n      success: true,\n      data: activeExecutions\n    });\n\n  } catch (error) {\n    return res.status(500).json({\n      success: false,\n      error: error instanceof Error ? error.message : 'Failed to fetch active executions'\n    });\n  }\n});\n\nexport { router as testExecutionRoutes };"],"names":["testExecutionRoutes","router","Router","post","req","res","startTime","Date","now","executionId","id","params","model","body","uuidv4","testCase","db","prepare","get","status","json","success","error","inputVariables","JSON","parse","input_variables","assertions","prompt","llmService","substituteVariables","prompt_template","llmResponse","generate","llmOutput","response","assertionResults","validateAssertions","variables","defaultModel","executionTime","allAssertionsPassed","every","result","passed","insertResult","run","stringify","execution_id","test_case_id","parseInt","llm_output","assertion_results","execution_time_ms","prompt_used","data","Error","message","dbError","console","stopOnFirstFailure","promptCard","testCases","all","length","results","shouldStop","testStartTime","testExecutionId","testExecutionTime","push","testError","errorResult","totalExecutionTime","passedTests","filter","r","failedTests","overallPassed","batchResult","prompt_card_id","total_tests","passed_tests","failed_tests","overall_passed","page","query","limit","offset","totalResult","totalPages","Math","ceil","total","map","Boolean","pagination","hasNext","hasPrev","test_case_ids","configuration","max_concurrent_tests","timeout_per_test","retry_failed_tests","max_retries","resource_limits","memory_mb","cpu_percent","priority","Array","isArray","placeholders","join","queueManager","app","locals","queueTestExecution","progressService","progress","getProgress","reason","cancelTestExecution","stats","getQueueStats","activeExecutions","getActiveExecutions"],"mappings":"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"}