35c6815811d774730dc76edb17863025
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get blacklistToken () {
        return blacklistToken;
    },
    get cleanupBlacklist () {
        return cleanupBlacklist;
    },
    get cleanupExpiredSessions () {
        return cleanupExpiredSessions;
    },
    get enhancedLogout () {
        return enhancedLogout;
    },
    get generateTokens () {
        return generateTokens;
    },
    get getActiveSessions () {
        return getActiveSessions;
    },
    get getAuthStats () {
        return getAuthStats;
    },
    get hashPassword () {
        return hashPassword;
    },
    get logout () {
        return logout;
    },
    get optionalAuth () {
        return optionalAuth;
    },
    get refreshToken () {
        return refreshToken;
    },
    get requirePermission () {
        return requirePermission;
    },
    get requireRole () {
        return requireRole;
    },
    get revokeAllUserSessions () {
        return revokeAllUserSessions;
    },
    get revokeSession () {
        return revokeSession;
    },
    get verifyPassword () {
        return verifyPassword;
    },
    get verifyToken () {
        return verifyToken;
    }
});
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
const _structuredLogging = require("./structuredLogging");
const _crypto = require("crypto");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// JWT Secret keys
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-super-secret-refresh-key-change-in-production';
const JWT_EXPIRY = process.env.JWT_EXPIRY || '15m';
const JWT_REFRESH_EXPIRY = process.env.JWT_REFRESH_EXPIRY || '7d';
// In-memory blacklist for revoked tokens (use Redis in production)
const blacklistedTokens = new Set();
// Active sessions tracking for enhanced security
const activeSessions = new Map();
const generateTokens = (payload, req)=>{
    const jti = (0, _crypto.randomBytes)(16).toString('hex'); // Unique token ID
    const sessionId = (0, _crypto.randomBytes)(16).toString('hex');
    const fingerprint = req ? generateFingerprint(req) : '';
    const ipAddress = req?.ip || '';
    const enhancedPayload = {
        ...payload,
        sessionId,
        fingerprint,
        ipAddress,
        jti
    };
    const accessToken = _jsonwebtoken.default.sign(enhancedPayload, JWT_SECRET, {
        expiresIn: JWT_EXPIRY,
        jwtid: jti
    });
    const refreshToken = _jsonwebtoken.default.sign(enhancedPayload, JWT_REFRESH_SECRET, {
        expiresIn: JWT_REFRESH_EXPIRY,
        jwtid: `${jti}_refresh`
    });
    // Track active session
    if (req) {
        activeSessions.set(sessionId, {
            userId: payload.id,
            sessionId,
            fingerprint,
            ipAddress,
            lastActivity: new Date(),
            userAgent: req.headers['user-agent'] || 'unknown'
        });
    }
    return {
        accessToken,
        refreshToken,
        sessionId
    };
};
// Generate browser fingerprint for additional security
function generateFingerprint(req) {
    const components = [
        req.headers['user-agent'] || '',
        req.headers['accept-language'] || '',
        req.headers['accept-encoding'] || '',
        req.headers['accept'] || ''
    ];
    return Buffer.from(components.join('|')).toString('base64').substring(0, 16);
}
const hashPassword = async (password)=>{
    const saltRounds = 12;
    return _bcryptjs.default.hash(password, saltRounds);
};
const verifyPassword = async (password, hashedPassword)=>{
    return _bcryptjs.default.compare(password, hashedPassword);
};
const verifyToken = (req, res, next)=>{
    try {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            (0, _structuredLogging.logSecurityEvent)('auth_failure', req, {
                reason: 'No token provided'
            });
            res.status(401).json({
                success: false,
                error: 'Access denied. No token provided or invalid format.',
                code: 'NO_TOKEN'
            });
            return;
        }
        const token = authHeader.substring(7); // Remove 'Bearer ' prefix
        // Check if token is blacklisted
        if (blacklistedTokens.has(token)) {
            (0, _structuredLogging.logSecurityEvent)('auth_failure', req, {
                reason: 'Token revoked'
            });
            res.status(401).json({
                success: false,
                error: 'Token has been revoked.',
                code: 'TOKEN_REVOKED'
            });
            return;
        }
        // Verify token
        const decoded = _jsonwebtoken.default.verify(token, JWT_SECRET);
        // Enhanced security checks
        const currentFingerprint = generateFingerprint(req);
        const currentIp = req.ip;
        // Check fingerprint consistency (if present in token)
        if (decoded.fingerprint && decoded.fingerprint !== currentFingerprint) {
            (0, _structuredLogging.logSecurityEvent)('suspicious_activity', req, {
                reason: 'Fingerprint mismatch',
                tokenFingerprint: decoded.fingerprint,
                currentFingerprint,
                userId: decoded.id
            });
            // Allow but log suspicious activity
            console.warn(`Fingerprint mismatch for user ${decoded.id}: token=${decoded.fingerprint}, current=${currentFingerprint}`);
        }
        // Check IP consistency with tolerance for reasonable changes
        if (decoded.ipAddress && decoded.ipAddress !== currentIp) {
            (0, _structuredLogging.logSecurityEvent)('suspicious_activity', req, {
                reason: 'IP address change',
                tokenIp: decoded.ipAddress,
                currentIp,
                userId: decoded.id
            });
            // Log but allow (users may change networks)
            console.warn(`IP change for user ${decoded.id}: token=${decoded.ipAddress}, current=${currentIp}`);
        }
        // Update session activity if session exists
        if (decoded.sessionId) {
            const session = activeSessions.get(decoded.sessionId);
            if (session) {
                session.lastActivity = new Date();
                session.ipAddress = currentIp || session.ipAddress;
            }
        }
        req.user = decoded;
        (0, _structuredLogging.logSecurityEvent)('auth_success', req, {
            userId: decoded.id,
            role: decoded.role
        });
        next();
    } catch (error) {
        const errorDetails = {
            error: error instanceof Error ? error.message : 'Unknown error'
        };
        if (error instanceof _jsonwebtoken.default.TokenExpiredError) {
            (0, _structuredLogging.logSecurityEvent)('auth_failure', req, {
                ...errorDetails,
                reason: 'Token expired'
            });
            res.status(401).json({
                success: false,
                error: 'Token has expired.',
                code: 'TOKEN_EXPIRED'
            });
        } else if (error instanceof _jsonwebtoken.default.JsonWebTokenError) {
            (0, _structuredLogging.logSecurityEvent)('auth_failure', req, {
                ...errorDetails,
                reason: 'Invalid token'
            });
            res.status(401).json({
                success: false,
                error: 'Invalid token.',
                code: 'INVALID_TOKEN'
            });
        } else {
            (0, _structuredLogging.logSecurityEvent)('auth_failure', req, {
                ...errorDetails,
                reason: 'Token verification error'
            });
            res.status(500).json({
                success: false,
                error: 'Token verification failed.',
                code: 'TOKEN_VERIFICATION_ERROR'
            });
        }
    }
};
const optionalAuth = (req, res, next)=>{
    try {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            next();
            return;
        }
        const token = authHeader.substring(7);
        if (!blacklistedTokens.has(token)) {
            const decoded = _jsonwebtoken.default.verify(token, JWT_SECRET);
            req.user = decoded;
        }
        next();
    } catch (error) {
        // Ignore token errors in optional auth
        next();
    }
};
const requireRole = (allowedRoles)=>{
    return (req, res, next)=>{
        if (!req.user) {
            res.status(401).json({
                success: false,
                error: 'Authentication required.',
                code: 'AUTH_REQUIRED'
            });
            return;
        }
        if (!allowedRoles.includes(req.user.role)) {
            res.status(403).json({
                success: false,
                error: `Access denied. Required roles: ${allowedRoles.join(', ')}`,
                code: 'INSUFFICIENT_ROLE'
            });
            return;
        }
        next();
    };
};
const requirePermission = (requiredPermissions)=>{
    return (req, res, next)=>{
        if (!req.user) {
            res.status(401).json({
                success: false,
                error: 'Authentication required.',
                code: 'AUTH_REQUIRED'
            });
            return;
        }
        const hasPermission = requiredPermissions.some((permission)=>req.user.permissions.includes(permission));
        if (!hasPermission) {
            res.status(403).json({
                success: false,
                error: `Access denied. Required permissions: ${requiredPermissions.join(', ')}`,
                code: 'INSUFFICIENT_PERMISSIONS'
            });
            return;
        }
        next();
    };
};
const refreshToken = (req, res, next)=>{
    try {
        const { refreshToken } = req.body;
        if (!refreshToken) {
            res.status(401).json({
                success: false,
                error: 'Refresh token required.',
                code: 'NO_REFRESH_TOKEN'
            });
            return;
        }
        // Check if refresh token is blacklisted
        if (blacklistedTokens.has(refreshToken)) {
            res.status(401).json({
                success: false,
                error: 'Refresh token has been revoked.',
                code: 'REFRESH_TOKEN_REVOKED'
            });
            return;
        }
        const decoded = _jsonwebtoken.default.verify(refreshToken, JWT_REFRESH_SECRET);
        // Generate new tokens
        const tokens = generateTokens({
            id: decoded.id,
            email: decoded.email,
            role: decoded.role,
            permissions: decoded.permissions
        });
        // Blacklist old refresh token
        blacklistedTokens.add(refreshToken);
        res.json({
            success: true,
            data: tokens
        });
    } catch (error) {
        if (error instanceof _jsonwebtoken.default.TokenExpiredError) {
            res.status(401).json({
                success: false,
                error: 'Refresh token has expired.',
                code: 'REFRESH_TOKEN_EXPIRED'
            });
        } else if (error instanceof _jsonwebtoken.default.JsonWebTokenError) {
            res.status(401).json({
                success: false,
                error: 'Invalid refresh token.',
                code: 'INVALID_REFRESH_TOKEN'
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Token refresh failed.',
                code: 'TOKEN_REFRESH_ERROR'
            });
        }
    }
};
const blacklistToken = (token)=>{
    blacklistedTokens.add(token);
};
const logout = (req, res)=>{
    try {
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const token = authHeader.substring(7);
            blacklistToken(token);
        }
        // Also blacklist refresh token if provided
        const { refreshToken } = req.body;
        if (refreshToken) {
            blacklistToken(refreshToken);
        }
        res.json({
            success: true,
            message: 'Logged out successfully'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: 'Logout failed'
        });
    }
};
const getActiveSessions = (userId)=>{
    const sessions = Array.from(activeSessions.values());
    return userId ? sessions.filter((session)=>session.userId === userId) : sessions;
};
const revokeSession = (sessionId)=>{
    return activeSessions.delete(sessionId);
};
const revokeAllUserSessions = (userId)=>{
    let revokedCount = 0;
    for (const [sessionId, session] of activeSessions.entries()){
        if (session.userId === userId) {
            activeSessions.delete(sessionId);
            revokedCount++;
        }
    }
    return revokedCount;
};
const enhancedLogout = (req, res)=>{
    try {
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const token = authHeader.substring(7);
            blacklistToken(token);
            // Also revoke the session if we can decode the token
            try {
                const decoded = _jsonwebtoken.default.verify(token, JWT_SECRET);
                if (decoded.sessionId) {
                    revokeSession(decoded.sessionId);
                }
                (0, _structuredLogging.logSecurityEvent)('auth_success', req, {
                    action: 'logout',
                    userId: decoded.id,
                    sessionId: decoded.sessionId
                });
            } catch (error) {
            // Token might be invalid/expired, but that's okay for logout
            }
        }
        // Also blacklist refresh token if provided
        const { refreshToken } = req.body;
        if (refreshToken) {
            blacklistToken(refreshToken);
        }
        res.json({
            success: true,
            message: 'Logged out successfully'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: 'Logout failed'
        });
    }
};
const cleanupExpiredSessions = ()=>{
    const now = Date.now();
    const sessionTimeout = 24 * 60 * 60 * 1000; // 24 hours
    for (const [sessionId, session] of activeSessions.entries()){
        if (now - session.lastActivity.getTime() > sessionTimeout) {
            activeSessions.delete(sessionId);
        }
    }
};
const cleanupBlacklist = ()=>{
    // In a real implementation, you would check token expiration times
    // and remove expired tokens from the blacklist
    // This is a simplified version
    console.log('Cleaning up token blacklist...');
    cleanupExpiredSessions();
};
const getAuthStats = ()=>{
    const sessionsPerUser = {};
    for (const session of activeSessions.values()){
        sessionsPerUser[session.userId] = (sessionsPerUser[session.userId] || 0) + 1;
    }
    return {
        activeSessions: activeSessions.size,
        blacklistedTokens: blacklistedTokens.size,
        sessionsPerUser
    };
};
// Periodic cleanup
setInterval(()=>{
    cleanupBlacklist();
}, 60 * 60 * 1000); // Clean up every hour
