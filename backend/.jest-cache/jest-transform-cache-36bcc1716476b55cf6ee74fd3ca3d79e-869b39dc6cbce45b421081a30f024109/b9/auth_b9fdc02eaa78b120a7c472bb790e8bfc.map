{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/middleware/auth.ts"],"sourcesContent":["import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { Request, Response, NextFunction } from 'express';\nimport { logSecurityEvent } from './structuredLogging';\nimport { randomBytes } from 'crypto';\n\n// Extend Request interface to include user\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: {\n        id: string;\n        email: string;\n        role: string;\n        permissions: string[];\n      };\n    }\n  }\n}\n\nexport interface JWTPayload {\n  id: string;\n  email: string;\n  role: string;\n  permissions: string[];\n  sessionId?: string;\n  fingerprint?: string;\n  ipAddress?: string;\n  iat?: number;\n  exp?: number;\n  jti?: string; // JWT ID for tracking\n}\n\n// JWT Secret keys\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-super-secret-refresh-key-change-in-production';\nconst JWT_EXPIRY = process.env.JWT_EXPIRY || '15m';\nconst JWT_REFRESH_EXPIRY = process.env.JWT_REFRESH_EXPIRY || '7d';\n\n// In-memory blacklist for revoked tokens (use Redis in production)\nconst blacklistedTokens = new Set<string>();\n\n// Active sessions tracking for enhanced security\nconst activeSessions = new Map<string, {\n  userId: string;\n  sessionId: string;\n  fingerprint: string;\n  ipAddress: string;\n  lastActivity: Date;\n  userAgent: string;\n}>();\n\n// Token generation utilities with enhanced security\nexport const generateTokens = (payload: Omit<JWTPayload, 'iat' | 'exp' | 'jti'>, req?: Request) => {\n  const jti = randomBytes(16).toString('hex'); // Unique token ID\n  const sessionId = randomBytes(16).toString('hex');\n  const fingerprint = req ? generateFingerprint(req) : '';\n  const ipAddress = req?.ip || '';\n\n  const enhancedPayload = {\n    ...payload,\n    sessionId,\n    fingerprint,\n    ipAddress,\n    jti\n  };\n\n  const accessToken = jwt.sign(enhancedPayload as any, JWT_SECRET as string, { \n    expiresIn: JWT_EXPIRY as any,\n    jwtid: jti\n  } as any);\n  \n  const refreshToken = jwt.sign(enhancedPayload as any, JWT_REFRESH_SECRET as string, { \n    expiresIn: JWT_REFRESH_EXPIRY as any,\n    jwtid: `${jti}_refresh`\n  } as any);\n\n  // Track active session\n  if (req) {\n    activeSessions.set(sessionId, {\n      userId: payload.id,\n      sessionId,\n      fingerprint,\n      ipAddress,\n      lastActivity: new Date(),\n      userAgent: req.headers['user-agent'] || 'unknown'\n    });\n  }\n  \n  return { accessToken, refreshToken, sessionId };\n};\n\n// Generate browser fingerprint for additional security\nfunction generateFingerprint(req: Request): string {\n  const components = [\n    req.headers['user-agent'] || '',\n    req.headers['accept-language'] || '',\n    req.headers['accept-encoding'] || '',\n    req.headers['accept'] || ''\n  ];\n  \n  return Buffer.from(components.join('|')).toString('base64').substring(0, 16);\n}\n\n// Password hashing utilities\nexport const hashPassword = async (password: string): Promise<string> => {\n  const saltRounds = 12;\n  return bcrypt.hash(password, saltRounds);\n};\n\nexport const verifyPassword = async (password: string, hashedPassword: string): Promise<boolean> => {\n  return bcrypt.compare(password, hashedPassword);\n};\n\n// Enhanced JWT verification middleware with security checks\nexport const verifyToken = (req: Request, res: Response, next: NextFunction): void => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      logSecurityEvent('auth_failure', req, { reason: 'No token provided' });\n      res.status(401).json({\n        success: false,\n        error: 'Access denied. No token provided or invalid format.',\n        code: 'NO_TOKEN'\n      });\n      return;\n    }\n\n    const token = authHeader.substring(7); // Remove 'Bearer ' prefix\n    \n    // Check if token is blacklisted\n    if (blacklistedTokens.has(token)) {\n      logSecurityEvent('auth_failure', req, { reason: 'Token revoked' });\n      res.status(401).json({\n        success: false,\n        error: 'Token has been revoked.',\n        code: 'TOKEN_REVOKED'\n      });\n      return;\n    }\n\n    // Verify token\n    const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;\n    \n    // Enhanced security checks\n    const currentFingerprint = generateFingerprint(req);\n    const currentIp = req.ip;\n\n    // Check fingerprint consistency (if present in token)\n    if (decoded.fingerprint && decoded.fingerprint !== currentFingerprint) {\n      logSecurityEvent('suspicious_activity', req, { \n        reason: 'Fingerprint mismatch',\n        tokenFingerprint: decoded.fingerprint,\n        currentFingerprint,\n        userId: decoded.id\n      });\n      \n      // Allow but log suspicious activity\n      console.warn(`Fingerprint mismatch for user ${decoded.id}: token=${decoded.fingerprint}, current=${currentFingerprint}`);\n    }\n\n    // Check IP consistency with tolerance for reasonable changes\n    if (decoded.ipAddress && decoded.ipAddress !== currentIp) {\n      logSecurityEvent('suspicious_activity', req, { \n        reason: 'IP address change',\n        tokenIp: decoded.ipAddress,\n        currentIp,\n        userId: decoded.id\n      });\n      \n      // Log but allow (users may change networks)\n      console.warn(`IP change for user ${decoded.id}: token=${decoded.ipAddress}, current=${currentIp}`);\n    }\n\n    // Update session activity if session exists\n    if (decoded.sessionId) {\n      const session = activeSessions.get(decoded.sessionId);\n      if (session) {\n        session.lastActivity = new Date();\n        session.ipAddress = currentIp || session.ipAddress;\n      }\n    }\n\n    req.user = decoded;\n    logSecurityEvent('auth_success', req, { userId: decoded.id, role: decoded.role });\n    next();\n  } catch (error) {\n    const errorDetails = { error: error instanceof Error ? error.message : 'Unknown error' };\n    \n    if (error instanceof jwt.TokenExpiredError) {\n      logSecurityEvent('auth_failure', req, { ...errorDetails, reason: 'Token expired' });\n      res.status(401).json({\n        success: false,\n        error: 'Token has expired.',\n        code: 'TOKEN_EXPIRED'\n      });\n    } else if (error instanceof jwt.JsonWebTokenError) {\n      logSecurityEvent('auth_failure', req, { ...errorDetails, reason: 'Invalid token' });\n      res.status(401).json({\n        success: false,\n        error: 'Invalid token.',\n        code: 'INVALID_TOKEN'\n      });\n    } else {\n      logSecurityEvent('auth_failure', req, { ...errorDetails, reason: 'Token verification error' });\n      res.status(500).json({\n        success: false,\n        error: 'Token verification failed.',\n        code: 'TOKEN_VERIFICATION_ERROR'\n      });\n    }\n  }\n};\n\n// Optional authentication middleware (doesn't fail if no token)\nexport const optionalAuth = (req: Request, res: Response, next: NextFunction): void => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      next();\n      return;\n    }\n\n    const token = authHeader.substring(7);\n    \n    if (!blacklistedTokens.has(token)) {\n      const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;\n      req.user = decoded;\n    }\n    \n    next();\n  } catch (error) {\n    // Ignore token errors in optional auth\n    next();\n  }\n};\n\n// Role-based access control middleware\nexport const requireRole = (allowedRoles: string[]) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(401).json({\n        success: false,\n        error: 'Authentication required.',\n        code: 'AUTH_REQUIRED'\n      });\n      return;\n    }\n\n    if (!allowedRoles.includes(req.user.role)) {\n      res.status(403).json({\n        success: false,\n        error: `Access denied. Required roles: ${allowedRoles.join(', ')}`,\n        code: 'INSUFFICIENT_ROLE'\n      });\n      return;\n    }\n\n    next();\n  };\n};\n\n// Permission-based access control middleware\nexport const requirePermission = (requiredPermissions: string[]) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(401).json({\n        success: false,\n        error: 'Authentication required.',\n        code: 'AUTH_REQUIRED'\n      });\n      return;\n    }\n\n    const hasPermission = requiredPermissions.some(permission => \n      req.user!.permissions.includes(permission)\n    );\n\n    if (!hasPermission) {\n      res.status(403).json({\n        success: false,\n        error: `Access denied. Required permissions: ${requiredPermissions.join(', ')}`,\n        code: 'INSUFFICIENT_PERMISSIONS'\n      });\n      return;\n    }\n\n    next();\n  };\n};\n\n// Refresh token middleware\nexport const refreshToken = (req: Request, res: Response, next: NextFunction): void => {\n  try {\n    const { refreshToken } = req.body;\n    \n    if (!refreshToken) {\n      res.status(401).json({\n        success: false,\n        error: 'Refresh token required.',\n        code: 'NO_REFRESH_TOKEN'\n      });\n      return;\n    }\n\n    // Check if refresh token is blacklisted\n    if (blacklistedTokens.has(refreshToken)) {\n      res.status(401).json({\n        success: false,\n        error: 'Refresh token has been revoked.',\n        code: 'REFRESH_TOKEN_REVOKED'\n      });\n      return;\n    }\n\n    const decoded = jwt.verify(refreshToken, JWT_REFRESH_SECRET) as JWTPayload;\n    \n    // Generate new tokens\n    const tokens = generateTokens({\n      id: decoded.id,\n      email: decoded.email,\n      role: decoded.role,\n      permissions: decoded.permissions\n    });\n\n    // Blacklist old refresh token\n    blacklistedTokens.add(refreshToken);\n\n    res.json({\n      success: true,\n      data: tokens\n    });\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      res.status(401).json({\n        success: false,\n        error: 'Refresh token has expired.',\n        code: 'REFRESH_TOKEN_EXPIRED'\n      });\n    } else if (error instanceof jwt.JsonWebTokenError) {\n      res.status(401).json({\n        success: false,\n        error: 'Invalid refresh token.',\n        code: 'INVALID_REFRESH_TOKEN'\n      });\n    } else {\n      res.status(500).json({\n        success: false,\n        error: 'Token refresh failed.',\n        code: 'TOKEN_REFRESH_ERROR'\n      });\n    }\n  }\n};\n\n// Token blacklisting utilities\nexport const blacklistToken = (token: string): void => {\n  blacklistedTokens.add(token);\n};\n\nexport const logout = (req: Request, res: Response): void => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      const token = authHeader.substring(7);\n      blacklistToken(token);\n    }\n\n    // Also blacklist refresh token if provided\n    const { refreshToken } = req.body;\n    if (refreshToken) {\n      blacklistToken(refreshToken);\n    }\n\n    res.json({\n      success: true,\n      message: 'Logged out successfully'\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      error: 'Logout failed'\n    });\n  }\n};\n\n// Session management functions\nexport const getActiveSessions = (userId?: string): Array<{\n  sessionId: string;\n  userId: string;\n  fingerprint: string;\n  ipAddress: string;\n  lastActivity: Date;\n  userAgent: string;\n}> => {\n  const sessions = Array.from(activeSessions.values());\n  return userId ? sessions.filter(session => session.userId === userId) : sessions;\n};\n\nexport const revokeSession = (sessionId: string): boolean => {\n  return activeSessions.delete(sessionId);\n};\n\nexport const revokeAllUserSessions = (userId: string): number => {\n  let revokedCount = 0;\n  for (const [sessionId, session] of activeSessions.entries()) {\n    if (session.userId === userId) {\n      activeSessions.delete(sessionId);\n      revokedCount++;\n    }\n  }\n  return revokedCount;\n};\n\n// Enhanced logout with session cleanup\nexport const enhancedLogout = (req: Request, res: Response): void => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      const token = authHeader.substring(7);\n      blacklistToken(token);\n      \n      // Also revoke the session if we can decode the token\n      try {\n        const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;\n        if (decoded.sessionId) {\n          revokeSession(decoded.sessionId);\n        }\n        logSecurityEvent('auth_success', req, { \n          action: 'logout',\n          userId: decoded.id,\n          sessionId: decoded.sessionId\n        });\n      } catch (error) {\n        // Token might be invalid/expired, but that's okay for logout\n      }\n    }\n\n    // Also blacklist refresh token if provided\n    const { refreshToken } = req.body;\n    if (refreshToken) {\n      blacklistToken(refreshToken);\n    }\n\n    res.json({\n      success: true,\n      message: 'Logged out successfully'\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      error: 'Logout failed'\n    });\n  }\n};\n\n// Clean up expired sessions and tokens\nexport const cleanupExpiredSessions = (): void => {\n  const now = Date.now();\n  const sessionTimeout = 24 * 60 * 60 * 1000; // 24 hours\n  \n  for (const [sessionId, session] of activeSessions.entries()) {\n    if (now - session.lastActivity.getTime() > sessionTimeout) {\n      activeSessions.delete(sessionId);\n    }\n  }\n};\n\n// Clean up expired tokens from blacklist (should be run periodically)\nexport const cleanupBlacklist = (): void => {\n  // In a real implementation, you would check token expiration times\n  // and remove expired tokens from the blacklist\n  // This is a simplified version\n  console.log('Cleaning up token blacklist...');\n  cleanupExpiredSessions();\n};\n\n// Security monitoring and statistics\nexport const getAuthStats = (): {\n  activeSessions: number;\n  blacklistedTokens: number;\n  sessionsPerUser: Record<string, number>;\n} => {\n  const sessionsPerUser: Record<string, number> = {};\n  \n  for (const session of activeSessions.values()) {\n    sessionsPerUser[session.userId] = (sessionsPerUser[session.userId] || 0) + 1;\n  }\n\n  return {\n    activeSessions: activeSessions.size,\n    blacklistedTokens: blacklistedTokens.size,\n    sessionsPerUser\n  };\n};\n\n// Periodic cleanup\nsetInterval(() => {\n  cleanupBlacklist();\n}, 60 * 60 * 1000); // Clean up every hour"],"names":["blacklistToken","cleanupBlacklist","cleanupExpiredSessions","enhancedLogout","generateTokens","getActiveSessions","getAuthStats","hashPassword","logout","optionalAuth","refreshToken","requirePermission","requireRole","revokeAllUserSessions","revokeSession","verifyPassword","verifyToken","JWT_SECRET","process","env","JWT_REFRESH_SECRET","JWT_EXPIRY","JWT_REFRESH_EXPIRY","blacklistedTokens","Set","activeSessions","Map","payload","req","jti","randomBytes","toString","sessionId","fingerprint","generateFingerprint","ipAddress","ip","enhancedPayload","accessToken","jwt","sign","expiresIn","jwtid","set","userId","id","lastActivity","Date","userAgent","headers","components","Buffer","from","join","substring","password","saltRounds","bcrypt","hash","hashedPassword","compare","res","next","authHeader","authorization","startsWith","logSecurityEvent","reason","status","json","success","error","code","token","has","decoded","verify","currentFingerprint","currentIp","tokenFingerprint","console","warn","tokenIp","session","get","user","role","errorDetails","Error","message","TokenExpiredError","JsonWebTokenError","allowedRoles","includes","requiredPermissions","hasPermission","some","permission","permissions","body","tokens","email","add","data","sessions","Array","values","filter","delete","revokedCount","entries","action","now","sessionTimeout","getTime","log","sessionsPerUser","size","setInterval"],"mappings":"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"}