93e9925ef998ffacd4c18b75be4c80b8
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get CircuitBreaker () {
        return CircuitBreaker;
    },
    get CircuitBreakerRegistry () {
        return CircuitBreakerRegistry;
    },
    get CircuitBreakerState () {
        return CircuitBreakerState;
    },
    get circuitBreakerRegistry () {
        return circuitBreakerRegistry;
    }
});
const _events = require("events");
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
var CircuitBreakerState = /*#__PURE__*/ function(CircuitBreakerState) {
    CircuitBreakerState["CLOSED"] = "CLOSED";
    CircuitBreakerState["OPEN"] = "OPEN";
    CircuitBreakerState["HALF_OPEN"] = "HALF_OPEN"; // Testing if service has recovered
    return CircuitBreakerState;
}({});
class CircuitBreaker extends _events.EventEmitter {
    async execute(fn) {
        this.totalRequests++;
        if (this.state === "OPEN") {
            if (this.shouldAttemptReset()) {
                this.state = "HALF_OPEN";
                this.successCount = 0;
                console.log(`ğŸ”„ Circuit breaker for ${this.serviceName} moved to HALF_OPEN`);
                this.emit('stateChanged', {
                    serviceName: this.serviceName,
                    state: this.state,
                    reason: 'Reset timeout elapsed'
                });
            } else {
                const error = new Error(`Circuit breaker OPEN for ${this.serviceName}. Next attempt: ${this.nextAttempt}`);
                this.emit('requestRejected', {
                    serviceName: this.serviceName,
                    reason: 'Circuit breaker open',
                    nextAttempt: this.nextAttempt
                });
                throw error;
            }
        }
        try {
            const result = await fn();
            this.onSuccess();
            return result;
        } catch (error) {
            this.onFailure(error);
            throw error;
        }
    }
    onSuccess() {
        this.totalSuccesses++;
        this.lastSuccess = new Date();
        if (this.state === "HALF_OPEN") {
            this.successCount++;
            if (this.successCount >= this.config.successThreshold) {
                this.reset();
            }
        } else if (this.state === "CLOSED") {
            this.failureCount = 0; // Reset failure count on success
        }
        this.emit('success', {
            serviceName: this.serviceName,
            state: this.state,
            successCount: this.successCount
        });
    }
    onFailure(error) {
        this.totalFailures++;
        this.lastFailure = new Date();
        this.failureCount++;
        this.emit('failure', {
            serviceName: this.serviceName,
            state: this.state,
            failureCount: this.failureCount,
            error: error instanceof Error ? error.message : 'Unknown error'
        });
        if (this.state === "HALF_OPEN") {
            // Any failure in half-open state moves back to open
            this.trip();
        } else if (this.state === "CLOSED") {
            if (this.failureCount >= this.config.failureThreshold) {
                this.trip();
            }
        }
    }
    trip() {
        this.state = "OPEN";
        this.nextAttempt = new Date(Date.now() + this.config.resetTimeout);
        console.log(`ğŸš¨ Circuit breaker OPENED for ${this.serviceName}. Next attempt: ${this.nextAttempt}`);
        this.emit('opened', {
            serviceName: this.serviceName,
            failureCount: this.failureCount,
            nextAttempt: this.nextAttempt,
            reason: `Failure threshold reached (${this.config.failureThreshold} failures)`
        });
    }
    reset() {
        this.state = "CLOSED";
        this.failureCount = 0;
        this.successCount = 0;
        this.nextAttempt = null;
        console.log(`âœ… Circuit breaker CLOSED for ${this.serviceName} - Service recovered`);
        this.emit('closed', {
            serviceName: this.serviceName,
            reason: `Service recovered (${this.config.successThreshold} successful requests)`
        });
    }
    shouldAttemptReset() {
        return this.nextAttempt !== null && new Date() >= this.nextAttempt;
    }
    getStats() {
        return {
            state: this.state,
            failureCount: this.failureCount,
            successCount: this.successCount,
            nextAttempt: this.nextAttempt,
            totalRequests: this.totalRequests,
            totalFailures: this.totalFailures,
            totalSuccesses: this.totalSuccesses,
            uptime: Date.now() - this.startTime.getTime(),
            lastFailure: this.lastFailure,
            lastSuccess: this.lastSuccess
        };
    }
    forceOpen() {
        this.state = "OPEN";
        this.nextAttempt = new Date(Date.now() + this.config.resetTimeout);
        console.log(`ğŸ”§ Circuit breaker MANUALLY OPENED for ${this.serviceName}`);
        this.emit('forceOpened', {
            serviceName: this.serviceName,
            reason: 'Manual intervention'
        });
    }
    forceClose() {
        this.reset();
        console.log(`ğŸ”§ Circuit breaker MANUALLY CLOSED for ${this.serviceName}`);
        this.emit('forceClosed', {
            serviceName: this.serviceName,
            reason: 'Manual intervention'
        });
    }
    updateConfig(newConfig) {
        this.config = {
            ...this.config,
            ...newConfig
        };
        this.emit('configUpdated', {
            serviceName: this.serviceName,
            config: this.config
        });
    }
    constructor(serviceName, config = {}){
        super(), _define_property(this, "state", "CLOSED"), _define_property(this, "failureCount", 0), _define_property(this, "successCount", 0), _define_property(this, "nextAttempt", null), _define_property(this, "config", void 0), _define_property(this, "serviceName", void 0), // Statistics
        _define_property(this, "totalRequests", 0), _define_property(this, "totalFailures", 0), _define_property(this, "totalSuccesses", 0), _define_property(this, "lastFailure", null), _define_property(this, "lastSuccess", null), _define_property(this, "startTime", new Date());
        this.serviceName = serviceName;
        this.config = {
            failureThreshold: 5,
            resetTimeout: 60000,
            monitoringPeriod: 300000,
            successThreshold: 3,
            ...config
        };
    }
}
class CircuitBreakerRegistry {
    getBreaker(serviceName, config) {
        if (!this.breakers.has(serviceName)) {
            const breaker = new CircuitBreaker(serviceName, config);
            this.breakers.set(serviceName, breaker);
            // Forward events
            breaker.on('opened', (data)=>this.emit('breakerOpened', data));
            breaker.on('closed', (data)=>this.emit('breakerClosed', data));
            breaker.on('stateChanged', (data)=>this.emit('breakerStateChanged', data));
            breaker.on('failure', (data)=>this.emit('breakerFailure', data));
            breaker.on('success', (data)=>this.emit('breakerSuccess', data));
        }
        return this.breakers.get(serviceName);
    }
    getAllBreakers() {
        return new Map(this.breakers);
    }
    getStats() {
        const stats = {};
        for (const [serviceName, breaker] of this.breakers){
            stats[serviceName] = breaker.getStats();
        }
        return stats;
    }
    removeBreaker(serviceName) {
        return this.breakers.delete(serviceName);
    }
    clear() {
        this.breakers.clear();
    }
    on(event, listener) {
        this.eventEmitter.on(event, listener);
        return this;
    }
    emit(event, ...args) {
        return this.eventEmitter.emit(event, ...args);
    }
    off(event, listener) {
        this.eventEmitter.off(event, listener);
        return this;
    }
    constructor(){
        _define_property(this, "breakers", new Map());
        // Event emitter functionality
        _define_property(this, "eventEmitter", new _events.EventEmitter());
    }
}
const circuitBreakerRegistry = new CircuitBreakerRegistry();
