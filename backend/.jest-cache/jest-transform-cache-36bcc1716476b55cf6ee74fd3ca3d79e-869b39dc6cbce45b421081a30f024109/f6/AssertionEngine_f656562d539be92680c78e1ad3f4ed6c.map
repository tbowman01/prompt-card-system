{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/services/assertions/AssertionEngine.ts"],"sourcesContent":["import { AssertionType } from '../../types/testCase';\nimport { AssertionResult } from '../../types/testExecution';\nimport { SemanticSimilarityValidator } from './SemanticSimilarityValidator';\nimport { CustomAssertionValidator } from './CustomAssertionValidator';\nimport { AssertionTypeRegistry } from './AssertionTypeRegistry';\n\nexport interface EnhancedAssertionType extends AssertionType {\n  type: 'contains' | 'not-contains' | 'equals' | 'not-equals' | 'regex' | 'length' | \n        'semantic-similarity' | 'custom' | 'json-schema' | 'sentiment' | 'language' | 'toxicity';\n  value: string | number | object;\n  description?: string;\n  threshold?: number; // For semantic similarity, sentiment, etc.\n  config?: Record<string, any>; // Additional configuration\n}\n\nexport interface AssertionContext {\n  prompt: string;\n  variables: Record<string, any>;\n  model: string;\n  executionTime: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface EnhancedAssertionResult {\n  assertion: EnhancedAssertionType;\n  passed: boolean;\n  error?: string;\n  score?: number; // For scoring-based assertions\n  metadata?: Record<string, any>;\n  executionTime?: number;\n}\n\nexport class AssertionEngine {\n  private semanticValidator: SemanticSimilarityValidator;\n  private customValidator: CustomAssertionValidator;\n  private typeRegistry: AssertionTypeRegistry;\n\n  constructor() {\n    this.semanticValidator = new SemanticSimilarityValidator();\n    this.customValidator = new CustomAssertionValidator();\n    this.typeRegistry = new AssertionTypeRegistry();\n  }\n\n  /**\n   * Initialize the assertion engine with ML models\n   */\n  async initialize(): Promise<void> {\n    console.log('Initializing Enhanced Assertion Engine...');\n    \n    try {\n      await this.semanticValidator.initialize();\n      await this.customValidator.initialize();\n      await this.typeRegistry.initialize();\n      \n      console.log('✅ Enhanced Assertion Engine initialized successfully');\n    } catch (error) {\n      console.error('❌ Failed to initialize Enhanced Assertion Engine:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Validate all assertions against LLM output with enhanced context\n   */\n  async validateAssertions(\n    output: string,\n    assertions: EnhancedAssertionType[],\n    context?: AssertionContext\n  ): Promise<EnhancedAssertionResult[]> {\n    const results: EnhancedAssertionResult[] = [];\n    \n    for (const assertion of assertions) {\n      const startTime = Date.now();\n      \n      try {\n        const result = await this.validateSingleAssertion(output, assertion, context);\n        result.executionTime = Date.now() - startTime;\n        results.push(result);\n      } catch (error) {\n        results.push({\n          assertion,\n          passed: false,\n          error: error instanceof Error ? error.message : 'Unknown assertion error',\n          executionTime: Date.now() - startTime\n        });\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Validate a single assertion with enhanced capabilities\n   */\n  private async validateSingleAssertion(\n    output: string,\n    assertion: EnhancedAssertionType,\n    context?: AssertionContext\n  ): Promise<EnhancedAssertionResult> {\n    switch (assertion.type) {\n      case 'contains':\n        return this.validateContains(output, assertion);\n      \n      case 'not-contains':\n        return this.validateNotContains(output, assertion);\n      \n      case 'equals':\n        return this.validateEquals(output, assertion);\n      \n      case 'not-equals':\n        return this.validateNotEquals(output, assertion);\n      \n      case 'regex':\n        return this.validateRegex(output, assertion);\n      \n      case 'length':\n        return this.validateLength(output, assertion);\n      \n      case 'semantic-similarity':\n        return await this.validateSemanticSimilarity(output, assertion, context);\n      \n      case 'custom':\n        return await this.validateCustom(output, assertion, context);\n      \n      case 'json-schema':\n        return this.validateJsonSchema(output, assertion);\n      \n      case 'sentiment':\n        return await this.validateSentiment(output, assertion);\n      \n      case 'language':\n        return await this.validateLanguage(output, assertion);\n      \n      case 'toxicity':\n        return await this.validateToxicity(output, assertion);\n      \n      default:\n        throw new Error(`Unknown assertion type: ${assertion.type}`);\n    }\n  }\n\n  /**\n   * Basic string contains validation\n   */\n  private validateContains(output: string, assertion: EnhancedAssertionType): EnhancedAssertionResult {\n    const searchValue = String(assertion.value);\n    const passed = output.toLowerCase().includes(searchValue.toLowerCase());\n    \n    return {\n      assertion,\n      passed,\n      metadata: {\n        searchValue,\n        outputLength: output.length,\n        caseSensitive: false\n      }\n    };\n  }\n\n  /**\n   * Basic string not-contains validation\n   */\n  private validateNotContains(output: string, assertion: EnhancedAssertionType): EnhancedAssertionResult {\n    const searchValue = String(assertion.value);\n    const passed = !output.toLowerCase().includes(searchValue.toLowerCase());\n    \n    return {\n      assertion,\n      passed,\n      metadata: {\n        searchValue,\n        outputLength: output.length,\n        caseSensitive: false\n      }\n    };\n  }\n\n  /**\n   * Exact string equality validation\n   */\n  private validateEquals(output: string, assertion: EnhancedAssertionType): EnhancedAssertionResult {\n    const expectedValue = String(assertion.value);\n    const passed = output.trim() === expectedValue.trim();\n    \n    return {\n      assertion,\n      passed,\n      metadata: {\n        expectedValue,\n        actualValue: output.trim(),\n        exactMatch: passed\n      }\n    };\n  }\n\n  /**\n   * String inequality validation\n   */\n  private validateNotEquals(output: string, assertion: EnhancedAssertionType): EnhancedAssertionResult {\n    const expectedValue = String(assertion.value);\n    const passed = output.trim() !== expectedValue.trim();\n    \n    return {\n      assertion,\n      passed,\n      metadata: {\n        expectedValue,\n        actualValue: output.trim(),\n        exactMatch: !passed\n      }\n    };\n  }\n\n  /**\n   * Regular expression validation\n   */\n  private validateRegex(output: string, assertion: EnhancedAssertionType): EnhancedAssertionResult {\n    try {\n      const regex = new RegExp(String(assertion.value), assertion.config?.flags || '');\n      const matches = output.match(regex);\n      const passed = matches !== null;\n      \n      return {\n        assertion,\n        passed,\n        metadata: {\n          pattern: String(assertion.value),\n          flags: assertion.config?.flags || '',\n          matches: matches || [],\n          matchCount: matches?.length || 0\n        }\n      };\n    } catch (error) {\n      return {\n        assertion,\n        passed: false,\n        error: `Invalid regex pattern: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        metadata: {\n          pattern: String(assertion.value)\n        }\n      };\n    }\n  }\n\n  /**\n   * String length validation with range support\n   */\n  private validateLength(output: string, assertion: EnhancedAssertionType): EnhancedAssertionResult {\n    const actualLength = output.length;\n    let passed = false;\n    const metadata: Record<string, any> = {\n      actualLength,\n      constraint: assertion.value\n    };\n\n    if (typeof assertion.value === 'number') {\n      passed = actualLength === assertion.value;\n    } else {\n      const valueStr = String(assertion.value);\n      if (valueStr.includes('-')) {\n        const [minStr, maxStr] = valueStr.split('-');\n        const min = parseInt(minStr.trim());\n        const max = parseInt(maxStr.trim());\n        passed = actualLength >= min && actualLength <= max;\n        metadata.min = min;\n        metadata.max = max;\n        metadata.inRange = passed;\n      } else if (valueStr.startsWith('>')) {\n        const min = parseInt(valueStr.substring(1));\n        passed = actualLength > min;\n        metadata.min = min;\n        metadata.operator = '>';\n      } else if (valueStr.startsWith('<')) {\n        const max = parseInt(valueStr.substring(1));\n        passed = actualLength < max;\n        metadata.max = max;\n        metadata.operator = '<';\n      } else if (valueStr.startsWith('>=')) {\n        const min = parseInt(valueStr.substring(2));\n        passed = actualLength >= min;\n        metadata.min = min;\n        metadata.operator = '>=';\n      } else if (valueStr.startsWith('<=')) {\n        const max = parseInt(valueStr.substring(2));\n        passed = actualLength <= max;\n        metadata.max = max;\n        metadata.operator = '<=';\n      } else {\n        const expected = parseInt(valueStr);\n        passed = actualLength === expected;\n        metadata.expected = expected;\n      }\n    }\n\n    return {\n      assertion,\n      passed,\n      metadata\n    };\n  }\n\n  /**\n   * Semantic similarity validation using transformer models\n   */\n  private async validateSemanticSimilarity(\n    output: string,\n    assertion: EnhancedAssertionType,\n    context?: AssertionContext\n  ): Promise<EnhancedAssertionResult> {\n    try {\n      const expectedText = String(assertion.value);\n      const threshold = assertion.threshold || 0.8;\n      \n      const similarity = await this.semanticValidator.computeSimilarity(output, expectedText);\n      const passed = similarity >= threshold;\n      \n      return {\n        assertion,\n        passed,\n        score: similarity,\n        metadata: {\n          expectedText,\n          threshold,\n          similarity,\n          model: this.semanticValidator.getModelName(),\n          algorithmUsed: 'sentence-transformers'\n        }\n      };\n    } catch (error) {\n      return {\n        assertion,\n        passed: false,\n        error: `Semantic similarity validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        metadata: {\n          expectedText: String(assertion.value),\n          threshold: assertion.threshold || 0.8\n        }\n      };\n    }\n  }\n\n  /**\n   * Custom JavaScript assertion validation\n   */\n  private async validateCustom(\n    output: string,\n    assertion: EnhancedAssertionType,\n    context?: AssertionContext\n  ): Promise<EnhancedAssertionResult> {\n    try {\n      const customCode = String(assertion.value);\n      const result = await this.customValidator.execute(customCode, output, context);\n      \n      return {\n        assertion,\n        passed: result.passed,\n        score: result.score,\n        metadata: {\n          customCode,\n          executionTime: result.executionTime,\n          variables: result.variables,\n          logs: result.logs\n        }\n      };\n    } catch (error) {\n      return {\n        assertion,\n        passed: false,\n        error: `Custom assertion validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`,\n        metadata: {\n          customCode: String(assertion.value)\n        }\n      };\n    }\n  }\n\n  /**\n   * JSON schema validation\n   */\n  private validateJsonSchema(output: string, assertion: EnhancedAssertionType): EnhancedAssertionResult {\n    try {\n      const parsedOutput = JSON.parse(output);\n      const schema = assertion.value as object;\n      \n      // Simple schema validation - in a real implementation, use a proper JSON schema validator\n      const passed = this.validateObjectAgainstSchema(parsedOutput, schema);\n      \n      return {\n        assertion,\n        passed,\n        metadata: {\n          schema,\n          parsedOutput,\n          isValidJson: true\n        }\n      };\n    } catch (error) {\n      return {\n        assertion,\n        passed: false,\n        error: `JSON schema validation failed: ${error instanceof Error ? error.message : 'Invalid JSON'}`,\n        metadata: {\n          schema: assertion.value,\n          isValidJson: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Sentiment analysis validation\n   */\n  private async validateSentiment(\n    output: string,\n    assertion: EnhancedAssertionType\n  ): Promise<EnhancedAssertionResult> {\n    try {\n      const expectedSentiment = String(assertion.value); // 'positive', 'negative', 'neutral'\n      const threshold = assertion.threshold || 0.6;\n      \n      const sentiment = await this.semanticValidator.analyzeSentiment(output);\n      const passed = sentiment.label === expectedSentiment && sentiment.score >= threshold;\n      \n      return {\n        assertion,\n        passed,\n        score: sentiment.score,\n        metadata: {\n          expectedSentiment,\n          actualSentiment: sentiment.label,\n          confidence: sentiment.score,\n          threshold\n        }\n      };\n    } catch (error) {\n      return {\n        assertion,\n        passed: false,\n        error: `Sentiment validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      };\n    }\n  }\n\n  /**\n   * Language detection validation\n   */\n  private async validateLanguage(\n    output: string,\n    assertion: EnhancedAssertionType\n  ): Promise<EnhancedAssertionResult> {\n    try {\n      const expectedLanguage = String(assertion.value); // 'en', 'es', 'fr', etc.\n      \n      const language = await this.semanticValidator.detectLanguage(output);\n      const passed = language.language === expectedLanguage;\n      \n      return {\n        assertion,\n        passed,\n        score: language.confidence,\n        metadata: {\n          expectedLanguage,\n          detectedLanguage: language.language,\n          confidence: language.confidence\n        }\n      };\n    } catch (error) {\n      return {\n        assertion,\n        passed: false,\n        error: `Language validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      };\n    }\n  }\n\n  /**\n   * Toxicity detection validation\n   */\n  private async validateToxicity(\n    output: string,\n    assertion: EnhancedAssertionType\n  ): Promise<EnhancedAssertionResult> {\n    try {\n      const maxToxicity = Number(assertion.value); // 0.0 to 1.0\n      \n      const toxicity = await this.semanticValidator.detectToxicity(output);\n      const passed = toxicity.score <= maxToxicity;\n      \n      return {\n        assertion,\n        passed,\n        score: toxicity.score,\n        metadata: {\n          maxToxicity,\n          toxicityScore: toxicity.score,\n          categories: toxicity.categories,\n          isToxic: toxicity.score > 0.7\n        }\n      };\n    } catch (error) {\n      return {\n        assertion,\n        passed: false,\n        error: `Toxicity validation failed: ${error instanceof Error ? error.message : 'Unknown error'}`\n      };\n    }\n  }\n\n  /**\n   * Simple object schema validation helper\n   */\n  private validateObjectAgainstSchema(obj: any, schema: any): boolean {\n    if (typeof schema !== 'object' || schema === null) {\n      return obj === schema;\n    }\n\n    for (const key in schema) {\n      if (!(key in obj)) {\n        return false;\n      }\n      \n      if (typeof schema[key] === 'object' && schema[key] !== null) {\n        if (!this.validateObjectAgainstSchema(obj[key], schema[key])) {\n          return false;\n        }\n      } else if (typeof obj[key] !== typeof schema[key]) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Register a custom assertion type\n   */\n  async registerAssertionType(\n    name: string,\n    validator: (output: string, assertion: EnhancedAssertionType, context?: AssertionContext) => Promise<EnhancedAssertionResult>\n  ): Promise<void> {\n    await this.typeRegistry.register(name, validator);\n  }\n\n  /**\n   * Get all registered assertion types\n   */\n  getRegisteredTypes(): string[] {\n    return this.typeRegistry.getRegisteredTypes();\n  }\n\n  /**\n   * Get assertion statistics\n   */\n  getStatistics(): {\n    totalAssertions: number;\n    successfulAssertions: number;\n    failedAssertions: number;\n    averageExecutionTime: number;\n  } {\n    return this.typeRegistry.getStatistics();\n  }\n\n  /**\n   * Export assertion types to JSON\n   */\n  exportTypes(): string {\n    return this.typeRegistry.exportTypes();\n  }\n\n  /**\n   * Import assertion types from JSON\n   */\n  async importTypes(jsonData: string): Promise<void> {\n    await this.typeRegistry.importTypes(jsonData);\n  }\n\n  /**\n   * Clean up resources\n   */\n  async cleanup(): Promise<void> {\n    await this.semanticValidator.cleanup();\n    await this.customValidator.cleanup();\n    await this.typeRegistry.cleanup();\n  }\n}\n\n// The AssertionEngine class is exported for instantiation in index.ts"],"names":["AssertionEngine","initialize","console","log","semanticValidator","customValidator","typeRegistry","error","validateAssertions","output","assertions","context","results","assertion","startTime","Date","now","result","validateSingleAssertion","executionTime","push","passed","Error","message","type","validateContains","validateNotContains","validateEquals","validateNotEquals","validateRegex","validateLength","validateSemanticSimilarity","validateCustom","validateJsonSchema","validateSentiment","validateLanguage","validateToxicity","searchValue","String","value","toLowerCase","includes","metadata","outputLength","length","caseSensitive","expectedValue","trim","actualValue","exactMatch","regex","RegExp","config","flags","matches","match","pattern","matchCount","actualLength","constraint","valueStr","minStr","maxStr","split","min","parseInt","max","inRange","startsWith","substring","operator","expected","expectedText","threshold","similarity","computeSimilarity","score","model","getModelName","algorithmUsed","customCode","execute","variables","logs","parsedOutput","JSON","parse","schema","validateObjectAgainstSchema","isValidJson","expectedSentiment","sentiment","analyzeSentiment","label","actualSentiment","confidence","expectedLanguage","language","detectLanguage","detectedLanguage","maxToxicity","Number","toxicity","detectToxicity","toxicityScore","categories","isToxic","obj","key","registerAssertionType","name","validator","register","getRegisteredTypes","getStatistics","exportTypes","importTypes","jsonData","cleanup","SemanticSimilarityValidator","CustomAssertionValidator","AssertionTypeRegistry"],"mappings":"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"}