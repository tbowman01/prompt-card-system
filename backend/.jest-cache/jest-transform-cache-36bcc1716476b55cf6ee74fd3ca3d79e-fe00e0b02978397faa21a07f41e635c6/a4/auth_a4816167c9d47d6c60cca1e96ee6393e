130ff18b9868ce113434fef71ce9f3a5
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get blacklistToken () {
        return blacklistToken;
    },
    get cleanupBlacklist () {
        return cleanupBlacklist;
    },
    get generateTokens () {
        return generateTokens;
    },
    get hashPassword () {
        return hashPassword;
    },
    get logout () {
        return logout;
    },
    get optionalAuth () {
        return optionalAuth;
    },
    get refreshToken () {
        return refreshToken;
    },
    get requirePermission () {
        return requirePermission;
    },
    get requireRole () {
        return requireRole;
    },
    get verifyPassword () {
        return verifyPassword;
    },
    get verifyToken () {
        return verifyToken;
    }
});
const _jsonwebtoken = /*#__PURE__*/ _interop_require_default(require("jsonwebtoken"));
const _bcryptjs = /*#__PURE__*/ _interop_require_default(require("bcryptjs"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
// JWT Secret keys
const JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-super-secret-refresh-key-change-in-production';
const JWT_EXPIRY = process.env.JWT_EXPIRY || '15m';
const JWT_REFRESH_EXPIRY = process.env.JWT_REFRESH_EXPIRY || '7d';
// In-memory blacklist for revoked tokens (use Redis in production)
const blacklistedTokens = new Set();
const generateTokens = (payload)=>{
    const accessToken = _jsonwebtoken.default.sign(payload, JWT_SECRET, {
        expiresIn: JWT_EXPIRY
    });
    const refreshToken = _jsonwebtoken.default.sign(payload, JWT_REFRESH_SECRET, {
        expiresIn: JWT_REFRESH_EXPIRY
    });
    return {
        accessToken,
        refreshToken
    };
};
const hashPassword = async (password)=>{
    const saltRounds = 12;
    return _bcryptjs.default.hash(password, saltRounds);
};
const verifyPassword = async (password, hashedPassword)=>{
    return _bcryptjs.default.compare(password, hashedPassword);
};
const verifyToken = (req, res, next)=>{
    try {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            res.status(401).json({
                success: false,
                error: 'Access denied. No token provided or invalid format.',
                code: 'NO_TOKEN'
            });
            return;
        }
        const token = authHeader.substring(7); // Remove 'Bearer ' prefix
        // Check if token is blacklisted
        if (blacklistedTokens.has(token)) {
            res.status(401).json({
                success: false,
                error: 'Token has been revoked.',
                code: 'TOKEN_REVOKED'
            });
            return;
        }
        // Verify token
        const decoded = _jsonwebtoken.default.verify(token, JWT_SECRET);
        req.user = decoded;
        next();
    } catch (error) {
        if (error instanceof _jsonwebtoken.default.TokenExpiredError) {
            res.status(401).json({
                success: false,
                error: 'Token has expired.',
                code: 'TOKEN_EXPIRED'
            });
        } else if (error instanceof _jsonwebtoken.default.JsonWebTokenError) {
            res.status(401).json({
                success: false,
                error: 'Invalid token.',
                code: 'INVALID_TOKEN'
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Token verification failed.',
                code: 'TOKEN_VERIFICATION_ERROR'
            });
        }
    }
};
const optionalAuth = (req, res, next)=>{
    try {
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith('Bearer ')) {
            next();
            return;
        }
        const token = authHeader.substring(7);
        if (!blacklistedTokens.has(token)) {
            const decoded = _jsonwebtoken.default.verify(token, JWT_SECRET);
            req.user = decoded;
        }
        next();
    } catch (error) {
        // Ignore token errors in optional auth
        next();
    }
};
const requireRole = (allowedRoles)=>{
    return (req, res, next)=>{
        if (!req.user) {
            res.status(401).json({
                success: false,
                error: 'Authentication required.',
                code: 'AUTH_REQUIRED'
            });
            return;
        }
        if (!allowedRoles.includes(req.user.role)) {
            res.status(403).json({
                success: false,
                error: `Access denied. Required roles: ${allowedRoles.join(', ')}`,
                code: 'INSUFFICIENT_ROLE'
            });
            return;
        }
        next();
    };
};
const requirePermission = (requiredPermissions)=>{
    return (req, res, next)=>{
        if (!req.user) {
            res.status(401).json({
                success: false,
                error: 'Authentication required.',
                code: 'AUTH_REQUIRED'
            });
            return;
        }
        const hasPermission = requiredPermissions.some((permission)=>req.user.permissions.includes(permission));
        if (!hasPermission) {
            res.status(403).json({
                success: false,
                error: `Access denied. Required permissions: ${requiredPermissions.join(', ')}`,
                code: 'INSUFFICIENT_PERMISSIONS'
            });
            return;
        }
        next();
    };
};
const refreshToken = (req, res, next)=>{
    try {
        const { refreshToken } = req.body;
        if (!refreshToken) {
            res.status(401).json({
                success: false,
                error: 'Refresh token required.',
                code: 'NO_REFRESH_TOKEN'
            });
            return;
        }
        // Check if refresh token is blacklisted
        if (blacklistedTokens.has(refreshToken)) {
            res.status(401).json({
                success: false,
                error: 'Refresh token has been revoked.',
                code: 'REFRESH_TOKEN_REVOKED'
            });
            return;
        }
        const decoded = _jsonwebtoken.default.verify(refreshToken, JWT_REFRESH_SECRET);
        // Generate new tokens
        const tokens = generateTokens({
            id: decoded.id,
            email: decoded.email,
            role: decoded.role,
            permissions: decoded.permissions
        });
        // Blacklist old refresh token
        blacklistedTokens.add(refreshToken);
        res.json({
            success: true,
            data: tokens
        });
    } catch (error) {
        if (error instanceof _jsonwebtoken.default.TokenExpiredError) {
            res.status(401).json({
                success: false,
                error: 'Refresh token has expired.',
                code: 'REFRESH_TOKEN_EXPIRED'
            });
        } else if (error instanceof _jsonwebtoken.default.JsonWebTokenError) {
            res.status(401).json({
                success: false,
                error: 'Invalid refresh token.',
                code: 'INVALID_REFRESH_TOKEN'
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Token refresh failed.',
                code: 'TOKEN_REFRESH_ERROR'
            });
        }
    }
};
const blacklistToken = (token)=>{
    blacklistedTokens.add(token);
};
const logout = (req, res)=>{
    try {
        const authHeader = req.headers.authorization;
        if (authHeader && authHeader.startsWith('Bearer ')) {
            const token = authHeader.substring(7);
            blacklistToken(token);
        }
        // Also blacklist refresh token if provided
        const { refreshToken } = req.body;
        if (refreshToken) {
            blacklistToken(refreshToken);
        }
        res.json({
            success: true,
            message: 'Logged out successfully'
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            error: 'Logout failed'
        });
    }
};
const cleanupBlacklist = ()=>{
    // In a real implementation, you would check token expiration times
    // and remove expired tokens from the blacklist
    // This is a simplified version
    console.log('Cleaning up token blacklist...');
};
