{"version":3,"sources":["/workspaces/prompt-card-system/backend/src/middleware/auth.ts"],"sourcesContent":["import jwt from 'jsonwebtoken';\nimport bcrypt from 'bcryptjs';\nimport { Request, Response, NextFunction } from 'express';\n\n// Extend Request interface to include user\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: {\n        id: string;\n        email: string;\n        role: string;\n        permissions: string[];\n      };\n    }\n  }\n}\n\nexport interface JWTPayload {\n  id: string;\n  email: string;\n  role: string;\n  permissions: string[];\n  iat?: number;\n  exp?: number;\n}\n\n// JWT Secret keys\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key-change-in-production';\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your-super-secret-refresh-key-change-in-production';\nconst JWT_EXPIRY = process.env.JWT_EXPIRY || '15m';\nconst JWT_REFRESH_EXPIRY = process.env.JWT_REFRESH_EXPIRY || '7d';\n\n// In-memory blacklist for revoked tokens (use Redis in production)\nconst blacklistedTokens = new Set<string>();\n\n// Token generation utilities\nexport const generateTokens = (payload: Omit<JWTPayload, 'iat' | 'exp'>) => {\n  const accessToken = jwt.sign(payload as object, JWT_SECRET as string, { expiresIn: JWT_EXPIRY });\n  const refreshToken = jwt.sign(payload as object, JWT_REFRESH_SECRET as string, { expiresIn: JWT_REFRESH_EXPIRY });\n  \n  return { accessToken, refreshToken };\n};\n\n// Password hashing utilities\nexport const hashPassword = async (password: string): Promise<string> => {\n  const saltRounds = 12;\n  return bcrypt.hash(password, saltRounds);\n};\n\nexport const verifyPassword = async (password: string, hashedPassword: string): Promise<boolean> => {\n  return bcrypt.compare(password, hashedPassword);\n};\n\n// JWT verification middleware\nexport const verifyToken = (req: Request, res: Response, next: NextFunction): void => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      res.status(401).json({\n        success: false,\n        error: 'Access denied. No token provided or invalid format.',\n        code: 'NO_TOKEN'\n      });\n      return;\n    }\n\n    const token = authHeader.substring(7); // Remove 'Bearer ' prefix\n    \n    // Check if token is blacklisted\n    if (blacklistedTokens.has(token)) {\n      res.status(401).json({\n        success: false,\n        error: 'Token has been revoked.',\n        code: 'TOKEN_REVOKED'\n      });\n      return;\n    }\n\n    // Verify token\n    const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;\n    req.user = decoded;\n    next();\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      res.status(401).json({\n        success: false,\n        error: 'Token has expired.',\n        code: 'TOKEN_EXPIRED'\n      });\n    } else if (error instanceof jwt.JsonWebTokenError) {\n      res.status(401).json({\n        success: false,\n        error: 'Invalid token.',\n        code: 'INVALID_TOKEN'\n      });\n    } else {\n      res.status(500).json({\n        success: false,\n        error: 'Token verification failed.',\n        code: 'TOKEN_VERIFICATION_ERROR'\n      });\n    }\n  }\n};\n\n// Optional authentication middleware (doesn't fail if no token)\nexport const optionalAuth = (req: Request, res: Response, next: NextFunction): void => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (!authHeader || !authHeader.startsWith('Bearer ')) {\n      next();\n      return;\n    }\n\n    const token = authHeader.substring(7);\n    \n    if (!blacklistedTokens.has(token)) {\n      const decoded = jwt.verify(token, JWT_SECRET) as JWTPayload;\n      req.user = decoded;\n    }\n    \n    next();\n  } catch (error) {\n    // Ignore token errors in optional auth\n    next();\n  }\n};\n\n// Role-based access control middleware\nexport const requireRole = (allowedRoles: string[]) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(401).json({\n        success: false,\n        error: 'Authentication required.',\n        code: 'AUTH_REQUIRED'\n      });\n      return;\n    }\n\n    if (!allowedRoles.includes(req.user.role)) {\n      res.status(403).json({\n        success: false,\n        error: `Access denied. Required roles: ${allowedRoles.join(', ')}`,\n        code: 'INSUFFICIENT_ROLE'\n      });\n      return;\n    }\n\n    next();\n  };\n};\n\n// Permission-based access control middleware\nexport const requirePermission = (requiredPermissions: string[]) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    if (!req.user) {\n      res.status(401).json({\n        success: false,\n        error: 'Authentication required.',\n        code: 'AUTH_REQUIRED'\n      });\n      return;\n    }\n\n    const hasPermission = requiredPermissions.some(permission => \n      req.user!.permissions.includes(permission)\n    );\n\n    if (!hasPermission) {\n      res.status(403).json({\n        success: false,\n        error: `Access denied. Required permissions: ${requiredPermissions.join(', ')}`,\n        code: 'INSUFFICIENT_PERMISSIONS'\n      });\n      return;\n    }\n\n    next();\n  };\n};\n\n// Refresh token middleware\nexport const refreshToken = (req: Request, res: Response, next: NextFunction): void => {\n  try {\n    const { refreshToken } = req.body;\n    \n    if (!refreshToken) {\n      res.status(401).json({\n        success: false,\n        error: 'Refresh token required.',\n        code: 'NO_REFRESH_TOKEN'\n      });\n      return;\n    }\n\n    // Check if refresh token is blacklisted\n    if (blacklistedTokens.has(refreshToken)) {\n      res.status(401).json({\n        success: false,\n        error: 'Refresh token has been revoked.',\n        code: 'REFRESH_TOKEN_REVOKED'\n      });\n      return;\n    }\n\n    const decoded = jwt.verify(refreshToken, JWT_REFRESH_SECRET) as JWTPayload;\n    \n    // Generate new tokens\n    const tokens = generateTokens({\n      id: decoded.id,\n      email: decoded.email,\n      role: decoded.role,\n      permissions: decoded.permissions\n    });\n\n    // Blacklist old refresh token\n    blacklistedTokens.add(refreshToken);\n\n    res.json({\n      success: true,\n      data: tokens\n    });\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      res.status(401).json({\n        success: false,\n        error: 'Refresh token has expired.',\n        code: 'REFRESH_TOKEN_EXPIRED'\n      });\n    } else if (error instanceof jwt.JsonWebTokenError) {\n      res.status(401).json({\n        success: false,\n        error: 'Invalid refresh token.',\n        code: 'INVALID_REFRESH_TOKEN'\n      });\n    } else {\n      res.status(500).json({\n        success: false,\n        error: 'Token refresh failed.',\n        code: 'TOKEN_REFRESH_ERROR'\n      });\n    }\n  }\n};\n\n// Token blacklisting utilities\nexport const blacklistToken = (token: string): void => {\n  blacklistedTokens.add(token);\n};\n\nexport const logout = (req: Request, res: Response): void => {\n  try {\n    const authHeader = req.headers.authorization;\n    \n    if (authHeader && authHeader.startsWith('Bearer ')) {\n      const token = authHeader.substring(7);\n      blacklistToken(token);\n    }\n\n    // Also blacklist refresh token if provided\n    const { refreshToken } = req.body;\n    if (refreshToken) {\n      blacklistToken(refreshToken);\n    }\n\n    res.json({\n      success: true,\n      message: 'Logged out successfully'\n    });\n  } catch (error) {\n    res.status(500).json({\n      success: false,\n      error: 'Logout failed'\n    });\n  }\n};\n\n// Clean up expired tokens from blacklist (should be run periodically)\nexport const cleanupBlacklist = (): void => {\n  // In a real implementation, you would check token expiration times\n  // and remove expired tokens from the blacklist\n  // This is a simplified version\n  console.log('Cleaning up token blacklist...');\n};"],"names":["blacklistToken","cleanupBlacklist","generateTokens","hashPassword","logout","optionalAuth","refreshToken","requirePermission","requireRole","verifyPassword","verifyToken","JWT_SECRET","process","env","JWT_REFRESH_SECRET","JWT_EXPIRY","JWT_REFRESH_EXPIRY","blacklistedTokens","Set","payload","accessToken","jwt","sign","expiresIn","password","saltRounds","bcrypt","hash","hashedPassword","compare","req","res","next","authHeader","headers","authorization","startsWith","status","json","success","error","code","token","substring","has","decoded","verify","user","TokenExpiredError","JsonWebTokenError","allowedRoles","includes","role","join","requiredPermissions","hasPermission","some","permission","permissions","body","tokens","id","email","add","data","message","console","log"],"mappings":"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"}