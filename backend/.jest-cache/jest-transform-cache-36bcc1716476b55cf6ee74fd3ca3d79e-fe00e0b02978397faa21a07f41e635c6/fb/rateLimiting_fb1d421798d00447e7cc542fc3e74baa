555439a266f05f5136bfcb7759bedf96
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get apiRateLimit () {
        return apiRateLimit;
    },
    get authRateLimit () {
        return authRateLimit;
    },
    get generalRateLimit () {
        return generalRateLimit;
    },
    get heavyOperationRateLimit () {
        return heavyOperationRateLimit;
    },
    get speedLimiter () {
        return speedLimiter;
    },
    get testExecutionRateLimit () {
        return testExecutionRateLimit;
    },
    get uploadRateLimit () {
        return uploadRateLimit;
    }
});
const _expressratelimit = /*#__PURE__*/ _interop_require_default(require("express-rate-limit"));
const _expressslowdown = /*#__PURE__*/ _interop_require_default(require("express-slow-down"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const generalRateLimit = (0, _expressratelimit.default)({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message: {
        success: false,
        error: 'Too many requests from this IP, please try again later.',
        retryAfter: 15 * 60 // seconds
    },
    standardHeaders: true,
    legacyHeaders: false,
    // store: new RedisStore({
    //   sendCommand: (...args: string[]) => redis.call(...args),
    // }),
    handler: (req, res)=>{
        res.status(429).json({
            success: false,
            error: 'Rate limit exceeded',
            limit: 100,
            windowMs: 15 * 60 * 1000,
            retryAfter: Math.round(15 * 60),
            ip: req.ip,
            path: req.path
        });
    }
});
const authRateLimit = (0, _expressratelimit.default)({
    windowMs: 15 * 60 * 1000,
    max: 5,
    message: {
        success: false,
        error: 'Too many authentication attempts, please try again later.',
        retryAfter: 15 * 60
    },
    standardHeaders: true,
    legacyHeaders: false,
    skipSuccessfulRequests: true,
    handler: (req, res)=>{
        res.status(429).json({
            success: false,
            error: 'Authentication rate limit exceeded',
            limit: 5,
            windowMs: 15 * 60 * 1000,
            retryAfter: Math.round(15 * 60),
            ip: req.ip,
            path: req.path
        });
    }
});
const apiRateLimit = (0, _expressratelimit.default)({
    windowMs: 1 * 60 * 1000,
    max: 50,
    message: {
        success: false,
        error: 'API rate limit exceeded',
        retryAfter: 60
    },
    standardHeaders: true,
    legacyHeaders: false
});
const testExecutionRateLimit = (0, _expressratelimit.default)({
    windowMs: 5 * 60 * 1000,
    max: 20,
    message: {
        success: false,
        error: 'Test execution rate limit exceeded',
        retryAfter: 5 * 60
    },
    standardHeaders: true,
    legacyHeaders: false
});
const speedLimiter = (0, _expressslowdown.default)({
    windowMs: 15 * 60 * 1000,
    delayAfter: 50,
    delayMs: (used)=>{
        return (used - 50) * 500; // Add 500ms delay for each request after delayAfter
    },
    maxDelayMs: 10000,
    skipFailedRequests: false,
    skipSuccessfulRequests: false
});
const heavyOperationRateLimit = (0, _expressratelimit.default)({
    windowMs: 60 * 60 * 1000,
    max: 10,
    message: {
        success: false,
        error: 'Heavy operation rate limit exceeded',
        retryAfter: 60 * 60
    },
    standardHeaders: true,
    legacyHeaders: false
});
const uploadRateLimit = (0, _expressratelimit.default)({
    windowMs: 60 * 60 * 1000,
    max: 20,
    message: {
        success: false,
        error: 'Upload rate limit exceeded',
        retryAfter: 60 * 60
    },
    standardHeaders: true,
    legacyHeaders: false
});
