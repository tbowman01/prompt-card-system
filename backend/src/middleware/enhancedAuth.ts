import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';
import { randomBytes, createHash, timingSafeEqual } from 'crypto';
import speakeasy from 'speakeasy';
import QRCode from 'qrcode';

// Enhanced Authentication Interfaces
interface User {
  id: string;
  email: string;
  passwordHash: string;
  role: UserRole;
  permissions: Permission[];
  mfaEnabled: boolean;
  mfaSecret?: string;
  accountLocked: boolean;
  lockoutUntil?: Date;
  failedLoginAttempts: number;
  lastLogin?: Date;
  sessionIds: string[];
  passwordHistory: string[];
  emailVerified: boolean;
  createdAt: Date;
  updatedAt: Date;
}

interface Session {
  id: string;
  userId: string;
  token: string;
  refreshToken: string;
  fingerprint: string;
  ipAddress: string;
  userAgent: string;
  isActive: boolean;
  expiresAt: Date;
  createdAt: Date;
  lastActivity: Date;
}

interface AuthConfig {
  jwtSecret: string;
  refreshSecret: string;
  accessTokenExpiry: string;
  refreshTokenExpiry: string;
  maxLoginAttempts: number;
  lockoutDuration: number;
  sessionTimeout: number;
  passwordMinLength: number;
  passwordHistoryCount: number;
  requireEmailVerification: boolean;
  enableMFA: boolean;
}

type UserRole = 'admin' | 'moderator' | 'user' | 'readonly';
type Permission = 'read' | 'write' | 'delete' | 'admin' | 'moderate' | 'manage_users' | 'view_analytics';

// Default configuration
const defaultAuthConfig: AuthConfig = {
  jwtSecret: process.env.JWT_SECRET || 'fallback-secret-change-in-production',
  refreshSecret: process.env.JWT_REFRESH_SECRET || 'fallback-refresh-secret',
  accessTokenExpiry: process.env.JWT_EXPIRY || '15m',
  refreshTokenExpiry: process.env.JWT_REFRESH_EXPIRY || '7d',
  maxLoginAttempts: parseInt(process.env.MAX_LOGIN_ATTEMPTS || '5'),
  lockoutDuration: parseInt(process.env.LOCKOUT_DURATION || '900000'), // 15 minutes
  sessionTimeout: parseInt(process.env.SESSION_TIMEOUT || '3600000'), // 1 hour
  passwordMinLength: parseInt(process.env.PASSWORD_MIN_LENGTH || '12'),
  passwordHistoryCount: parseInt(process.env.PASSWORD_HISTORY_COUNT || '5'),
  requireEmailVerification: process.env.REQUIRE_EMAIL_VERIFICATION === 'true',
  enableMFA: process.env.ENABLE_MFA === 'true'
};\n\n// In-memory storage (replace with database in production)\nconst users = new Map<string, User>();\nconst sessions = new Map<string, Session>();\nconst blacklistedTokens = new Set<string>();\nconst emailVerificationTokens = new Map<string, { email: string; expires: Date }>();\nconst passwordResetTokens = new Map<string, { userId: string; expires: Date }>();\n\n// Role-based permissions\nconst rolePermissions: Record<UserRole, Permission[]> = {\n  admin: ['read', 'write', 'delete', 'admin', 'moderate', 'manage_users', 'view_analytics'],\n  moderator: ['read', 'write', 'delete', 'moderate', 'view_analytics'],\n  user: ['read', 'write'],\n  readonly: ['read']\n};\n\n// Password strength validation\nexport const validatePassword = (password: string): { valid: boolean; errors: string[] } => {\n  const errors: string[] = [];\n  \n  if (password.length < defaultAuthConfig.passwordMinLength) {\n    errors.push(`Password must be at least ${defaultAuthConfig.passwordMinLength} characters long`);\n  }\n  \n  if (!/[A-Z]/.test(password)) {\n    errors.push('Password must contain at least one uppercase letter');\n  }\n  \n  if (!/[a-z]/.test(password)) {\n    errors.push('Password must contain at least one lowercase letter');\n  }\n  \n  if (!/\\d/.test(password)) {\n    errors.push('Password must contain at least one number');\n  }\n  \n  if (!/[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]/.test(password)) {\n    errors.push('Password must contain at least one special character');\n  }\n  \n  // Check for common weak passwords\n  const commonPasswords = ['password', '123456', 'admin', 'user', 'test', 'login'];\n  if (commonPasswords.some(common => password.toLowerCase().includes(common))) {\n    errors.push('Password contains commonly used words');\n  }\n  \n  return { valid: errors.length === 0, errors };\n};\n\n// Password hashing with enhanced security\nexport const hashPassword = async (password: string): Promise<string> => {\n  const saltRounds = 14; // Increased for better security\n  return await bcrypt.hash(password, saltRounds);\n};\n\n// Check password history to prevent reuse\nexport const checkPasswordHistory = async (userId: string, newPassword: string): Promise<boolean> => {\n  const user = users.get(userId);\n  if (!user || !user.passwordHistory) return true;\n  \n  for (const oldPasswordHash of user.passwordHistory) {\n    if (await bcrypt.compare(newPassword, oldPasswordHash)) {\n      return false;\n    }\n  }\n  \n  return true;\n};\n\n// Generate secure session\nconst generateSession = (user: User, fingerprint: string, ipAddress: string, userAgent: string): Session => {\n  const sessionId = randomBytes(32).toString('hex');\n  const accessToken = jwt.sign(\n    {\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n      permissions: rolePermissions[user.role],\n      sessionId\n    },\n    defaultAuthConfig.jwtSecret,\n    { expiresIn: defaultAuthConfig.accessTokenExpiry }\n  );\n  \n  const refreshToken = jwt.sign(\n    { userId: user.id, sessionId, type: 'refresh' },\n    defaultAuthConfig.refreshSecret,\n    { expiresIn: defaultAuthConfig.refreshTokenExpiry }\n  );\n  \n  const session: Session = {\n    id: sessionId,\n    userId: user.id,\n    token: accessToken,\n    refreshToken,\n    fingerprint,\n    ipAddress,\n    userAgent,\n    isActive: true,\n    expiresAt: new Date(Date.now() + defaultAuthConfig.sessionTimeout),\n    createdAt: new Date(),\n    lastActivity: new Date()\n  };\n  \n  sessions.set(sessionId, session);\n  return session;\n};\n\n// Enhanced authentication middleware\nexport const enhancedAuth = (requiredPermissions: Permission[] = []) => {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    try {\n      const authHeader = req.headers.authorization;\n      \n      if (!authHeader || !authHeader.startsWith('Bearer ')) {\n        return res.status(401).json({\n          success: false,\n          error: 'Access token required',\n          code: 'TOKEN_REQUIRED'\n        });\n      }\n      \n      const token = authHeader.substring(7);\n      \n      // Check if token is blacklisted\n      if (blacklistedTokens.has(token)) {\n        return res.status(401).json({\n          success: false,\n          error: 'Token has been revoked',\n          code: 'TOKEN_REVOKED'\n        });\n      }\n      \n      // Verify and decode token\n      const decoded = jwt.verify(token, defaultAuthConfig.jwtSecret) as any;\n      const sessionId = decoded.sessionId;\n      \n      // Check session validity\n      const session = sessions.get(sessionId);\n      if (!session || !session.isActive || session.expiresAt < new Date()) {\n        return res.status(401).json({\n          success: false,\n          error: 'Session expired or invalid',\n          code: 'SESSION_INVALID'\n        });\n      }\n      \n      // Verify user exists and is not locked\n      const user = users.get(decoded.userId);\n      if (!user) {\n        return res.status(401).json({\n          success: false,\n          error: 'User not found',\n          code: 'USER_NOT_FOUND'\n        });\n      }\n      \n      if (user.accountLocked && user.lockoutUntil && user.lockoutUntil > new Date()) {\n        return res.status(423).json({\n          success: false,\n          error: 'Account is temporarily locked',\n          code: 'ACCOUNT_LOCKED',\n          lockoutUntil: user.lockoutUntil\n        });\n      }\n      \n      // Check permissions\n      if (requiredPermissions.length > 0) {\n        const userPermissions = rolePermissions[user.role] || [];\n        const hasPermission = requiredPermissions.some(perm => \n          userPermissions.includes(perm)\n        );\n        \n        if (!hasPermission) {\n          return res.status(403).json({\n            success: false,\n            error: 'Insufficient permissions',\n            code: 'INSUFFICIENT_PERMISSIONS',\n            required: requiredPermissions,\n            userPermissions\n          });\n        }\n      }\n      \n      // Update session activity\n      session.lastActivity = new Date();\n      sessions.set(sessionId, session);\n      \n      // Add user context to request\n      (req as any).user = {\n        id: user.id,\n        email: user.email,\n        role: user.role,\n        permissions: rolePermissions[user.role],\n        sessionId: session.id\n      };\n      \n      next();\n    } catch (error) {\n      if (error instanceof jwt.JsonWebTokenError) {\n        return res.status(401).json({\n          success: false,\n          error: 'Invalid token',\n          code: 'TOKEN_INVALID'\n        });\n      }\n      \n      console.error('Authentication error:', error);\n      return res.status(500).json({\n        success: false,\n        error: 'Authentication failed',\n        code: 'AUTH_ERROR'\n      });\n    }\n  };\n};\n\n// User registration with enhanced validation\nexport const registerUser = async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { email, password, confirmPassword, role = 'user' } = req.body;\n    \n    // Validation\n    if (!email || !password || !confirmPassword) {\n      return res.status(400).json({\n        success: false,\n        error: 'Email, password, and password confirmation are required',\n        code: 'MISSING_FIELDS'\n      });\n    }\n    \n    if (password !== confirmPassword) {\n      return res.status(400).json({\n        success: false,\n        error: 'Passwords do not match',\n        code: 'PASSWORD_MISMATCH'\n      });\n    }\n    \n    // Validate email format\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      return res.status(400).json({\n        success: false,\n        error: 'Invalid email format',\n        code: 'INVALID_EMAIL'\n      });\n    }\n    \n    // Check if user already exists\n    const existingUser = Array.from(users.values()).find(u => u.email === email);\n    if (existingUser) {\n      return res.status(409).json({\n        success: false,\n        error: 'User with this email already exists',\n        code: 'USER_EXISTS'\n      });\n    }\n    \n    // Validate password strength\n    const passwordValidation = validatePassword(password);\n    if (!passwordValidation.valid) {\n      return res.status(400).json({\n        success: false,\n        error: 'Password does not meet security requirements',\n        code: 'WEAK_PASSWORD',\n        details: passwordValidation.errors\n      });\n    }\n    \n    // Hash password and create user\n    const passwordHash = await hashPassword(password);\n    const userId = randomBytes(16).toString('hex');\n    \n    const user: User = {\n      id: userId,\n      email,\n      passwordHash,\n      role: role as UserRole,\n      permissions: rolePermissions[role as UserRole] || [],\n      mfaEnabled: false,\n      accountLocked: false,\n      failedLoginAttempts: 0,\n      sessionIds: [],\n      passwordHistory: [passwordHash],\n      emailVerified: !defaultAuthConfig.requireEmailVerification,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n    \n    users.set(userId, user);\n    \n    // Send email verification if required\n    if (defaultAuthConfig.requireEmailVerification) {\n      const verificationToken = randomBytes(32).toString('hex');\n      emailVerificationTokens.set(verificationToken, {\n        email,\n        expires: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n      });\n      \n      // In production, send email with verification link\n      console.log(`Email verification token for ${email}: ${verificationToken}`);\n    }\n    \n    res.status(201).json({\n      success: true,\n      message: defaultAuthConfig.requireEmailVerification \n        ? 'User registered. Please verify your email.'\n        : 'User registered successfully',\n      data: {\n        userId: user.id,\n        email: user.email,\n        role: user.role,\n        emailVerified: user.emailVerified\n      }\n    });\n  } catch (error) {\n    console.error('Registration error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Registration failed',\n      code: 'REGISTRATION_ERROR'\n    });\n  }\n};\n\n// Enhanced login with account lockout and fingerprinting\nexport const loginUser = async (req: Request, res: Response): Promise<void> => {\n  try {\n    const { email, password, mfaToken, fingerprint } = req.body;\n    const ipAddress = req.ip || 'unknown';\n    const userAgent = req.headers['user-agent'] || 'unknown';\n    \n    if (!email || !password) {\n      return res.status(400).json({\n        success: false,\n        error: 'Email and password are required',\n        code: 'MISSING_CREDENTIALS'\n      });\n    }\n    \n    // Find user\n    const user = Array.from(users.values()).find(u => u.email === email);\n    if (!user) {\n      return res.status(401).json({\n        success: false,\n        error: 'Invalid credentials',\n        code: 'INVALID_CREDENTIALS'\n      });\n    }\n    \n    // Check account lockout\n    if (user.accountLocked && user.lockoutUntil && user.lockoutUntil > new Date()) {\n      return res.status(423).json({\n        success: false,\n        error: 'Account is temporarily locked due to too many failed attempts',\n        code: 'ACCOUNT_LOCKED',\n        lockoutUntil: user.lockoutUntil\n      });\n    }\n    \n    // Check email verification\n    if (defaultAuthConfig.requireEmailVerification && !user.emailVerified) {\n      return res.status(403).json({\n        success: false,\n        error: 'Email verification required',\n        code: 'EMAIL_NOT_VERIFIED'\n      });\n    }\n    \n    // Verify password\n    const passwordValid = await bcrypt.compare(password, user.passwordHash);\n    if (!passwordValid) {\n      // Increment failed attempts\n      user.failedLoginAttempts++;\n      \n      // Lock account if too many failures\n      if (user.failedLoginAttempts >= defaultAuthConfig.maxLoginAttempts) {\n        user.accountLocked = true;\n        user.lockoutUntil = new Date(Date.now() + defaultAuthConfig.lockoutDuration);\n      }\n      \n      user.updatedAt = new Date();\n      users.set(user.id, user);\n      \n      return res.status(401).json({\n        success: false,\n        error: 'Invalid credentials',\n        code: 'INVALID_CREDENTIALS',\n        attemptsRemaining: Math.max(0, defaultAuthConfig.maxLoginAttempts - user.failedLoginAttempts)\n      });\n    }\n    \n    // Check MFA if enabled\n    if (user.mfaEnabled && user.mfaSecret) {\n      if (!mfaToken) {\n        return res.status(200).json({\n          success: false,\n          requireMFA: true,\n          message: 'MFA token required',\n          code: 'MFA_REQUIRED'\n        });\n      }\n      \n      const verified = speakeasy.totp.verify({\n        secret: user.mfaSecret,\n        encoding: 'base32',\n        token: mfaToken,\n        window: 2\n      });\n      \n      if (!verified) {\n        return res.status(401).json({\n          success: false,\n          error: 'Invalid MFA token',\n          code: 'INVALID_MFA'\n        });\n      }\n    }\n    \n    // Reset failed attempts\n    user.failedLoginAttempts = 0;\n    user.accountLocked = false;\n    user.lockoutUntil = undefined;\n    user.lastLogin = new Date();\n    user.updatedAt = new Date();\n    \n    // Generate session\n    const session = generateSession(user, fingerprint || '', ipAddress, userAgent);\n    user.sessionIds.push(session.id);\n    \n    users.set(user.id, user);\n    \n    res.json({\n      success: true,\n      message: 'Login successful',\n      data: {\n        user: {\n          id: user.id,\n          email: user.email,\n          role: user.role,\n          permissions: rolePermissions[user.role],\n          lastLogin: user.lastLogin\n        },\n        tokens: {\n          accessToken: session.token,\n          refreshToken: session.refreshToken,\n          expiresAt: session.expiresAt\n        },\n        session: {\n          id: session.id,\n          expiresAt: session.expiresAt\n        }\n      }\n    });\n  } catch (error) {\n    console.error('Login error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'Login failed',\n      code: 'LOGIN_ERROR'\n    });\n  }\n};\n\n// Setup MFA for user\nexport const setupMFA = async (req: Request, res: Response): Promise<void> => {\n  try {\n    const userId = (req as any).user.id;\n    const user = users.get(userId);\n    \n    if (!user) {\n      return res.status(404).json({\n        success: false,\n        error: 'User not found',\n        code: 'USER_NOT_FOUND'\n      });\n    }\n    \n    // Generate MFA secret\n    const secret = speakeasy.generateSecret({\n      name: `Prompt Card System (${user.email})`,\n      issuer: 'Prompt Card System',\n      length: 32\n    });\n    \n    // Generate QR code\n    const qrCodeUrl = await QRCode.toDataURL(secret.otpauth_url!);\n    \n    // Store secret temporarily (user must verify to enable)\n    (user as any).tempMfaSecret = secret.base32;\n    users.set(userId, user);\n    \n    res.json({\n      success: true,\n      data: {\n        secret: secret.base32,\n        qrCode: qrCodeUrl,\n        manualEntryKey: secret.base32\n      }\n    });\n  } catch (error) {\n    console.error('MFA setup error:', error);\n    res.status(500).json({\n      success: false,\n      error: 'MFA setup failed',\n      code: 'MFA_SETUP_ERROR'\n    });\n  }\n};\n\n// Export utility functions\nexport {\n  users,\n  sessions,\n  blacklistedTokens,\n  rolePermissions,\n  defaultAuthConfig\n};